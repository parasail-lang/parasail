-- Sparkel Prototype Standard Library

-- Copyright (C) 2011-2013, AdaCore, New York, NY
-- To be used only for Personal, Academic, or Evaluation Purposes
-- Not for Commercial Production Use.

package SSL is
end package SSL

with SSL.*
package SSL.Core is
end package SSL.Core

package SSL.Core.Any is
    type Any is abstract limited null record;
end package SSL.Core.Any

package SSL.Core.Assignable is
    type Assignable is abstract null record;

end package SSL.Core.Assignable

package SSL.Containers is
end package SSL.Containers

package SSL.Test is
end package SSL.Test

package SSL.Core.Imageable is
    type Imageable is abstract private;

    abstract func Image(Val : Imageable) return Univ_String

    abstract func Value(Str : Univ_String) return optional Imageable

    -- NOTE: We include Hashable<> operations here
    --       so that Set<Imageable+> works nicely.
    --       Clearly if something is Imageable it is possible
    --       to implement "=?" and Hash using the string image,
    --       so we might as well requires these operations too.

    abstract func "=?"(Left, Right : Imageable) return Ordering
    abstract func Hash(Val : Imageable) return Univ_Integer
end package SSL.Core.Imageable

generic
    type Element_Type is new Countable_Base
package SSL.Containers.Countable_Set is

    type Countable_Set is private

    func "[]"() return Countable_Set

    func Singleton(Elem : Element_Type) return Countable_Set

    func ".."(Left, Right : Element_Type) return Countable_Set
    func "<.."(Left, Right : Element_Type) return Countable_Set
    func "..<"(Left, Right : Element_Type) return Countable_Set
    func "<..<"(Left, Right : Element_Type) return Countable_Set

    func "|"(Left, Right : Element_Type) return Countable_Set
    func "|"(Left : Countable_Set; Right : Element_Type) return Countable_Set
    func "|"(Left : Element_Type; Right : Countable_Set) return Countable_Set
    func "|"(Left : Countable_Set; Right : Countable_Set) return Countable_Set

    proc "|="(var Left : Countable_Set; Right : Element_Type)
    proc "|="(var Left : Countable_Set; Right : Countable_Set)

    proc "<|="(var Left : Countable_Set; var Right : optional Element_Type)
        -- Move element into set, leaving Right null afterward.

    proc "<|="(var Left : Countable_Set; var Right : Countable_Set)
        -- Move all elements of Right into Left, leaving Right empty.

    func "-"(Left, Right : Countable_Set) return Countable_Set
      -- Set difference
    func "-"(Left : Countable_Set; Right : Element_Type) return Countable_Set
      -- Remove one element
    proc "-="(var S : Countable_Set; Elem : Element_Type)
      -- Remove the given element from the set, if present
    proc "-="(var Left : Countable_Set; Right : Countable_Set)
      -- Remove all elements of Right from Left, if present

    func "or"(Left : Countable_Set; Right : Countable_Set) 
      return Countable_Set is "|"   -- union
    proc "or="(var Left : Countable_Set; Right : Countable_Set) is "|="

    func "+"(Left : Countable_Set; Right : Countable_Set) 
      return Countable_Set is "|"   -- Union
    proc "+="(var Left : Countable_Set; Right : Countable_Set) is "|="
    proc "+="(var Left : Countable_Set; Right : Element_Type) is "|="
   
    func "and"(Left, Right : Countable_Set) return Countable_Set
        -- Intersection
    proc "and="(var Left : Countable_Set; Right : Countable_Set)

    func "xor"(Left, Right : Countable_Set) return Countable_Set
        -- Symmetric difference
    proc "xor="(var Left : Countable_Set; Right : Countable_Set)

    func "in"(Left : Element_Type; Right : Countable_Set) return Boolean

    func "=?"(Left, Right : Countable_Set) return Ordering
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise

    func Count(S : Countable_Set) return Univ_Integer

    func "magnitude"(Countable_Set) return Univ_Integer is Count

    func Is_Empty(S : Countable_Set) return Boolean

    func First(S : Countable_Set) return optional Element_Type
    func Last(S : Countable_Set) return optional Element_Type

    func Remove_First(var S : Countable_Set) return optional Element_Type
        -- Remove first element of set (lowest value)

    func Remove_Last(var S : Countable_Set) return optional Element_Type
        -- Remove last element of set (highest value)

    func Remove_Any(var S : Countable_Set) return optional Element_Type
        -- Remove an arbitrary element of set

end package SSL.Containers.Countable_Set

package SSL.Core.Univ_Integer is
    type Univ_Integer is private;

    func "+"(Right : Univ_Integer) return Univ_Integer
      is import(#identity)

    func "-"(Right : Univ_Integer) return Univ_Integer
      is import(#negate)

    func "abs"(Right : Univ_Integer) return Univ_Integer
      is import("abs")

    func "magnitude"(Univ_Integer) return Univ_Integer is "abs"

    func "+"(Left, Right : Univ_Integer) return Result : Univ_Integer 
      is import("+")

    func "-"(Left, Right : Univ_Integer) return Result : Univ_Integer
      is import("-")

    func "*"(Left, Right : Univ_Integer) return Result : Univ_Integer 
      is import("*")

    func "/"(Left, Right : Univ_Integer) return Result : Univ_Integer
      is import("/")

    func "**"(Left, Right : Univ_Integer) return Univ_Integer
      is import("**")

    func "mod"(Left, Right : Univ_Integer) return Univ_Integer
      is import("mod")

    func "rem"(Left, Right : Univ_Integer) return Univ_Integer
      is import("rem")


    proc "+="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("+=")

    proc "-="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("-=")

    proc "*="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("*=")

    proc "/="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("/=")

    proc "**="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("**=")


    func "=?"(Left, Right : Univ_Integer) return Ordering
      is import("=?")

    func ">>"(Univ_Integer; Univ_Integer) return Univ_Integer is import(">>")

    func "<<"(Univ_Integer; Univ_Integer) return Univ_Integer is import("<<")

    func Min(Left, Right : optional Univ_Integer) return optional Univ_Integer
      is import(#min)
    func Max(Left, Right : optional Univ_Integer) return optional Univ_Integer
      is import(#max)

    func Hash(Val : Univ_Integer) return Univ_Integer
      is import(#identity)

    proc Print(X : Univ_Integer) is import(#print_int)

    proc Put(X : Univ_Integer) is Print

    func Image(Val : Univ_Integer) return Univ_String
      is import(#to_string_int)

    func Value(Str : Univ_String) return optional Univ_Integer
      is import(#from_string_int)

    func First() return Univ_Integer is
      import(#univ_integer_first)

    func Last() return Univ_Integer is
      import(#univ_integer_last)

    func ".."(Left, Right : Univ_Integer) return Countable_Set<Univ_Integer>
      is of Countable_Set<Univ_Integer>
    func "<.."(Left, Right : Univ_Integer) return Countable_Set<Univ_Integer>
      is of Countable_Set<Univ_Integer>
    func "..<"(Left, Right : Univ_Integer) return Countable_Set<Univ_Integer>
      is of Countable_Set<Univ_Integer>
    func "<..<"(Left, Right : Univ_Integer) return Countable_Set<Univ_Integer>
      is of Countable_Set<Univ_Integer>
    func "|"(Left, Right : Univ_Integer) return Countable_Set<Univ_Integer>
      is of Countable_Set<Univ_Integer>
end package SSL.Core.Univ_Integer

generic
    type Elem_Type is new Assignable;
    type Index_Type is new Countable
package SSL.Core.Indexable is
    -- An indexable container
    type Indexable is abstract private

    abstract func "indexing"(ref A : Indexable; Index : Index_Type)
      return ref Elem_Type
    abstract func Length(A : Indexable) return Univ_Integer
    abstract func "magnitude"(Indexable) return Univ_Integer is Length
    abstract func "index_set"(A : Indexable) return Countable_Set<Index_Type>
    abstract func Bounds(A : Indexable) return Countable_Set<Index_Type>
      is "index_set"
end package SSL.Core.Indexable

generic
    type Element_Type is new Assignable  -- tbd "is private"
package SSL.Containers.Basic_Array is
  -- Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    type Basic_Array is private;

    func Create(Length : Univ_Integer; Val : optional Element_Type)
      return Basic_Array 
      is import(#basic_array_create)
    func "[]"() return Basic_Array is (Create(0, null))
    func "indexing"(ref V : Basic_Array; Index : Univ_Integer) return 
      ref Element_Type is import(#basic_array_indexing)
    func "var_indexing"(ref var V : Basic_Array; Index : Univ_Integer) return 
      ref var Element_Type is import(#basic_array_indexing)
    func Length(V : Basic_Array) return Univ_Integer
      is import(#basic_array_length)
    func "magnitude"(Basic_Array) return Univ_Integer is Length
    func "|"(Left, Right : Basic_Array) return Basic_Array
    func "&"(Left, Right : Basic_Array) return Basic_Array is "|"
    func "index_set"(A : Basic_Array) return Countable_Set<Univ_Integer>
    proc "<|="(var Left : Basic_Array; var Right : optional Element_Type)
end package SSL.Containers.Basic_Array

package body SSL.Containers.Basic_Array is
  -- Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
  exports
    func "|"(Left, Right : Basic_Array) return Result : Basic_Array is
        const Left_Len := Length(Left)

        if Left_Len = 0 then
            return Right
        end if

        Result := Create(Left_Len + Length(Right), null)

        -- Copy the Left elements
        for I in 1..Left_Len parallel loop
            Result[I] := Left[I]
        end loop

        -- Copy the Right elements
        
        for J in 1..Length(Right) parallel loop
            Result[Left_Len + J] := Right[J]
        end loop
    end func "|"
            
    func "index_set"(A : Basic_Array) return Countable_Set<Univ_Integer> is
        return 1..Length(A)
    end func "index_set"

    proc "<|="(var Left : Basic_Array; var Right : optional Element_Type) is
        const Left_Len := |Left|
        var Result : Basic_Array for Left := Create(Left_Len+1, null)

        for I in 1 .. Left_Len parallel loop
            Result[I] <== Left[I]
        end loop

        Result[Left_Len+1] <== Right

        Left <== Result
    end proc "<|="
end package SSL.Containers.Basic_Array

proc SSL.Test.Test_Basic_Array() is
    var A : Basic_Array<Univ_Integer<>> := Create(3, 7)
    A[1] := 42
    A[2] += 6
    A[3] += A[2]
    Print("The answer is: " & (A[1] + A[2] + A[3]) & "\n")
    Print("Length(A) = " & Length(A) & "\n")

    var B := A | A
    Print("Length(B) = " & Length(B) & ", B[5] = " & B[5] & "\n")
    for I in 1..Length(B) forward loop
        Print("B[" & I & "] = " & B[I] & ", ")
    end loop
    Print("\n")
end proc SSL.Test.Test_Basic_Array
    
generic
    type Element_Type is new Assignable  -- tbd: is private
package SSL.Core.Vector is
  -- Extendable vector, indexed by Univ_Integer, 1..Length
    type Vector is new Indexable<Element_Type, Univ_Integer> with private

    func "[]"() return Vector
    func Create(Length : Univ_Integer; Initial_Value : Element_Type)
      {Length >= 0} return Vector
    func "indexing"(ref V : Vector; Index : Univ_Integer) return 
      ref Element_Type
    func "index_set"(V : Vector) return Countable_Set<Univ_Integer>
    func "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      return Vector  -- a "read-only" slice
    proc "|="(var V : Vector; Elem : Element_Type)
    proc "&="(var V : Vector; Elem : Element_Type) is "|="
    proc "|="(var V : Vector; Right : Vector)
    proc "<|="(var V : Vector; var Elem : optional Element_Type)
    func "|"(Left, Right : Vector) return Vector
    func "|"(Left : Vector; Right : Element_Type) return Vector
    func "&"(Left, Right : Vector) return Vector is "|"
    func "&"(Left : Vector; Right : Element_Type) return Vector is "|"
    func Length(V : Vector) return Univ_Integer
    func "magnitude"(Vector) return Univ_Integer is Length
end package SSL.Core.Vector
    
package body SSL.Core.Vector is
  -- Extendable vector, indexed by Univ_Integer, 1..Length
    const Debug := #False;
    const Initial_Size := 4
    const Leaf_Vec_Capacity := 256
    const Vec_Of_Vec_Length := 256
    const Subvec_Capacity : Basic_Array<Univ_Integer> :=
      -- Capacity of each subvec at given level
      [Leaf_Vec_Capacity,
       Vec_Of_Vec_Length * Leaf_Vec_Capacity,
       Vec_Of_Vec_Length ** 2 * Leaf_Vec_Capacity]
    const Ordinal : Basic_Array<Univ_String> :=
      ["th","st","nd","rd","th","th","th","th","th","th"]

    type Vector is record
       const Level : Univ_Integer;       --  Level = 0 means only Data array
       Count       : Univ_Integer := 0;  --  Overall count
       Width       : Univ_Integer := 0;  --  Num Subvecs in use;
                                         --  is 0 if level = 0
       Data        : optional Basic_Array<optional Element_Type> := null;
       Subvecs     : optional Basic_Array<optional Vector> := null;
    end record;

    proc Expand_Count(var V : Vector; Amount : Univ_Integer := 1) is
        -- Expand count by "Amount"
        {> Amount > 0 <}
        --Rep_Ok(V, 1)
        const New_Count := V.Count + Amount;

        loop
            var Next_Count := New_Count

            if V.Level = 0 then
                --  A single Basic_Array of elements
                Next_Count := Min (New_Count, Leaf_Vec_Capacity)
                if V.Data is null then
                    --  Very first element
                    if Debug then
                        Println("Very first element");
                    end if;
                    V.Data := Create(Max(Initial_Size, Next_Count), null)
                    --Rep_Ok(V, 5555);
                elsif V.Count = Length(V.Data) or New_Count > Length(V.Data)
                then
                    --  Double the size if below capacity, else add a level
                    if V.Count < Leaf_Vec_Capacity then
                        -- Double the size (up to the max)
                        if Debug then
                            Println("Doubling Data, V.Count was " | V.Count)
                        end if
                        var Old_Data <== V.Data
                        V.Data := Create(Min (Max (2*V.Count, Next_Count),
                                              Leaf_Vec_Capacity), null)
                        for I in 1..V.Count loop
                            V.Data[I] <== Old_Data[I]
                        end loop
                        Old_Data := null
                        --Rep_Ok(V, 6666);
                    else
                        -- Reached maximum, add one level
                        {> Next_Count = V.Count <}
                        --Rep_Ok(V, 3333);
                        if Debug then
                            Println("Adding second level, V.Count was " |
                              V.Count)
                        end if;
                        var Old_V <== V
                        V := (Level => 1,
                              Count => Next_Count,
                              Width => 2,
                              Subvecs => Create (Vec_Of_Vec_Length, null),
                              Data => null)
                        V.Subvecs[1] <== Old_V
                        V.Subvecs[2] :=
                          (Level => 0, Count => 0, Width => 0,
                           Subvecs => null,
                           Data => Create(Leaf_Vec_Capacity, null));
                        --  Will loop around to extend this two-level structure
                        --Rep_Ok(V, 4444);
                    end if;
                else
                    if Debug then
                        Println(Next_Count | ", " | New_Count);
                    end if;
                end if
            else
                --  Multi-level structure, expand last subvec or add another
                if V.Width > 0 and then
                    V.Subvecs[V.Width].Count < Subvec_Capacity[V.Level]
                then
                    --  Can expand this subvec up to its capacity
                    if Debug then
                        Println("Expand Subvec " | V.Width |
                          ", V.Count was " | V.Count)
                    end if;
                    ref Last_Subvec => V.Subvecs[V.Width]
                    const Subvec_Increase := Min (New_Count - V.Count,
                      Subvec_Capacity[V.Level] - Last_Subvec.Count)
                    Expand_Count (Last_Subvec, Subvec_Increase);
                    --  Compute next value for V.Count
                    Next_Count := V.Count + Subvec_Increase;
                    --Rep_Ok(V, 7777);
                elsif V.Width < Vec_Of_Vec_Length then
                    --  Add another subvec
                    V.Width += 1
                    if V.Level = 1 then
                        --  Add another leaf vec
                        --  Compute amount in this new leaf vec
                        const Amount_In_New_Leaf := Min (Leaf_Vec_Capacity,
                          New_Count - V.Count)

                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " leaf vec, V.Count was " | V.Count |
                                ", adding " | Amount_In_New_Leaf |
                                " in new leaf")
                        end if;

                        V.Subvecs[V.Width] :=
                          (Level => 0, Count => Amount_In_New_Leaf,
                           Width => 0, Subvecs => null,
                           Data => Create(Leaf_Vec_Capacity, null))

                        --  Compute total count of vector
                        Next_Count := V.Count + Amount_In_New_Leaf
                        --Rep_Ok(V, 8888);
                    else
                        --  Add another multi-level subvec
                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " level " | V.Level-1 |
                                " sub vec, V.Count was " | V.Count)
                        end if;
                        V.Subvecs[V.Width] :=
                          (Level => V.Level-1,
                           Count => 0,
                           Width => 0,
                           Subvecs => Create(Vec_Of_Vec_Length, null),
                           Data => null)
                        --Rep_Ok(V, 9999);

                        --  Count not increased yet
                        Next_Count := V.Count
                    end if
                else
                    --  Must add another level
                    if Debug then
                        Println("Adding another level, V.Level was " |
                          V.Level | ", V.Count was " | V.Count |
                          ", Next_Count = " | Next_Count)
                    end if;
                    var Old_V <== V
                    V := (Level => Old_V.Level+1,
                          Count => Old_V.Count,
                          Width => 1,
                          Subvecs => Create (Vec_Of_Vec_Length, null),
                          Data => null)
                    V.Subvecs[1] <== Old_V

                    --  Count not increased yet
                    Next_Count := V.Count
                    --  Will loop around to extend this multi-level structure
                end if
            end if
            --Rep_Ok(V, 1212);
            V.Count := Next_Count
            --Rep_Ok(V, 2323);
            if Next_Count = New_Count then
                exit loop
            end if
            if Debug then
                Println("Trying again, Next_Count = " | Next_Count |
                  ", New_Count = " | New_Count)
                Println("V.Level = " | V.Level | ", V.Width = " | V.Width);
            end if;
            --Rep_Ok(V, 2);
        end loop
        --Rep_Ok(V, 2222);
    end proc Expand_Count;

  exports
    func "[]"() return Vector is
        return (Level => 0, Count => 0, Width => 0,
                Data => null, Subvecs => null)
    end func "[]"

    func Create(Length : Univ_Integer; Initial_Value : Element_Type)
      {Length >= 0} 
        return Vector is

        if Length <= Leaf_Vec_Capacity then
            return (Level => 0, Width => 0,
                    Count => Length, Subvecs => null,
                    Data => Create (Length, Initial_Value))
        else
            const More_Needed := Length - Leaf_Vec_Capacity;

            var Result : Vector :=
                (Level => 0, Count => Leaf_Vec_Capacity,
                 Width => 0, Subvecs => null,
                 Data => Create (Leaf_Vec_Capacity, Initial_Value))
            Result.Expand_Count(More_Needed);
            if Initial_Value not null then
                for I in 1 .. More_Needed loop
                    Result[Leaf_Vec_Capacity + I] := Initial_Value
                end loop
            end if;
            --Rep_Ok(Result, 3);
            return Result;
        end if;

    end func Create

    func Length(V : Vector) return Univ_Integer is
        --Rep_Ok(V, 4);
        return V.Count
    end func Length

    func "indexing"(ref V : Vector; Index : Univ_Integer) return 
      ref Element_Type is
        --Rep_Ok(V, 5);
        if Index not in 1 .. V.Count then
           --var IO := IO::Get_IO();
           --IO.Stderr.Println( ...
           Println("Vector index " | Index | " out of bounds 1 .. " |
             V.Count)
           {vector_index_out_of_bounds: Index in 1..V.Count}
        end if
        if V.Level = 0 then
            --  Simple case
            return V.Data[Index]
        else
           const Subvec_Size := Subvec_Capacity[V.Level]
           const Which_Subvec := (Index-1) / Subvec_Size + 1
           const Subvec_Index := (Index-1) mod Subvec_Size + 1
           --  Recurse with appropriate subvec
           return V.Subvecs[Which_Subvec][Subvec_Index]
        end if;
    end func "indexing"

    func "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      return Vector is
      -- a "read-only" slice
        --Rep_Ok(V, 6);
        return [for I in Index_Set => V[I]]
    end func "slicing"

    func "index_set"(V : Vector) return Countable_Set<Univ_Integer> is
        --Rep_Ok(V, 7);
        return 1..Length(V)
    end func "index_set"

    proc "<|="(var V : Vector; var Elem : optional Element_Type) is
        --Rep_Ok(V, 8);
        Expand_Count(V, Amount => 1)
        --Rep_Ok(V, 9);
        V[V.Count] <== Elem
        --Rep_Ok(V, 10);
    end proc "<|="

    proc "|="(var V : Vector; Elem : Element_Type) is
        --Rep_Ok(V, 11);
        Expand_Count(V, Amount => 1)
        --Rep_Ok(V, 12);
        V[V.Count] := Elem
        --Rep_Ok(V, 13);
    end proc "|="
    
    proc "|="(var V : Vector; Right : Vector) is
        --Rep_Ok(V, 14);
        const Orig_Count := V.Count
        if Orig_Count = 0 then
            -- Just copy right
            V := Right;
        elsif Right.Count > 0 then
            -- Grow V, and then copy in Right
            Expand_Count(V, Right.Count)
            for I in 1..Right.Count loop
                --Rep_Ok(V, 15);
                if Debug then
                    Println(V.Level | ", " | V.Count | ", " | V.Width);
                end if;
                V[I+Orig_Count] := Right[I]
                --Rep_Ok(V, 16);
            end loop
        end if
        --Rep_Ok(V, 17);
    end proc "|="

    func "|"(Left, Right : Vector) return Result : Vector is
        --Rep_Ok(Left, 18);
        --Rep_Ok(Right, 19);
        -- Copy left into result, and then add in the Right elements
        if Left.Count = 0 then
            -- Left is null Vector; result is determined by Right
            Result := Right
        else
            -- Start with Left
            Result := Left
            --Rep_Ok(Result, 20);
            Result |= Right
        end if
        --Rep_Ok(Result, 21);
    end func "|"

    func "|"(Left : Vector; Right : Element_Type) return Result : Vector is
        --Rep_Ok(Left, 22);
        Result := Left
        --Rep_Ok(Result, 23);
        Result |= Right
        --Rep_Ok(Result, 24);
    end func "|"

end package SSL.Core.Vector

proc SSL.Test.Test_Vector() is
    var V : Vector<Univ_Integer> := []
    var U : Vector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " & V[1] & ", " & V[2])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 1..Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    Println("\"indexing\"(V, 12) := 33;")
    "indexing"(V, 12) := 33
    for I in 1..Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 1..Length(Slice) forward loop
        Println("Slice[" & I & "] = " & Slice[I])
    end loop
end proc SSL.Test.Test_Vector

generic
    type Bound_Type is new Countable
package SSL.Core.Countable_Range is
    -- Simple contiguous Countable_Range of integers (i.e. an interval)
    type Countable_Range is record
       const First : Bound_Type
       const Last : Bound_Type
    end record Countable_Range

    func ".."(Left, Right : Bound_Type) return Countable_Range
    func "<.."(Left, Right : Bound_Type) return Countable_Range
    func "..<"(Left, Right : Bound_Type) return Countable_Range
    func "<..<"(Left, Right : Bound_Type) return Countable_Range
    func "in"(Val : Bound_Type; Int : Countable_Range) return Boolean
    func Length(R : Countable_Range) return Univ_Integer
    func "magnitude"(Countable_Range) return Univ_Integer is Length
    func "[..]"() return Countable_Range
    func "[]"() return Countable_Range
    func Singleton(Bound : Bound_Type) return Countable_Range

    func Remove_First(var S : Countable_Range) return optional Bound_Type
    func Remove_Last(var S : Countable_Range) return optional Bound_Type
    func Remove_Any(var S : Countable_Range) return optional Bound_Type
end package SSL.Core.Countable_Range

package body SSL.Core.Countable_Range is
exports  -- check that indent of 0 works
    func ".."(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left, Last => Right)
    end func ".."

    func "<.."(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left+1, Last => Right)
    end func "<.."

    func "..<"(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left, Last => Right-1)
    end func "..<"

    func "<..<"(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left+1, Last => Right-1)
    end func "<..<"

    func "in"(Val : Bound_Type; Int : Countable_Range) return Boolean is
        return Val >= Int.First and then Val <= Int.Last
    end func "in"

    func Length(R : Countable_Range) return Univ_Integer is
        return R.Last - R.First + 1
    end func Length

    func "[]"() return Countable_Range is
        return Bound_Type'First()+1 .. Bound_Type'First()
    end func "[]"

    func "[..]"() return Countable_Range is
        return Bound_Type'First() .. Bound_Type'Last()
    end func "[..]"

    func Singleton(Bound : Bound_Type) return Countable_Range is
        return Bound .. Bound
    end func Singleton

    func Remove_First(var S : Countable_Range) 
      return Result : optional Bound_Type is
        if S.First <= S.Last then
            Result := S.First
            S := (First => S.First+1, Last => S.Last)
        else
            Result := null
        end if
    end func Remove_First
  
    func Remove_Last(var S : Countable_Range) 
      return Result : optional Bound_Type is
        if S.First <= S.Last then
            Result := S.Last
            S := (First => S.First, Last => S.Last-1)
        else
            Result := null
        end if
    end func Remove_Last

    func Remove_Any(var S : Countable_Range) 
      return Result : optional Bound_Type is
        if S.First <= S.Last then
            if (S.Last - S.First) mod 2 = 0 then
                return Remove_First(S)
            else
                return Remove_Last(S)
            end if
        else
            return null
        end if
    end func Remove_Any

end package SSL.Core.Countable_Range

package SSL.Core.Univ_Character is
    type Univ_Character is private;

    proc Print(C : Univ_Character) is import(#print_char)
    proc Put(C : Univ_Character) is Print

    func "+"(Left : Univ_Character; Right : Univ_Integer) return Univ_Character
      is import("+")
    func "+"(Left : Univ_Integer; Right : Univ_Character) return Univ_Character
      is import("+")

    func "-"(Left : Univ_Character; Right : Univ_Integer) return Univ_Character
      is import("-")
    func "-"(Left, Right : Univ_Character) return Univ_Integer
      is import("-")

    func "*"(Left : Univ_Integer; Right : Univ_Character) return Univ_String
      -- Produce specified number of "Right" chars in a row
    func "*"(Left : Univ_Character; Right : Univ_Integer) return Univ_String
      -- Produce specified number of "Left" chars in a row

    func "=?"(Left, Right : Univ_Character) return Ordering
      is import("=?")

    func Image(Val : Univ_Character) return Univ_String
      is import(#to_string_char)

    func Value(Str : Univ_String) return optional Univ_Character
      is import(#from_string_char)

    func Hash(Val : Univ_Character) return Univ_Integer
      is import(#identity)

    func First() return Univ_Character
    func Last() return Univ_Character

    func Min(Left, Right : optional Univ_Character) return Univ_Character
      is import (#min)
    func Max(Left, Right : optional Univ_Character) return Univ_Character
      is import (#max)

    func ".."(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    func "<.."(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    func "..<"(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    func "<..<"(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    func "|"(Left, Right : Univ_Character) return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
end package SSL.Core.Univ_Character
    
package SSL.Core.Univ_String is
    type Univ_String is private;
    proc Print(Univ_String) is import(#print_string)
    proc Println(Univ_String) is import(#println_string)
    func Readln() return optional Univ_String is import(#read_string)

    --  Text_IO-ish equivalents
    proc Put(Univ_String) is Print
    proc Put_Line(Univ_String) is Println
    proc New_Line() is (Put("\n"))
    func Get_Line() return optional Univ_String is import(#read_string)

    func "*"(Left : Univ_Integer; Right : Univ_String) return Univ_String
     -- Produce specified number of "Right" strings in a row
    func "*"(Left : Univ_String; Right : Univ_Integer) return Univ_String
     -- Produce specified number of "Left" strings in a row

    func "|"(Left, Right : Univ_String) return Univ_String 
      is import(#concat_string)

    func "&"(Left, Right : Univ_String) return Univ_String is "|"

    func "=?"(Left, Right : Univ_String) return Ordering
      is import(#string_compare)

    proc "|="(var Left : Univ_String; Right : Univ_String)
      is import(#assign_concat_string)

    proc "&="(var Left : Univ_String; Right : Univ_String) is "|="

    func "indexing"(Str : Univ_String; Index : Univ_Integer)
      return Univ_Character
      is import(#string_indexing)
     -- a "read-only" element, indexed 1 .. |Str|

    func "index_set"(Str : Univ_String) return Countable_Set<Univ_Integer>
        -- Return set of indices for string

    func "slicing"(Str : Univ_String;
      Index_Set : Countable_Range<Univ_Integer>) 
      return Univ_String is import(#string_slicing)
        -- a "read-only" slice

    func Length(Str : Univ_String) return Univ_Integer
      is import(#string_length)

    func "magnitude"(Univ_String) return Univ_Integer
      is import(#string_length)

    func Hash(Val : Univ_String) return Univ_Integer
      is import(#identity)

    func "|"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String

    func "|"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String

    proc "|="(var Left : Univ_String; Right : Right_Type is Imageable<>)

    func "&"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String

    func "&"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String

    proc "&="(var Left : Univ_String; Right : Right_Type is Imageable<>)

    -- Operations to convert to/from a Vector of Univ_Character's
    func To_Vector(Str : Univ_String) return Vector<Univ_Character>
    func From_Vector(Vec : Vector<Univ_Character>) return Univ_String

  implements -- for Imageable

    -- These operations are needed so Univ_String satifies
    -- requirements of "Imageable" interface, but these
    -- operations are not directly callable, to avoid ambiguities.

    func Image(Val : Univ_String) return Univ_String
      is import (#identity)
    func Value(Str : Univ_String) return optional Univ_String
      is import (#identity)

end package SSL.Core.Univ_String
    
proc Test_Str() is
    var X : Univ_String := "Hello, Sparkeling World";
    Println (X);
    Println ("Hello with a string literal");
    Univ_String'Println (X);
    SSL'Core'Univ_String'Println (X);
    SSL.Core.Univ_String.Println (X);
    Univ_String.Println (X);
    Univ_String.Println ("Hello, Sparkel World with a literal")
end proc Test_Str

package body SSL.Core.Univ_String is
    subtype Substr_Array is Basic_Array<Univ_String>;

    type Univ_String is record
        Parts : optional Substr_Array;
        Dummy : Univ_Integer;  -- make sure this doesn't end up as a wrapper
    end record Univ_String
  exports
    func "index_set"(Str : Univ_String) return Countable_Set<Univ_Integer> is
        -- Return set of indices for string
        return 1..|Str|
    end func "index_set"

    func "*"(Left : Univ_Integer; Right : Univ_String) return Univ_String is
        -- Produce specified number of "Right" strings in a row
        if Left <= 0 then
            return ""
        elsif Left = 1 then
            return Right
        else
            -- Recurse to produce half-length, and then combine
            const Partial : Univ_String := (Left/2) * Right
            if Left mod 2 = 1 then
                return Partial | Partial | Right
            else
                return Partial | Partial
            end if
        end if
    end func "*"

    func "*"(Left : Univ_String; Right : Univ_Integer) return Univ_String is
        -- Produce specified number of "Left" strings in a row
        return Right * Left   -- Just pass the buck to other "*"
    end func "*"

    func "|"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String is
        return Left | Right_Type'Image(Right)
    end func "|"

    func "|"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String is
        return Left_Type'Image(Left) | Right
    end func "|"

    proc "|="(var Left : Univ_String; Right : Right_Type is Imageable<>) is
        Left |= Right_Type'Image(Right)
    end proc "|="

    func "&"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String is
        return Left & Right_Type'Image(Right)
    end func "&"

    func "&"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String is
        return Left_Type'Image(Left) & Right
    end func "&"

    proc "&="(var Left : Univ_String; Right : Right_Type is Imageable<>) is
        Left &= Right_Type'Image(Right)
    end proc "&="

    func To_Vector(Str : Univ_String) return Vector<Univ_Character> is
        return [for I in 1 .. |Str| => Str[I]]
    end func To_Vector

    func From_Vector(Vec : Vector<Univ_Character>) return Univ_String is
        return (for each C of Vec forward => <""> | C)
    end func From_Vector
end package SSL.Core.Univ_String

package SSL.Core.Random is
    type Random is private;

    func Start(Seed : Univ_Integer := 1) return Random
      -- Start a new random number sequence with a standard multiplier/modulus

    func Start(Seed : Univ_Integer;
       Mult, Mod : Univ_Integer) return Random
      -- Start a new random number sequence with given multiplier and modulus

    func Next(var Seq : Random) return Univ_Integer
      -- Get next value in random number sequence
end package SSL.Core.Random

package body SSL.Core.Random is
    type Random is record
       Last_Value : Univ_Integer
       const Mult : Univ_Integer
       const Mod : Univ_Integer
    end record Random

    const Debugging : Boolean := #False
  exports  -- check that indent of 0 works
    func Start(Seed : Univ_Integer) return Random is
      -- Start a new random number sequence with a standard multiplier/modulus
        return (Last_Value => Seed,
          Mult => 7**5, Mod => 2**31 - 1)
    end func Start

    func Start(Seed : Univ_Integer;
      Mult, Mod : Univ_Integer) return Random is
      -- Start a new random number sequence with given multiplier and modulus
        if Debugging then
            Println("Random: Seed = " & Seed & ", Mult = " & Mult &
              ", Mod = " & Mod)
        end if
        return (Last_Value => Seed, Mult => Mult, Mod => Mod)
    end func Start

    func Next(var Seq : Random) return Univ_Integer is
      -- Get next value in random number sequence
        Seq.Last_Value := Seq.Last_Value * Seq.Mult mod Seq.Mod
        return Seq.Last_Value
    end func Next
end package SSL.Core.Random

proc SSL.Test.Test_String() is
    const U := "tab\t"
    const T := U[4]
    Println("U = " & U & ", |U| = " & |U| & ", U[4] = '" & T & "'")
    const X := "this is a string"
    const Y := X[3]
    {Y = 'i'} -- string indexing problem
    const Z := X[6..7]
    {Z = "is"} -- string slicing problem, expected 'is', found Z 
    Println("X = " & X & ", X[3] = " & Y & ", X[6..7] = " & Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " & "hello")

    const Seven_Xs := "x" * 7
    {Seven_Xs = "xxxxxxx"} -- Char multiplication check

    Println("Here are seven x's: " & Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
end proc SSL.Test.Test_String

package body SSL.Core.Univ_Character is
  exports
    func "*"(Left : Univ_Integer; Right : Univ_Character) return Univ_String is
        -- Produce specified number of "Right" chars in a row
        return Left * Image(Right)   
           -- Just pass the buck to the string func
    end func "*"

    func "*"(Left : Univ_Character; Right : Univ_Integer) return Univ_String is
        -- Produce specified number of "Left" chars in a row
        return Right * Image(Left)   
           -- Just pass the buck to the string func
    end func "*"

    func First() return Univ_Character is
        return '\0'
    end func First

    func Last() return Univ_Character is
        return '\0' + 2**31-1
    end func Last
end package SSL.Core.Univ_Character

package SSL.Core.Comparable is
    type Comparable is abstract private; -- new Assignable;
    abstract func "=?"(Left, Right : Comparable) return Ordering
end package SSL.Core.Comparable

package SSL.Core.Hashable is
    type Hashable is abstract new Comparable;
    -- Types which aren't ordered nevertheless are often
    -- hashable, which makes it possible to create an efficient
    -- set or map using them as the index type.

    --  func "=?"(Left, Right : Hashable) return Ordering
    --  TBD: overriding of abstracts NYI
    abstract func Hash(Val : Hashable) return Univ_Integer
end package SSL.Core.Hashable

generic
    type Element_Type is new Hashable
package SSL.Containers.Set is
  -- A hashed-set module
    type Set is private

    func "[]"() return Set

    func Singleton(Elem : Element_Type) return Set

    func "|"(Left, Right : Element_Type) return Set
    func "|"(Left : Set; Right : Element_Type) return Set
    func "|"(Left : Element_Type; Right : Set) return Set
    func "|"(Left : Set; Right : Set) return Set

    proc "|="(var Left : Set; Right : Set)

    proc "|="(var Left : Set; Right : Element_Type)
	-- Add element to Set.

    proc "<|="(var Left : Set; var Right : optional Element_Type)
	-- Move element into Set.

    proc "<|="(var Left : Set; var Right : Set)
	-- Move all elements of Right into Left, leaving Right empty.

    func "in"(Left : Element_Type; Right : Set) return Boolean

    func "=?"(Left, Right : Set) return Ordering
	-- Return #equal if Left and Right have the same elements
	-- Return #less if Left is a proper subset of Right
	-- Return #greater if Left is a proper superset of Right
	-- Return #unordered otherwise

    func "or"(Left, Right : Set) return Set is "|"  -- Union
    proc "or="(var Left : Set; Right : Set) is "|="

    func "+"(Left, Right : Set) return Set is "|"   -- Union
    proc "+="(var Left : Set; Right : Set) is "|="
    proc "+="(var Left : Set; Right : Element_Type) is "|="   -- aka Include

    func "and"(Left, Right : Set) return Set
	-- Intersection
    proc "and="(var Left : Set; Right : Set)

    func "xor"(Left, Right : Set) return Set
	-- Symmetric difference
    proc "xor="(var Left : Set; Right : Set)

    func "-"(Left, Right : Set) return Set
	-- Set difference

    proc "-="(var Left : Set; Right : Set)
	-- Compute Set difference

    proc "-="(var S : Set; Elem : Element_Type)   -- aka Exclude
	-- Remove one element, if present

    func Count(S : Set) return Univ_Integer

    func "magnitude"(Set) return Univ_Integer is Count

    func Is_Empty(S : Set) return Boolean

    func Remove_Any(var S : Set) return optional Element_Type
      -- Remove and return an arbitrary element of the Set S

    proc Dump_Statistics(S : Set)
      -- A debugging routine to show bucket sizes of Set

end package SSL.Containers.Set

package SSL.Core.Univ_Enumeration is
    type Univ_Enumeration is private;

    func "=?"(Left, Right : Univ_Enumeration) return Ordering 
      is import(#unordered_compare)
    proc Print(Val : Univ_Enumeration) 
      is import(#print_univ_enum)

    proc Put(Val : Univ_Enumeration) is Print

    func Image(Val : Univ_Enumeration) return Univ_String
      is import(#to_string_enum)

    func Value(Str : Univ_String) return optional Univ_Enumeration
      is import(#from_string_enum)

    func Hash(Val : Univ_Enumeration) return Univ_Integer
      is import(#hash_enum)

    func "in"(Left : Univ_Enumeration; Right : Set<Univ_Enumeration>) 
      return Boolean
      is of Set<Univ_Enumeration>

end package SSL.Core.Univ_Enumeration

package SSL.Core.Boolean is
    type Boolean is private;

    func "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#False, #True]}
      return Boolean is import(#sparkel_bool_from_univ)

    func "to_univ"(Val : Boolean) return Univ_Enumeration 
      is import(#sparkel_bool_to_univ)

    func "=?"(Left, Right : Boolean) return Ordering
      is import("=?")
        -- NOTE: #True > #False

    func "not"(Boolean) return Boolean is import("not")
    func "and"(Left, Right : Boolean) return Boolean is import("and")
    func "or"(Left, Right : Boolean) return Boolean is import("or")
    func "xor"(Left, Right : Boolean) return Boolean is import("xor")

    proc "and="(var Left : Boolean; Right : Boolean)
    proc "or="(var Left : Boolean; Right : Boolean)
    proc "xor="(var Left : Boolean; Right : Boolean)

    func Hash(Val : Boolean) return Univ_Integer
      is import(#identity)

    -- For Imageable
    func Image(Val : Boolean) return Univ_String
    func Value(Str : Univ_String) return optional Boolean

    -- Operators for Countable
    func "+"(Left : Univ_Integer; Right : Boolean) return Boolean 
      is import("+")
    func "+"(Left : Boolean; Right : Univ_Integer) return Boolean 
      is import("+")
    func "-"(Left, Right : Boolean) return Univ_Integer 
      is import("-")
    func "-"(Left : Boolean; Right : Univ_Integer) return Boolean 
      is import("-")

    -- TBD: These should be properties some day (e.g. Boolean#first).
    func First() return Boolean is (#False)
    func Last() return Boolean is (#True)

    func Min(Left, Right : optional Boolean) return optional Boolean
      is import(#min)
    func Max(Left, Right : optional Boolean) return optional Boolean
      is import(#max)

    func ".."(Left, Right : Boolean) return Countable_Set<Boolean>
    func "<.."(Left, Right : Boolean) return Countable_Set<Boolean>
    func "..<"(Left, Right : Boolean) return Countable_Set<Boolean>
    func "<..<"(Left, Right : Boolean) return Countable_Set<Boolean>
    func "|"(Left, Right : Boolean) return Countable_Set<Boolean>
end package SSL.Core.Boolean

package body SSL.Core.Boolean is
    subtype Boolean_Set is Countable_Set<Boolean>

  exports
    proc "and="(var Left : Boolean; Right : Boolean) is
      Left := Left and Right
    end proc "and="

    proc "or="(var Left : Boolean; Right : Boolean) is
      Left := Left or Right
    end proc "or="

    proc "xor="(var Left : Boolean; Right : Boolean) is
      Left := Left xor Right
    end proc "xor="

    func Image(Val : Boolean) return Univ_String is
      if Val then
          return "#True"
      else
          return "#False"
      end if
    end func Image

    func Value(Str : Univ_String) return optional Boolean is
      if Str = "#True" then
          return #True
      elsif Str = "#False" then
          return #False
      else
          return null
      end if
    end func Value

    -- NOTE: For implementation reasons, we put these here rather than defining
    --       them in the interface using "is of Countable_Set<Boolean>"
    func ".."(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'".."(Left, Right)
    end func ".."

    func "<.."(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"<.."(Left, Right)
    end func "<.."

    func "..<"(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"..<"(Left, Right)
    end func "..<"
    func "<..<"(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"<..<"(Left, Right)
    end func "<..<"

    func "|"(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"|"(Left, Right)
    end func "|"
end package SSL.Core.Boolean

proc SSL.Test.Test_Boolean(UX, UY : Univ_Enumeration) is
    const X : Boolean := UX
    const Y : Boolean := UY

    const And_XY := X and Y
    const Or_XY := X or Y
    const Xor_XY := X xor Y
    Println(X & " and " & Y & " = " & (X and Y))
    Println(X & " or " & Y & " = " & (X or Y))
    Println(X & " xor " & Y & " = " & (X xor Y))

    var XX := X
    XX and= Y
    Println("X and= Y = " & Image (XX))
    XX := X
    XX or= Y
    Println(X & " or= " & Y & " = " & XX)
    XX := X
    XX xor= Y
    Println(X & " xor= " & Y & " = " & XX)
end proc SSL.Test.Test_Boolean

-- package SSL.Core.Optional is
--     type Optional is abstract private;
--     func "null"() return Optional
--     func "is null"(Optional) return Boolean
-- end package SSL.Core.Optional
-- 
package SSL.Core.Ordered is
    type Ordered is abstract new Comparable;
  -- The "=?" operator on Ordered types never return s #unordered
  -- They also provide a Min and Max operator.

  -- Note that Min and Max may be given null operands.
  -- They each return null if both operands are null, and return the
  -- non-null operand if only one of the operands is null.
  -- This allows null to be used as the initial value when computing
  -- the "Max" or "Min" of a possibly-empty sequence, rather than
  -- having to start with the equivalent of negative or positive infinity.

    subtype Full_Ordering is Ordering
      -- {Full_Ordering in #less | #equal | #greater}

    --  func "=?"(Left, Right : Ordered) return Full_Ordering
    --  TBD: overriding of abstracts NYI

    abstract func Min(Left, Right : optional Ordered) return optional Ordered
    abstract func Max(Left, Right : optional Ordered) return optional Ordered
end package SSL.Core.Ordered

generic
    type Element_Type is new Assignable
package SSL.Core.ZVector is
  -- Extendable vector, indexed by Univ_Integer, 0..Length-1
    type ZVector is new Indexable<Element_Type, Univ_Integer> with private

    func "[]"() return ZVector
    func "indexing"(ref V : ZVector; Index : Univ_Integer) return 
      ref Element_Type
    func "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      return ZVector
      -- a "read-only" slice
    func "index_set"(V : ZVector) return Countable_Set<Univ_Integer>
    proc "|="(var V : ZVector; Elem : Element_Type)
    proc "&="(var V : ZVector; Elem : Element_Type) is "|="
    proc "<|="(var V : ZVector; var Elem : optional Element_Type)
    func "|"(Left, Right : ZVector) return ZVector
    func "&"(Left, Right : ZVector) return ZVector is "|"
    func Length(V : ZVector) return Univ_Integer
    func "magnitude"(ZVector) return Univ_Integer is Length
end package SSL.Core.ZVector
    
package body SSL.Core.ZVector is
  -- Extendable ZVector, indexed by Univ_Integer, 0..Length-1
    type ZVector is record
        Vec : Vector<Element_Type>
    end record ZVector

  exports
    func "[]"() return ZVector is
        return (Vec => [])
    end func "[]"

    func Length(V : ZVector) return Univ_Integer is
        return Length(V.Vec)
    end func Length

    func "indexing"(ref V : ZVector; Index : Univ_Integer) return 
      ref Element_Type is
        {Index in 0..<Length(V.Vec)}  -- Index out of bounds
        return V.Vec[Index+1]
    end func "indexing"

    func "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      return ZVector is
      -- a "read-only" slice
        return [for I in Index_Set => V[I]]
    end func "slicing"

    func "index_set"(V : ZVector) return Countable_Set<Univ_Integer> is
        return 0..<Length(V.Vec)
    end func "index_set"

    proc "<|="(var V : ZVector; var Elem : optional Element_Type) is
        V.Vec <|= Elem
    end proc "<|="

    proc "|="(var V : ZVector; Elem : Element_Type) is
        V.Vec |= Elem
    end proc "|="
    
    func "|"(Left, Right : ZVector) return Result : ZVector is
        return (Vec => Left.Vec | Right.Vec)
    end func "|"

end package SSL.Core.ZVector

proc SSL.Test.Test_ZVector() is
    var V : ZVector<Univ_Integer> := []
    var U : ZVector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " & V[0] & ", " & V[1])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 0..<Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    Println("\"indexing\"(V, 11) := 33;")
    "indexing"(V, 11) := 33
    for I in 0..<Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 0..<Length(Slice) forward loop
        Println("Slice[" & I & "] = " & Slice[I])
    end loop
end proc SSL.Test.Test_ZVector

package SSL.Core.ZString is
  -- A universal string with characters indexed starting at 0
    type ZString is private

    func "from_univ"(Univ : Univ_String) return ZString
      is import(#identity)
    func "to_univ"(ZStr : ZString) return Univ_String
      is import(#identity)

    proc Print(ZString) is import(#print_string)
    proc Println(ZString) is import(#println_string)
    func Readln() return optional ZString is import(#read_string)

    proc Put(ZString) is Print
    proc Put_Line(ZString) is Println
    func Get_Line() return optional ZString is import(#read_string)

    func "*"(Left : Univ_Integer; Right : ZString) return ZString
        -- Produce specified number of "Right" strings in a row
    func "*"(Left : ZString; Right : Univ_Integer) return ZString
        -- Produce specified number of "Left" strings in a row

    func "|"(Left, Right : ZString) return ZString 
      is import(#concat_string)

    func "&"(Left, Right : ZString) return ZString is "|"

    func "=?"(Left, Right : ZString) return Ordering
      is import(#string_compare)

    proc "|="(var Left : ZString; Right : ZString)
      is import(#assign_concat_string)

    proc "&="(var Left : ZString; Right : ZString) is "|="

    func "indexing"(Str : ZString; Index : Univ_Integer<>) return Univ_Character
        -- a "read-only" element, indexed 0..<Length(Str)

    func "index_set"(Str : ZString) return Countable_Set<Univ_Integer>
        -- Return set of indices for string

    func "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      return ZString
        -- a "read-only" slice

    func Length(Str : ZString) return Univ_Integer
      is import(#string_length)

    func "magnitude"(ZString) return Univ_Integer is Length

    func Hash(Val : ZString) return Univ_Integer
      is import(#identity)

    func "|"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString

    func "|"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString

    proc "|="(var Left : ZString; Right : Right_Type is Imageable<>)

    func "&"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString

    func "&"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString

    proc "&="(var Left : ZString; Right : Right_Type is Imageable<>)

    -- Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) return ZVector<Univ_Character>
    func From_ZVector(Vec : ZVector<Univ_Character>) return ZString

end package SSL.Core.ZString
    
package body SSL.Core.ZString is
  -- A universal string with characters indexed starting at 0
    type ZString is record
        U_Str : Univ_String
    end record ZString

  exports
    func "indexing"(Str : ZString; Index : Univ_Integer<>)
      return Univ_Character is
        -- a "read-only" element, indexed 0..<Length(Str)
        return Str.U_Str[Index+1]
    end func "indexing"

    func "index_set"(Str : ZString) return Countable_Set<Univ_Integer> is
        -- Return set of indices for string
        return 0 ..< |Str.U_Str|
    end func "index_set"

    func "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      return ZString is
        -- a "read-only" slice
        return (U_Str => Str.U_Str[Index_Set.First <.. Index_Set.Last+1])
    end func "slicing"

    func "*"(Left : Univ_Integer; Right : ZString) return ZString is
        -- Produce specified number of "Right" strings in a row
        return (U_Str => Left * Right.U_Str)
    end func "*"

    func "*"(Left : ZString; Right : Univ_Integer) return ZString is
        -- Produce specified number of "Left" strings in a row
        return Right * Left   -- Just pass the buck to other "*"
    end func "*"

    func "|"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString is
        return (U_Str => Left.U_Str | Right_Type'Image(Right))
    end func "|"

    func "|"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString is
        return (U_Str => Left_Type'Image(Left) | Right.U_Str)
    end func "|"

    proc "|="(var Left : ZString; Right : Right_Type is Imageable<>) is
        Left.U_Str |= Right_Type'Image(Right)
    end proc "|="

    func "&"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString is
        return Left & Right_Type'Image(Right)
    end func "&"

    func "&"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString is
        return Left_Type'Image(Left) & Right
    end func "&"

    proc "&="(var Left : ZString; Right : Right_Type is Imageable<>) is
        Left &= Right_Type'Image(Right)
    end proc "&="

    -- Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) return ZVector<Univ_Character> is
        return [for I in 0..<Length(Str) => Str[I]]
    end func To_ZVector

    func From_ZVector(Vec : ZVector<Univ_Character>) return ZString is
        return (for each C of Vec forward => <""> | C)
    end func From_ZVector

end package SSL.Core.ZString

proc SSL.Test.Test_ZString() is
    const U : ZString := "tab\t"
    const T := U[3]
    Println("U = " & U & ", Length(U) = " & Length(U) & ", U[4] = '" & T & "'")
    const X : ZString := "this is a string"
    const Y := X[2]
    {Y = 'i'} -- string indexing problem
    const Z := X[5..6]
    {Z = "is"} -- string slicing problem, expected 'is', found Z 
    Println("X = " & X & ", X[2] = " & Y & ", X[5..6] = " & Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " & "hello")

    const Seven_Xes :ZString := "x" * 7
    {Seven_Xes = "xxxxxxx"} -- Char multiplication check

    Println("Here are seven x's: " & Seven_Xes)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
end proc SSL.Test.Test_ZString

generic
    type Array_Type is new Indexable
package SSL.Containers.Slice is
  -- A sliceable array.
    type Bounds is record
        const First : Array_Type'Index_Type
        const Last : Array_Type'Index_Type
    end record Bounds

    type Slice is limited new Bounds with private  -- TBD: Use discriminants

    func Length(S : Slice) return Univ_Integer
        -- Return length of slice (i.e. Last - First + 1)

    func "magnitude"(Slice) return Univ_Integer is Length
        -- Allows use of |...| operator

    func "slicing"(ref A : Array_Type) return ref Slice
        -- Convert an array into a slice covering 1..Length(A)

    func "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return ref Slice
        -- Slice of an array

    func "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return ref Slice
        -- Slice of a slice

    func "indexing"(ref S : Slice; Index : Array_Type.Index_Type) 
      return ref Array_Type.Elem_Type
        -- Index into a slice

    func "index_set"(S : Slice) return Countable_Set<Array_Type.Index_Type>
end package SSL.Containers.Slice

package body SSL.Containers.Slice is
    type Slice is limited record
        ref Arr : Array_Type
    end record Slice

  exports
    func Length(S : Slice) return Univ_Integer is
        -- Return length of slice (i.e. Last - First + 1)
        return S.Last - S.First + 1
    end func Length

    func "slicing"(ref A : Array_Type) return ref Slice is
        -- Convert an array into a slice covering whole array
        const A_Bounds := "index_set"(A)
        return (First => First(A_Bounds), Last => Last(A_Bounds), Arr => A)
    end func "slicing"

    func "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return ref Slice is
        -- Slice of an array
        const A_Bounds := "index_set"(A)
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= First(A_Bounds) and then 
            Bounds.Last <= Last(A_Bounds))} --slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => A)
    end func "slicing"

    func "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return ref Slice is
        -- Slice of a slice
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= S.First and then Bounds.Last <= S.Last)}
          -- slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => S.Arr)
    end func "slicing"

    func "indexing"(ref S : Slice; Index : Array_Type.Index_Type) 
      return ref Array_Type.Elem_Type is
        -- Index into a slice
        {Index >= S.First and then Index <= S.Last}
          -- array index out of bounds
        return S.Arr[Index]
    end func "indexing"
    
    func "index_set"(S : Slice) return Countable_Set<Array_Type.Index_Type> is
        return S.First .. S.Last
    end func "index_set"
end package SSL.Containers.Slice

generic
    type Elem_Type is new Assignable;
    type Indexed_By is new Countable
package SSL.Containers.Array is
    type Array is new Indexable<Elem_Type, Indexed_By> with private

  -- An array abstraction where the index type is not necessarily
  -- Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    func Create(Bounds : Countable_Range<Indexed_By>; Initial_Value : Elem_Type)
      return Array

    func Length(Arr : Array) return Univ_Integer
    func "magnitude"(Array) return Univ_Integer is Length

    func Bounds(Arr : Array) return Countable_Range<Indexed_By>

    func "indexing"(ref Arr : Array; Index : Indexed_By) return ref Elem_Type
    func "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      return ref var Elem_Type
    func "index_set"(Arr : Array) return Countable_Set<Indexed_By>
    proc "<|="(var Left : Array; var Right : optional Elem_Type)
    func "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>)
      return Array
    func "&"(Left, Right : Array) return Array
    func "[]"() return Array
end package SSL.Containers.Array

package body SSL.Containers.Array is
  -- An array abstraction where the index type is not necessarily
  -- Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    subtype Elem_Array is Basic_Array<Elem_Type>

    type Array is record
        Data : Elem_Array
        const Bounds : Countable_Range<Indexed_By>
    end record Array

  exports

    func Create(Bounds : Countable_Range<Indexed_By>; Initial_Value : Elem_Type)
      return Array is
        return (Data => Create(Length(Bounds), Initial_Value),
          Bounds => Bounds)
    end func Create

    func Length(Arr : Array) return Univ_Integer is
        return Length(Arr.Data)
    end func Length

    func Bounds(Arr : Array) return Countable_Range<Indexed_By> is
        return Arr.Bounds
    end func Bounds

    func "indexing"(ref Arr : Array; Index : Indexed_By) return ref Elem_Type is
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end func "indexing"

    func "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      return ref var Elem_Type is
        if Length(Arr) = 0 then
            -- Create a one-element array
            Arr := (Data => Create(1, null),
              Bounds => Index .. Index)
        elsif Index < Arr.Bounds.First then
            -- Extend below
            Arr := (Data => 
              Elem_Array.Create(Arr.Bounds.First - Index, null) | Arr.Data,
              Bounds => Index .. Arr.Bounds.Last)
        elsif Index > Arr.Bounds.Last then
            -- Extend above
            Arr := (Data => 
              Arr.Data | Elem_Array.Create(Index - Arr.Bounds.Last, null),
              Bounds => Arr.Bounds.First .. Index)
        end if
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end func "var_indexing"

    func "index_set"(Arr : Array) return Countable_Set<Indexed_By> is
        return Arr.Bounds.First .. Arr.Bounds.Last
    end func "index_set"

    proc "<|="(var Left : Array; var Right : optional Elem_Type) is
        -- Add Right onto Array
        if Length(Left) = 0 then
            Left := (Data => Create(1, null),
              Bounds => Indexed_By.First() .. Indexed_By.First())
            Left[Indexed_By.First()] <== Right
        else
            Left[Left.Bounds.Last + 1] <== Right
        end if
    end proc "<|="
    
    func "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      return Result : Array is
        Result := Left
        Result[Right.Key] := Right.Value
    end func "|"

    func "&"(Left, Right : Array) 
      return Array is
        if Length(Left) = 0 then
           return Right;
        elsif Length(Right) = 0 then
           return Left;
        else
           return (Data => Left.Data | Right.Data,
                   Bounds =>
                     Left.Bounds.First .. Left.Bounds.Last + Length(Right));
        end if;
    end func "&"

    func "[]"() return Result : Array is
        return (Data => Create(0, null),
          Bounds => Indexed_By.First()+1 .. Indexed_By.First())
            -- Bounds not meaningful when empty
    end func "[]"

end package SSL.Containers.Array

proc SSL.Test.Test_Array() is
    type Color is new Enum< [#red, #green, #blue] >
    type RCB is new Array<Integer<Range => 0..0xFF>, Indexed_By => Color>

    const Red : RCB := [#red => 0x33, #green => 0, #blue => 0]
    const Blue : RCB := [#red => 0, #green => 0, #blue => 0x33]
    const Yellow : RCB := [0, 0x33, 0x33]
    const White : RCB := [0xFF, 0xFF, 0xFF]
    
    const RCBs : Vector<RCB> := [Red, Blue, Yellow, White]

    for each C of RCBs loop
        Println("#red => " & C[#red] & ", #green => " & C[#green] &
          ", #blue => " & C[#blue])
    end loop
end proc SSL.Test.Test_Array

generic
    type Content_Type is new Comparable
package SSL.Core.Atomic is
    type Atomic is protected private;

    func Create(Initial_Val : Content_Type) return Atomic
      -- Create an atomic object with given initial value

    proc Set_Value(locked var A : Atomic; Val : Content_Type)
      -- Atomically set the new value
      -- TBD: Use atomic hardware instructions eventually

    func Value(locked A : Atomic) return Content_Type
      -- Return the current value
      -- TBD: Use atomic hardware instructions eventually

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) return
      Content_Type
      -- Set Value(A) to New_Val; Return the prior value.

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) return Content_Type
      -- If Value(A) = Expected_Val, then set Value(A) to New_Val.
      -- In any case, return the prior value.
end package SSL.Core.Atomic

package body SSL.Core.Atomic is
    type Atomic is protected record
        Value : Content_Type
    end record Atomic
  exports
    func Create(Initial_Val : Content_Type) return Atomic is
      -- Create an atomic object with given initial value
        return (Value => Initial_Val)
    end func Create

    proc Set_Value(locked var A : Atomic; Val : Content_Type) is
      -- Atomically set the new value
      -- TBD: Use atomic hardware instructions eventually
        A.Value := Val
    end proc Set_Value

    func Value(locked A : Atomic) return Content_Type is
      -- Return the current value
      -- TBD: Use atomic hardware instructions eventually
        return A.Value
    end func Value

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) return
      Result : Content_Type is
      -- Set Value(A) to New_Val; Return the prior value.
        Result := A.Value
        A.Value := New_Val
    end func Test_And_Set

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) return Result : Content_Type is
      -- If Value(A) = Expected_Val, then set Value(A) to New_Val.
      -- In any case, return the prior value.
        Result := A.Value
        if Result = Expected_Val then
            A.Value := New_Val
        end if
    end func Compare_And_Swap
end package SSL.Core.Atomic

proc SSL.Test.Test_Atomic(X, Y : Univ_Integer) is
    subtype Atomic_Univ is Atomic<Univ_Integer>
    var AX := Atomic_Univ.Create(X)

    Println("Value(X) = " & Value(AX))

    Set_Value(AX, X+1)
    Println("After Set_Value(" & (X+1) & "), Value(X) = " & Value(AX))

    const Z := Test_And_Set(AX, Y)
    Println("Test_And_Set(X, " & Y & ") = " & Z)

    const CAS := Compare_And_Swap(AX, Expected_Val => X-1, New_Val => Y-1)
    Println("Compare_And_Swap(X, " & (X-1) & ", " & (Y-1) & 
      ") = " & CAS & ", Value(X) = " & Value(AX))

    const CAS2 := Compare_And_Swap(AX, Y, Y-2)
    Println("Compare_And_Swap(X, " & Y & ", " & (Y-2) & 
      ") = " & CAS2 & ", Value(X) = " & Value(AX))

end proc SSL.Test.Test_Atomic

package SSL.Core.Countable_Base is
    type Countable_Base is abstract new Ordered
    --  TBD: All operations should be declared "abstract"
    --       unless perhaps we allow the whole package to be declared "abstract"

    abstract
      func "+"(Left : Countable_Base; Right : Univ_Integer)
        return Countable_Base
    abstract
      func "+"(Left : Univ_Integer; Right : Countable_Base)
        return Countable_Base

    abstract
      func "-"(Left : Countable_Base; Right : Univ_Integer)
        return Countable_Base
    abstract
      func "-"(Left, Right : Countable_Base) return Univ_Integer

    --  func "=?"(Left, Right : Countable_Base) return Ordered.Full_Ordering
    --  TBD: Overriding of abstracts NYI

    abstract
      func First() return Countable_Base

    abstract
      func Last() return Countable_Base

    --  func Hash(Val : Countable_Base) return Univ_Integer
    --  TBD: Overriding of abstracts NYI
end package SSL.Core.Countable_Base

generic
    type Bound_Type is new Comparable
package SSL.Core.Closed_Interval is
    -- This provides a simple "closed" interval X..Y
    -- If a type is countable, then half-open or fully open intervals
    -- can be converted into the equivalent closed interval.
    type Closed_Interval is record
       Low : Bound_Type
       High : Bound_Type
    end record Closed_Interval

    func "in"(Left : Bound_Type; Right : Closed_Interval) return Boolean
    func "=?"(Left, Right : Closed_Interval) return Ordering
end package SSL.Core.Closed_Interval

package body SSL.Core.Closed_Interval is
  exports
    func "in"(Left : Bound_Type; Right : Closed_Interval) return Boolean is
        return Left >= Right.Low and then Left <= Right.High
    end func "in"

    func "=?"(Left, Right : Closed_Interval) return Ordering is
        -- Compare two intervals, and consider them #unordered
        -- if they overlap at all, unless they are identical.
        -- If they don't overlap, then return #less or #greater as appropriate.

        if Left.High < Right.Low then
            return #less
        elsif Left.Low > Right.High then
            return #greater
        elsif Left.Low = Right.Low and then
          Left.High = Right.High then
            return #equal
        else
            return #unordered
        end if
    end func "=?"

end package SSL.Core.Closed_Interval

generic
    type Element is new Comparable

package SSL.Core.AA_Tree is

    -- This module implements a balanced "AA" tree, originally
    -- described by Arne Andersson in the "Proceedings of the Workshop
    -- on Algorithms and Data Structures," pp 60-71, Springer Verlag, 1993.
    -- The following algorithm and descriptions were taken from the
    -- WikiPedia article on AA_Tree: 
    --       http://en.wikipedia.org/wiki/AA_tree
    -- Note that various additional checks for a null tree have been added.

    -- Only two operations are needed for maintaining balance in an AA tree.
    -- These operations are called skew and split. Skew is a right rotation
    -- when an insertion or deletion creates a left horizontal link. Split
    -- is a conditional left rotation when an insertion or deletion creates two
    -- horizontal right links, which once again corresponds to two
    -- consecutive red links in red-black trees.

    type AA_Tree is private

    func "[]"() return optional AA_Tree
        -- Create an empty tree

    proc Insert(var T : optional AA_Tree; X : Element)
        -- input: X, the value to be inserted, and 
        -- T, the root of the tree to insert it into.
        -- output: A balanced T' including X.

    proc Delete(var T : optional AA_Tree; X : Element)
        -- input: X, the value to delete, and T, 
        -- the root of the tree from which it should be deleted.
        -- output: T', balanced, without the value X.

    func "in"(X : Element; T : optional AA_Tree) return Boolean

    func Overlapping(T : optional AA_Tree; X : Element) return optional Element
        -- input: X, the value to find, and T, 
        -- the root of the tree to be searched.
        -- output: the element equal to or "unordered" relative to X.

    proc "|="(var T : optional AA_Tree; X : Element) is Insert

    proc "<|="(var T : optional AA_Tree; var X : optional Element)
        -- Move X into AA_Tree, leaving X null.

    func First(T : optional AA_Tree) return optional Element
      -- Return first (smallest) element in tree

    func Last(T : optional AA_Tree) return optional Element
      -- Return last (greatest) element in tree

    func Remove_First(var T : optional AA_Tree) return optional Element
      -- Remove first (smallest) element in tree

    func Remove_Last(var T : optional AA_Tree) return optional Element
      -- Remove last (greatest) element in tree

    func Remove_Any(var T : optional AA_Tree) return optional Element
      -- Remove some element from tree

    func Count(T : optional AA_Tree) return Univ_Integer
      -- Return a count of the nodes in the tree

    func "magnitude"(AA_Tree) return Univ_Integer is Count

    func Is_Empty(T : optional AA_Tree) return Boolean
      -- Return True if the tree is empty

end package SSL.Core.AA_Tree

package body SSL.Core.AA_Tree is
    type AA_Tree is record
       Value : Element
       Level : Univ_Integer := 0
       Left : optional AA_Tree
       Right : optional AA_Tree
    end record AA_Tree

    func Node(var Value : optional Element; Level : Univ_Integer;
      Left, Right : optional AA_Tree) return AA_Tree is
        -- Create a new tree; move Value into it.
        return (Value <== Value, Level => Level, Left => Left, Right => Right)
    end func Node

    func Is_Leaf(T : optional AA_Tree) return Boolean is
        return T not null and then
          T.Left is null and then T.Right is null
    end func Is_Leaf

    func Leftmost(ref T : optional AA_Tree) return ref optional AA_Tree is
        for L => T loop
            if L not null and then L.Left not null then
                -- Continue with Left until we reach null
                continue loop with L => L.Left
            else
                -- Found left-most
                return L
            end if
        end loop
    end func Leftmost

    func Successor(T : optional AA_Tree) return optional Element is
        -- Return element in tree greater than but closest to T.Value
        if T.Right not null then
            const Succ := Leftmost(T.Right)
            {Succ not null}
            return Succ.Value
        else
            return null
        end if
    end func Successor

    func Rightmost(ref T : optional AA_Tree) return ref optional AA_Tree is
        for R => T loop
            if R not null and then R.Right not null then
                -- Keep following down Right side
                continue loop with R => R.Right
            else
                -- Found right-most
                return R
            end if
        end loop
    end func Rightmost

    func Predecessor(T : optional AA_Tree) return optional Element is
        -- Return element in tree less than but closest to T.Value
        if T.Left not null then
            return Rightmost(T.Left).Value
        else
            return null
        end if
    end func Predecessor

    proc Skew(var T : optional AA_Tree) is
      -- input: T, a node representing an AA tree that needs to be rebalanced.
      -- output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Left not null and then
          T.Left.Level = T.Level then
            -- The current T.Left becomes new root

            -- Exchange value of T.Left with root
            T.Value <=> T.Left.Value
           
            -- Move old root and T.Left.Right over to right side of tree
            T.Left.Right <=> T.Right
            T.Left.Left <=> T.Right
            T.Left <=> T.Right
        end if
    end proc Skew

    proc Split(var T : optional AA_Tree) is
        -- input: T, a node representing an AA tree that needs to be rebalanced.
        -- output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Right not null and then
          T.Right.Right not null and then
          T.Level = T.Right.Right.Level then
            -- T.Right becomes the new root
            -- Exchange value and level between root and T.Right
            T.Value <=> T.Right.Value
            T.Level <=> T.Right.Level

            -- Move old root and T.Right.Left to left side of tree
            T.Left <=> T.Right.Right
            T.Right.Left <=> T.Right.Right
            T.Left <=> T.Right

            -- Increment level
            T.Level += 1
        end if
    end proc Split

    proc Decrease_Level(var T : optional AA_Tree) is
        -- input: T, a tree for which we want to remove links that skip levels.
        -- output: T with its level decreased.

        if T is null then
            return
        end if
           
        var Should_Be : Univ_Integer := 1

        if T.Left not null then
            Should_Be := T.Left.Level + 1
        end if

        if T.Right not null then
            Should_Be := Min(Should_Be, T.Right.Level + 1)
        end if
            
        if Should_Be < T.Level then
            T.Level := Should_Be
            if T.Right not null and then
              Should_Be < T.Right.Level then
                T.Right.Level := Should_Be
            end if
        end if
    end proc Decrease_Level

  exports

    func "[]"() return optional AA_Tree is
        -- Create an empty tree
        return null
    end func "[]"

    -- Insertion begins with the normal binary tree search and insertion
    -- procedure. Then, as the call stack unwinds (assuming a recursive
    -- implementation of the search), it's easy to check the validity of the
    -- tree and perform any rotations as necessary. If a horizontal left link
    -- arises, a skew will be performed, and if two horizontal right links
    -- arise, a split will be performed, possibly incrementing the level of the
    -- new root node of the current subtree. Note, in the code as given above,
    -- the increment of T.Level. This makes it necessary to continue checking
    -- the validity of the tree as the modifications bubble up from the leaves.
    
    proc "<|="(var T : optional AA_Tree; var X : optional Element) is
      -- Move X into AA_Tree, leaving X null.
        -- input: X, the value to be inserted, and 
        -- T, the root of the tree to insert it into.
        -- output: A balanced T' including X.

        -- Do the normal binary tree insertion procedure. 
        -- Set the result of the recursive call to the correct 
        -- child in case a new node was created or the
        -- root of the subtree changes.

        if T is null then
            -- Create a new leaf node with X.
            T := Node(X, 1, null, null)
            return
        end if

        case X =? T.Value is
          when #less =>
            T.Left <|= X
          when #greater =>
            T.Right <|= X
          when #equal | #unordered =>
            -- Note that the case is X = T.Value is unspecified. 
            -- As given, an insert will have no effect. 
            -- The implementor may desire different behavior.
            X := null
            return
        end case

        -- Perform skew and then split. 
        -- The conditionals that determine whether or
        -- not a rotation will occur or not are inside 
        -- of the procedures, as given above.

        Skew(T)
        Split(T)
    end proc "<|="

    proc Insert(var T : optional AA_Tree; X : Element) is
      -- Just pass the buck to the "<|=" operation
        var X_Copy for T := X
        T <|= X_Copy
    end proc Insert

    -- As in most balanced binary trees, the deletion of an internal node can
    -- be turned into the deletion of a leaf node by swapping the internal node
    -- with either its closest predecessor or successor, depending on which are
    -- in the tree or on the implementor's whims. Retrieving a predecessor is
    -- simply a matter of following one left link and then all of the remaining
    -- right links. Similarly, the successor can be found by going right once
    -- and left until a null pointer is found. Because of the AA property of
    -- all nodes of level greater than one having two children, the successor
    -- or predecessor node will be in level 1, making their removal trivial.
    -- 
    -- To re-balance a tree, there are a few approaches. The one described by
    -- Andersson in his original paper is the simplest, and it is described
    -- here, although actual implementations may opt for a more optimized
    -- approach. After a removal, the first step to maintaining tree validity
    -- is to lower the level of any nodes whose children are two levels below
    -- them, or who are missing children. Then, the entire level must be skewed
    -- and split. This approach was favored, because when laid down
    -- conceptually, it has three easily understood separate steps:
    -- 
    --     Decrease the level, if appropriate.
    --     Skew the level.
    --     Split the level.
    -- 
    -- However, we have to skew and split the entire level this time instead of
    -- just a node, complicating our code.

    proc Delete(var T : optional AA_Tree; X : Element) is
        -- input: X, the value to delete, and T, 
        -- the root of the tree from which it should be deleted.
        -- output: T', balanced, without the value X.

        if T is null then
            -- Not in tree -- should we complain?
            return
        end if

        case X =? T.Value is
          when #less =>
            Delete(T.Left, X)
          when #greater =>
            Delete(T.Right, X)
          when #equal =>
            -- If we're a leaf, easy, otherwise reduce to leaf case. 
            if Is_Leaf(T) then
                T := null
            elsif T.Left is null then
                -- Get successor value and delete it from right tree,
                -- and set root to have that value
                const Succ := Successor(T)
                Delete(T.Right, Succ)
                T.Value := Succ
            else
                -- Get predecessor value and delete it from left tree,
                -- and set root to have that value
                const Pred := Predecessor(T)
                Delete(T.Left, Pred)
                T.Value := Pred
            end if
          when #unordered =>
            -- Not in tree; should we complain?
            return
        end case

        -- Rebalance the tree. Decrease the level of all nodes in this level if
        -- necessary, and then skew and split all nodes in the new level.

        if T is null then
            return
        end if

        Decrease_Level(T)
        Skew(T)
        Skew(T.Right)
        if T.Right not null then
            Skew(T.Right.Right)
        end if
        Split(T)
        Split(T.Right)
    end proc Delete

    func "in"(X : Element; T : optional AA_Tree) return Result : Boolean is
        for P => T while P not null loop
            case X =? P.Value is
              when #less =>
                continue loop with P => P.Left
              when #greater =>
                continue loop with P => P.Right
              when #equal =>
                return #True
              when #unordered =>
                return #False
            end case
        end loop
        return #False   -- Not found
    end func "in"

    func First(T : optional AA_Tree) return optional Element is
      -- Return first (smallest) element in tree
        if T is null then
            return null
        else 
            return Leftmost(T).Value
        end if
    end func First

    func Last(T : optional AA_Tree) return optional Element is
      -- Return last (greatest) element in tree
        if T is null then
            return null
        else
            return Rightmost(T).Value
        end if
    end func Last


    func Remove_First(var T : optional AA_Tree)
      return Result : optional Element is
      -- Remove first (smallest) element in tree
        Result := First(T)
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_First

    func Remove_Last(var T : optional AA_Tree)
      return Result : optional Element is
      -- Remove last (greatest) element in tree
        Result := Last(T)
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Last

    func Remove_Any(var T : optional AA_Tree)
      return Result : optional Element is
      -- Remove some element from tree
        if T is null then
            return null
        end if
        Result := T.Value
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Any

    func Is_Empty(T : optional AA_Tree) return Boolean is
      -- Return True if the tree is empty
        return T is null
    end func Is_Empty

    func Count(T : optional AA_Tree) return Univ_Integer is
      -- Return a count of the nodes in the tree
        if T is null then
            return 0
        else
            return Count(T.Left) + Count(T.Right) + 1
        end if
    end func Count

    func Overlapping(T : optional AA_Tree; X : Element)
      return optional Element is
        -- input: X, the value to find, and T, 
        -- the root of the tree to be searched.
        -- output: the element equal to or "unordered" relative to X.
        if T is null or else T.Value is null then
            return null
        else
            case X =? T.Value is
              when #less =>
                return Overlapping(T.Left, X)
              when #greater =>
                return Overlapping(T.Right, X)
              when #equal | #unordered =>
                -- Close enough
                return T.Value
            end case
        end if
    end func Overlapping

end package SSL.Core.AA_Tree

package body SSL.Containers.Countable_Set is

    subtype Element_Interval is Closed_Interval<Element_Type>

    type Countable_Set is record
        Items : optional AA_Tree<Element_Interval>
    end record Countable_Set

  exports

    func "[]"() return Countable_Set is
        return (Items => [])
    end func "[]"

    func Singleton(Elem : Element_Type) return Result : Countable_Set is
        Result := []
        Result.Items |= (Low => Elem, High => Elem)
    end func Singleton

    func ".."(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, High => Right)
        end if
    end func ".."
    
    func "<.."(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left+1, High => Right)
        end if
    end func "<.."
    
    func "<..<"(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left < Right-1 then
            Result.Items |= (Low => Left+1, High => Right-1)
        end if
    end func "<..<"
    
    func "..<"(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, High => Right-1)
        end if
    end func "..<"
    
    func "|"(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left >= Right-1 and then Left <= Right + 1 then
            -- Can combine elements into a single interval
            if Left <= Right then
                Result.Items |= (Low => Left, High => Right)
            else
                Result.Items |= (Low => Right, High => Left)
            end if
        else
            -- Make each element its own interval
            Result.Items |= (Low => Left, High => Left)
            Result.Items |= (Low => Right, High => Right)
        end if
    end func "|"

    func "|"(Left : Countable_Set; Right : Element_Type) 
      return Result : Countable_Set is
        Result := Left
        Result |= Right
    end func "|"

    func "|"(Left : Element_Type; Right : Countable_Set) return Countable_Set is
        return Right | Left
    end func "|"

    func "|"(Left : Countable_Set; Right : Countable_Set) 
      return Result : Countable_Set is
        Result := Left
        Result |= Right
    end func "|"

    proc "|="(var Left : Countable_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := (Low => Right, High => Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            -- Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end proc "|="

    proc "<|="(var Left : Countable_Set; var Right : optional Element_Type) is
        -- Move element into set, leaving Right null afterward.
        -- NOTE: No copy minimization done for countable types.
        Left |= Right
        Right := null
    end proc "<|="

    proc "<|="(var Left : Countable_Set; var Right : Countable_Set) is
        -- Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) = 0 then
            Left.Items <== Right.Items
        else
            -- Iterate through the tree
            loop
                -- Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)

                if Right_IV is null then
                    return   -- All done
                end if

                -- See whether it overlaps with an existing interval
                -- in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    if Left_IV.Low <= Right_IV.Low and then
                      Left_IV.High >= Right_IV.High then
                        -- Right_IV is subsumed; nothing to add in
                        Right_IV := null
                        exit loop
                    else
                        -- Need to delete Left_IV and incorporate
                        -- into Right_IV
                        Delete(Left.Items, Left_IV)
                        if Left_IV.Low < Right_IV.Low then
                            Right_IV.Low := Left_IV.Low
                        end if
                        if Left_IV.High > Right_IV.High then
                            Right_IV.High := Left_IV.High
                        end if

                        -- Now see if there is anything still overlapping
                        Left_IV := Overlapping(Left.Items, Right_IV)
                    end if
                end loop

                if Right_IV not null then
                    -- Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end proc "<|="

    proc "|="(var Left : Countable_Set; Right : Countable_Set) is
        -- Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end proc "|="

    func "-"(Left, Right : Countable_Set) return Result : Countable_Set is
      -- Set difference
        Result := Left
        Result -= Right
    end func "-"

    func "-"(Left : Countable_Set; Right : Element_Type)
      return Result : Countable_Set is
      -- Remove one element
        Result := Left
        Result -= Right
    end func "-"
        
    proc "-="(var S : Countable_Set; Elem : Element_Type) is
      -- Remove the given element from the set, if present
        const IV := Overlapping(S.Items, (Low => Elem, High => Elem))
          -- Get interval, if any, which overlaps given element

        if IV not null then
            -- Delete interval and put back after removing Elem
            Delete(S.Items, IV)
            if IV.High > IV.Low then
                -- We need to put something back
                if IV.Low = Elem then
                    S.Items |= (Low => IV.Low + 1, High => IV.High)
                elsif IV.High = Elem then
                    S.Items |= (Low => IV.Low, High => IV.High-1)
                else
                    -- Elem is in the middle, put back intervals
                    -- on either side.
                    S.Items |= (Low => IV.Low, High => Elem-1)
                    S.Items |= (Low => Elem+1, High => IV.High)
                end if
            end if
        end if

    end proc "-="

    proc "-="(var Left : Countable_Set; Right : Countable_Set) is
      -- Remove all elements of Right from Left, if present
        for Elem in Right loop
            Left -= Elem
        end loop
    end proc "-="

    func "and"(Left, Right : Countable_Set) return Result : Countable_Set is
        -- Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end func "and"

    proc "and="(var Left : Countable_Set; Right : Countable_Set) is
        -- Intersection
        for Elem in Left loop
            if Elem not in Right then
                Left -= Elem
            end if
        end loop
    end proc "and="

    func "xor"(Left, Right : Countable_Set) return Result : Countable_Set is
        -- Symmetric difference
        Result := Left
        Result xor= Right
    end func "xor"

    proc "xor="(var Left : Countable_Set; Right : Countable_Set) is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end proc "xor="

    func "in"(Left : Element_Type; Right : Countable_Set) return Boolean is
        return Overlapping(Right.Items, (Low => Left, High => Left)) not null
    end func "in"

    func "=?"(Left, Right : Countable_Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            -- Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                -- Left is a superset
                return #greater
            end if
        else
            -- Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                -- Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end func "=?"

    func Count(S : Countable_Set) return Result : Univ_Integer is
        -- Return count of items in set

        Result := 0

        -- Copy items and then iterate through them to build up count
        var Items := S.Items
        var Next_IV := Remove_Any(Items)
        while Next_IV not null loop
            Result += Next_IV.High - Next_IV.Low + 1
            Next_IV := Remove_Any(Items)
        end loop
    end func Count

    func Is_Empty(S : Countable_Set) return Boolean is
        return Is_Empty(S.Items)
    end func Is_Empty

    func First(S : Countable_Set) return optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end func First

    func Last(S : Countable_Set) return optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end func Last

    func Remove_First(var S : Countable_Set) 
      return Result : optional Element_Type is
        -- Return first element of set

        -- Get first interval in tree
        var First_IV := Remove_First(S.Items)
        if First_IV is null then
            -- Tree is empty
            return null
        end if

        -- See whether interval has more than one value in it
        if First_IV.High > First_IV.Low then
            -- Need to put back the remainder
            S.Items |= (Low => First_IV.Low+1, High => First_IV.High)
        end if

        -- Return first item
        return First_IV.Low
    end func Remove_First

    func Remove_Last(var S : Countable_Set) return Result : optional Element_Type is
        -- Remove last element of set

        -- Get Last interval in tree
        var Last_IV := Remove_Last(S.Items)
        if Last_IV is null then
            -- Tree is empty
            return null
        end if

        -- See whether interval has more than one value in it
        if Last_IV.High > Last_IV.Low then
            -- Need to put back the remainder
            S.Items |= (Low => Last_IV.Low, High => Last_IV.High-1)
        end if

        -- Return Last item
        return Last_IV.High
    end func Remove_Last

    func Remove_Any(var S : Countable_Set) return optional Element_Type is
        -- Remove any element of set

        -- Get any interval in tree
        var Any_IV := Remove_Any(S.Items)
        if Any_IV is null then
            -- Tree is empty
            return null
        end if

        -- See whether interval has more than one value in it
        if Any_IV.High > Any_IV.Low then
            -- Need to remove one to return and put back the remainder
            if (Any_IV.High - Any_IV.Low) mod 2 = 0 then
                -- Return high bound when high-low is even
                -- NOTE: We do this to avoid having algorithms become
                --       dependent on always getting values in ascending 
                --       or descending order.
                S.Items |= (Low => Any_IV.Low, High => Any_IV.High-1)
                return Any_IV.High
            else
                -- Return low bound when high-low is odd
                S.Items |= (Low => Any_IV.Low+1, High => Any_IV.High)
                return Any_IV.Low
            end if
        else
            -- Return only item in interval
            return Any_IV.Low
        end if

    end func Remove_Any

end package SSL.Containers.Countable_Set

proc SSL.Test.Test_Countable_Set(A, X, Y, Z : Integer) is
    var S : Countable_Set<Integer> := X | Y..Z
    Println(A & " in " & X & "|" & Y & ".." & Z & "=" & ( A in S ))

    const Agg : Countable_Set<Integer> := [X, Y, Z]
    const Or : Countable_Set<Integer> := Y | Z | X

    Println(" [X, Y, Z] =? (Y | Z | X) --> " & ( Agg =? Or ))

    for J in S loop 
        Println("Remove_Any(S) = " & J)
    end loop

    S := []

    for I in 1..10 forward loop
        S += I
        Println("Adding " & I & " to S, Count = " & Count(S))
    end loop

    for K in S loop 
        Println("Remove_Any(S) = " & K)
    end loop

    Println("Count(S) = " & Count(S))
    S -= 7
    Println("After S -= 7, Count(S) = " & Count(S))

    var Xor := S xor [2, 5, 12, 15]
    Print("S xor [2, 5, 12, 15] = ")
    for J in Xor forward loop
        Print(J & " ")
    end loop
    Print('\n')
end proc SSL.Test.Test_Countable_Set

package SSL.Core.Countable is
    type Countable is abstract new Countable_Base

    --  The following 8 ops are inherited (TBD: overriding NYI)

    --  func "+"(Left : Countable; Right : Univ_Integer) return Countable
    --  func "+"(Left : Univ_Integer; Right : Countable) return Countable

    --  func "-"(Left : Countable; Right : Univ_Integer) return Countable
    --  func "-"(Left, Right : Countable) return Univ_Integer

    --  func "=?"(Left, Right : Countable) return Ordered.Full_Ordering

    --  func First() return Countable

    --  func Last() return Countable

    --  func Hash(Val : Countable) return Univ_Integer

    --  TBD: operations (or package?) should be declared abstract

    abstract
      func ".."(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract
      func "<.."(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract
      func "..<"(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract
      func "<..<"(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract func "|"(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
end package SSL.Core.Countable

package SSL.Core.Ordering is
    type Ordering is private;

    func "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#less, #equal, #greater, #unordered]}
      return Ordering is import(#ordering_from_univ)

    func "to_univ"(Val : Ordering) return Univ_Enumeration 
      is import(#ordering_to_univ)

    func "to_bool"(Ord : Ordering; Mask : Univ_Integer) return Boolean 
      is import(#ordering_to_bool)

    func "=?"(Left, Right : Ordering) return Ordering is import("=?")

    func Hash(Val : Ordering) return Univ_Integer
      is import(#identity)

    -- For Imageable
    func Image(Val : Ordering) return Univ_String
    func Value(Str : Univ_String) return optional Ordering

    -- Operators for Countable
    func "+"(Left : Univ_Integer; Right : Ordering) return Ordering 
      is import("+")
    func "+"(Left : Ordering; Right : Univ_Integer) return Ordering 
      is import("+")
    func "-"(Left, Right : Ordering) return Univ_Integer 
      is import("-")
    func "-"(Left : Ordering; Right : Univ_Integer) return Ordering 
      is import("-")

    -- TBD: These should be properties some day (e.g. Ordering#first).
    func First() return Ordering
    func Last() return Ordering

    func Min(Left, Right : optional Ordering) return optional Ordering
      is import(#min)
    func Max(Left, Right : optional Ordering) return optional Ordering
      is import(#max)

    func ".."(Left, Right : Ordering) return Countable_Set<Ordering>
    func "<.."(Left, Right : Ordering) return Countable_Set<Ordering>
    func "..<"(Left, Right : Ordering) return Countable_Set<Ordering>
    func "<..<"(Left, Right : Ordering) return Countable_Set<Ordering>
    func "|"(Left, Right : Ordering) return Countable_Set<Ordering>
end package SSL.Core.Ordering

package body SSL.Core.Ordering is
    subtype Ordering_Set is Countable_Set<Ordering>

  exports
    func First() return Ordering is
        return #less
    end func First

    func Last() return Ordering is
        return #unordered
    end func Last

    func Image(Val : Ordering) return Univ_String is
        case Val is
          when #less =>
            return "#less"
          when #equal =>
            return "#equal"
          when #greater =>
            return "#greater"
          when #unordered =>
            return "#unordered"
        end case
    end func Image

    func Value(Str : Univ_String) return optional Ordering is
        case Str is
          when "#less" =>
            return #less
          when "#equal" =>
            return #equal
          when "#greater" =>
            return #greater
          when "#unordered" =>
            return #unordered
          when others =>
            return null
        end case
    end func Value

    -- NOTE: For implementation reasons, we put these here rather than defining
    --       them in the interface using "is of Countable_Set<Ordering>"
    func ".."(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'".."(Left, Right)
    end func ".."

    func "<.."(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"<.."(Left, Right)
    end func "<.."

    func "..<"(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"..<"(Left, Right)
    end func "..<"
    func "<..<"(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"<..<"(Left, Right)
    end func "<..<"

    func "|"(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"|"(Left, Right)
    end func "|"
end package SSL.Core.Ordering

generic
  Range : Countable_Range<Univ_Integer> := -2**62 .. +2**62
package SSL.Core.Integer is
    -- NOTE: We restrict Integer to this range so Univ_Integer can use
    --       values outside this range as indices into an extended-range
    --       integer table.
    type Integer is private;

    func "from_univ"(Lit : Univ_Integer) return Integer 
      is import(#integer_from_univ)

    func "to_univ"(Val : Integer) return Univ_Integer 
      is import(#integer_to_univ)

    func "+"(Right : Integer) return Integer
      is import(#identity)

    func "-"(Right : Integer) return Integer
      is import(#negate)

    func "abs"(Right : Integer) return Integer
      is import("abs")

    func "magnitude"(Integer) return Integer is "abs"

    func "+"(Left, Right : Integer) return Result : Integer 
      is import("+")

    func "-"(Left, Right : Integer) return Result : Integer
      is import("-")

    func "*"(Left, Right : Integer) return Result : Integer 
      is import("*")

    func "/"(Left, Right : Integer) return Result : Integer
      is import("/")

    func "mod"(Left, Right : Integer) return Integer
      is import("mod")

    func "rem"(Left, Right : Integer) return Integer
      is import("rem")

    func "**"(Left, Right : Integer) return Result : Integer
      is import("**")

    proc "+="(var Left : Integer; Right : Integer) 
      is import("+=")

    proc "-="(var Left : Integer; Right : Integer) 
      is import("-=")

    proc "*="(var Left : Integer; Right : Integer) 
      is import("*=")

    proc "/="(var Left : Integer; Right : Integer) 
      is import("/=")

    proc "**="(var Left : Integer; Right : Integer) 
      is import("**=")

    func "=?"(Left, Right : Integer) return Ordering
      is import("=?")

    func ">>"(Integer; Integer) return Integer is import(">>")

    func "<<"(Integer; Integer) return Integer is import("<<")

    func Min(Left, Right : optional Integer) return optional Integer
      is import(#min)
    func Max(Left, Right : optional Integer) return optional Integer
      is import(#max)

    func Hash(Val : Integer) return Univ_Integer
      is import(#identity)

    proc Print(X : Integer) is import(#print_int)

    proc Put(X : Integer) is Print

    func Image(Val : Integer) return Univ_String
      is import(#to_string_int)

    func Value(Str : Univ_String) return optional Integer
      is import(#from_string_int)

    func First() return Integer

    func Last() return Integer

    func "[..]"() return Countable_Range<Integer> is of Countable_Range<Integer>

    func ".."(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    func "<.."(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    func "..<"(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    func "<..<"(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    func "|"(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>

  implements -- for Countable

    -- These operations are needed so Integer satifies
    -- requirements of "Countable" interface, but these
    -- operations are not directly callable (if they were callable,
    -- we would have ambiguity when adding an integer to an int-literal).

    func "+"(Left : Integer; Right : Univ_Integer) return Result : Integer 
      is import("+")

    func "+"(Left : Univ_Integer; Right : Integer) return Result : Integer 
      is import("+")

    func "-"(Left : Integer; Right : Univ_Integer) return Result : Integer 
      is import("-")

    func "-"(Left, Right : Integer) return Result : Univ_Integer
      is import("-")

end package SSL.Core.Integer

package body SSL.Core.Integer is
    type Integer is record
       const Content : Univ_Integer;  -- So this ends up as a wrapper
    end record Integer

  exports
    func First() return Integer is
        return Range.First
    end func First

    func Last() return Integer is
        return Range.Last
    end func Last

end package SSL.Core.Integer

proc SSL.Test.Test_Integer(X, Y : Univ_Integer) is
   -- type I6 is new Integer<1..10**6>
   subtype I6 is Integer<1..10**6>
   var A : I6 := X
   var B : I6 := Y

   var C : I6 := A + B
   Println (" " & A & " + " & B & " = " & C)
end proc SSL.Test.Test_Integer
    
generic
    type Bound_Type is new Comparable
package SSL.Core.Interval is
    -- This supports closed, half-open, and open intervals.
    -- This is appropriate for uncountable types where you
    -- can't normalize all intervals into closed intervals.

    type Interval is record
        Low : Bound_Type
        Low_Is_Open : Boolean
        High : Bound_Type
        High_Is_Open : Boolean
    end record Interval

    func Singleton(Val : Bound_Type) return Interval
      -- Return interval consisting of a single value

    func Is_Empty(IV : optional Interval) return Boolean
      -- Return True if interval is null or it represents
      -- no values

    func "in"(Left : Bound_Type; Right : Interval) return Boolean

    func "=?"(Left, Right : Interval) return Ordering
      -- "#greater" means Left is strictly greater than Right
      -- "#less" means Left is strictly less than Right
      -- "#equal" means Left and Right are the same interval
      -- "#unordered" means anything else

    func "and"(Left, Right : Interval) return optional Interval
      -- Return intersection of the two intervals

    proc "and="(var Left : optional Interval; Right : Interval)
      -- Intersect Right into Left

    func Is_Strictly_Within(Left, Right : optional Interval) return Boolean
      -- Return #True if Left is strictly within Right,
      -- meaning low bound of Left is higher, and high bound is lower.
      -- NOTE: If #True, then removing Right from Left will produce two 
      --       non-overlapping intervals.

    func "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      return optional Interval
      -- Subtract out Right interval from Left interval
      -- Right must not be strictly within Left, since
      -- that would require return ing two intervals.

    proc "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)}
      -- Subtract Right interval from Left

    func Overlaps(Left, Right : optional Interval) return Boolean
      -- Return True if intervals overlap

    func "or"(Left, Right : Interval) {Overlaps(Left, Right)} return Interval
      -- Return union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
    func "|"(Left, Right : Interval) {Overlaps(Left, Right)}
      return Interval is "or"

    proc "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)}
      -- Compute union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
    proc "|="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is "or="

    proc "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)}
      -- Compute union of two intervals; leave Right empty.  
      -- Must have some overlap to ensure that result can be 
      -- represented as a single interval.

end package SSL.Core.Interval

package body SSL.Core.Interval is
  exports
    func Singleton(Val : Bound_Type) return Interval is
      -- Return interval consisting of a single value
        return (Low => Val, Low_Is_Open => #False,
          High => Val, High_Is_Open => #False)
    end func Singleton

    func Is_Empty(IV : optional Interval) return Boolean is
      -- Return True if interval is null or it represents
      -- no values
        return IV is null or else
          IV.Low > IV.High or else
          (IV.Low = IV.High and then (IV.Low_Is_Open or IV.High_Is_Open))
    end func Is_Empty

    func "in"(Left : Bound_Type; Right : Interval) return Boolean is
        case Left =? Right.Low is
          when #less => return #False
          when #equal => return not Right.Low_Is_Open
          when #greater =>
            case Left =? Right.High is
              when #less => return #True
              when #equal => return not Right.High_Is_Open
              when #greater => return #False
            end case
        end case
    end func "in"

    func "=?"(Left, Right : Interval) return Ordering is
        -- Compare two intervals, and consider them #unordered
        -- if they overlap at all, unless they are identical.
        -- If they don't overlap, then return #less or #greater as appropriate.
        -- Return #unordered if any of the comparisons return #unordered.

        -- First check for perfect equality
        if Left.Low = Right.Low and then
          Left.High = Right.High and then
          Left.Low_Is_Open = Right.Low_Is_Open and then
          Left.High_Is_Open = Right.High_Is_Open then
            -- NOTE: We are considering X..Y-1 /= X..<Y since
            --       we don't require countable elements.
            return #equal
        end if

        case Left.High =? Right.Low is
          when #unordered =>
            return #unordered
          when #less =>
            return #less
          when #equal =>
            if Left.High_Is_Open or else Right.Low_Is_Open then
                -- No overlap
                return #less
            else
                -- We have already ruled out #equal
                return #unordered
            end if
          when #greater =>
            -- Not clearly less, see whether clearly greater.
            case Left.Low =? Right.High is
              when #unordered =>
                return #unordered
              when #less =>
                -- We have already ruled out #equal
                return #unordered
              when #equal =>
                if Left.Low_Is_Open or else Right.High_Is_Open then
                    -- No overlap
                    return #greater
                else
                    -- We have already ruled out #equal
                    return #unordered
                end if
              when #greater =>
                return #greater
            end case
        end case
    end func "=?"

    func "and"(Left, Right : Interval) return optional Interval is
      -- Return intersection of the two intervals
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
        
        case Left.Low =? Right.Low is
          when #less => 
            New_Low := Right.Low
            New_Low_Is_Open := Right.Low_Is_Open
          when #greater => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open
          when #equal => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open or Right.Low_Is_Open
          when #unordered => 
            return null
        end case
      
        case Left.High =? Right.High is
          when #less => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open
          when #greater => 
            New_High := Right.High
            New_High_Is_Open := Right.High_Is_Open
          when #equal => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open or Right.High_Is_Open
          when #unordered => 
            return null
        end case
      
        return (Low => New_Low, Low_Is_Open => New_Low_Is_Open,
          High => New_High, High_Is_Open => New_High_Is_Open)
    end func "and"

    proc "and="(var Left : optional Interval; Right : Interval) is
      -- Intersect Right into Left
        if Left not null then
            Left := Left and Right
        end if
    end proc "and="

    func Is_Strictly_Within(Left, Right : optional Interval) return Boolean is
      -- Return #True if Left is strictly within Right,
      -- meaning low bound of Left is higher, and high bound is lower.
      -- NOTE: If #True, then removing Right from Left will produce two 
      --       non-overlapping intervals.
        if Right is null or else Left is null then
            return #False
        end if
        return (Left.Low > Right.Low or else 
          (Left.Low = Right.Low and then Left.Low_Is_Open > Right.Low_Is_Open))
          and then
            (Left.High < Right.High or else
             (Left.High = Right.High and then 
              Left.High_Is_Open > Right.High_Is_Open))
    end func Is_Strictly_Within

    func "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      return Result : optional Interval is
      -- Subtract out Right interval from Left interval
      -- Right must not be strictly within Left, since
      -- that would require return ing two intervals.
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
  
        case Left.Low =? Right.Low is
          when #less => 
            -- Return left part of Left
            Result := (Low => Left.Low, Low_Is_Open => Left.Low_Is_Open,
              High => Right.Low, High_Is_Open => not Right.Low_Is_Open)
          when #greater => 
            -- Return right part of Left
            Result := (Low => Right.High, Low_Is_Open => not Right.High_Is_Open,
              High => Left.High, High_Is_Open => Left.High_Is_Open)
          when #equal => 
            if Left.Low_Is_Open >= Right.Low_Is_Open then
                -- Return right part of Left
                Result := (Low => Right.High, 
                  Low_Is_Open => not Right.High_Is_Open,
                  High => Left.High, 
                  High_Is_Open => Left.High_Is_Open)
            else
                -- Only one element is left
                return (Left.Low, #False, Left.Low, #False)
            end if
          when #unordered => 
            return null
        end case
      
        if Result.Low > Result.High then
            -- Empty interval
            return null
        elsif Result.Low = Result.High and then
          (Result.Low_Is_Open or Result.High_Is_Open) then
            -- Empty interval
            return null
        else
            return Result
        end if
    end func "-"

    proc "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)} is
      -- Subtract Right interval from Left
        if Left not null then
            Left := Left - Right
        end if
    end proc "-="

    func Overlaps(Left, Right : optional Interval) return Boolean is
        if Left is null or else Right is null then
            return #False
        else
            case Left =? Right is
              when #equal | #unordered => return #True
              when #less | #greater => return #False
            end case
        end if
    end func Overlaps

    func "or"(Left, Right : Interval) {Overlaps(Left, Right)} 
      return Result : Interval is
      -- Return union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
  
        Result := Left
        Result or= Right
    end func "or"

    proc "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is
      -- Compute union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end proc "or="

    proc "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)} is
      -- Compute union of two intervals; leave Right empty.  
      -- Must have some overlap to ensure that result can be 
      -- represented as a single interval.
        if Left is null then
            Left <== Right
        elsif Right not null then
            var Right_Copy <== Right
                -- Make copy and null out Right, so
                -- we don't end up with Right partially nulled out
            
            case Left.Low =? Right_Copy.Low is
              when #less => 
                -- No change to Left.Low
                null
              when #greater => 
                Left.Low <== Right_Copy.Low
                Left.Low_Is_Open := Right_Copy.Low_Is_Open
              when #equal => 
                Left.Low_Is_Open and= Right_Copy.Low_Is_Open
            end case
      
            case Left.High =? Right_Copy.High is
              when #less => 
                Left.High <== Right_Copy.High
                Left.High_Is_Open := Right_Copy.High_Is_Open
              when #greater => 
                -- No change to Left.High
                null
              when #equal => 
                Left.High_Is_Open and= Right_Copy.High_Is_Open
            end case
        end if
    end proc "<|="

end package SSL.Core.Interval

proc SSL.Test.Test_Interval(X, Y, Z : Univ_Integer) is
    var Y_Up_To_Z : Interval<Univ_Integer> := 
      (Low => Y, Low_Is_Open => #False, High => Z, High_Is_Open => #True)

    Println(X & " in " & Y & "..<" & Z & " = " & (X in Y_Up_To_Z))

    var Y_To_Z : Closed_Interval<Univ_Integer> := (Low => Y, High => Z)

    Println(X & " in " & Y & ".." & Z & " = " & (X in Y_To_Z))

    var One_To_X : Closed_Interval<Univ_Integer> :=
      (Low => 1, High => X)

    Println(1 & ".." & X & "=?" & Y & ".." & Z & " = " & 
      (One_To_X =? Y_To_Z))

end proc SSL.Test.Test_Interval

proc SSL.Test.Test_AA_Tree
  (A : Univ_Integer; B : Univ_Integer; C : Univ_Integer) is
    subtype Univ_Tree is AA_Tree<Univ_Integer>
    var T : Univ_Tree := []
    var X : Univ_Integer := A

    Insert(T, A)
    Println("Count = " & Count(T) & " after insert of " & A)
    Insert(T, B)
    Println("Count = " & Count(T) & " after insert of " & B)
    Insert(T, C)
    Println("Count = " & Count(T) & " after insert of " & C)

    Insert(T, A)
    Println("Count = " & Count(T) & " after another insert of " & A)

    Println(A & " in T = " & (A in T))
    Println(B & " in T = " & (B in T))
    Println(C & " in T = " & (C in T))
    Println("7 in T = " & (7 in T))

    for E := Remove_First(T) then Remove_First(T) while E not null loop
        Println("Remove_First = " & E)
    end loop

    Println("Count after loop : " & Count(T))

    for I in 1..10 forward loop
        Insert(T, I)
        Println("Count = " & Count(T) & " after insert of " & I)
    end loop

    for L := Remove_Last(T) then Remove_Last(T) while L not null loop
        Println("Remove_Last = " & L)
    end loop

    Println("Count after loop : " & Count(T))

    for J in 1..10 reverse loop
        Insert(T, J)
        Println("Count = " & Count(T) & " after insert of " & J)
    end loop

    Println("Count after loop : " & Count(T))

    Println("Overlapping(T, 5) = " & Overlapping(T, 5))

    for Z := Remove_Any(T) then Remove_Any(T) while Z not null loop
        Println("Remove_Any = " & Z)
    end loop

    Println("Count after loop : " & Count(T))

    for K in 1..10 loop
        Insert(T, K)
        Println("Count = " & Count(T) & " after insert of " & K)
    end loop

    for F := Remove_First(T) then Remove_First(T) while F not null loop
        Println("Remove_First = " & F)
    end loop

    Println("Count after loop : " & Count(T))

end proc SSL.Test.Test_AA_Tree

generic
    type Key_Type is new Hashable
package SSL.Containers.Keyed is
    type Keyed is abstract private

    abstract func Key_Of(ref const KV : Keyed) return ref const Key_Type
    abstract func Has_Value(KV : Keyed) return Boolean
      -- Return #True if Keyed object has a non-null value
    abstract func Key_Only(Key : Key_Type) return Keyed
      -- Return a Keyed object given a key, having no associated value
end package SSL.Containers.Keyed

generic
    type Key_Type_KV is new Hashable;
    type Value_Type is new Assignable
package SSL.Containers.Key_Value is
  -- This supports the use of [Key => Value] as a way to
  -- add a single element to an existing indexable container of some sort.
    type Key_Value is new Keyed<Key_Type_KV> with record
         Key : optional Key_Type_KV
         Value : optional Value_Type
    end record Key_Value

    func "[]"() return Key_Value
    func "var_indexing"(ref var KV : Key_Value; Index : Key_Type_KV) 
      return ref var Value_Type
    func Key_Of(ref const KV : Key_Value) return ref const Key_Type_KV
    func Has_Value(KV : Key_Value) return Boolean
      -- Return #True if Key_Value object has a non-null value
    func Key_Only(Key : Key_Type_KV) return Key_Value
      -- Return a Key_Value object given a key, having no associated value
end package SSL.Containers.Key_Value

package body SSL.Containers.Key_Value is
  exports
    func "[]"() return Key_Value is
        return (Key => null, Value => null)
    end func "[]"

    func "var_indexing"(ref var KV : Key_Value; Index : Key_Type_KV) 
      return ref var Value_Type is
        KV.Key := Index
        return KV.Value
    end func "var_indexing"

    func Key_Of(ref const KV : Key_Value) return ref const Key_Type_KV is
        return KV.Key
    end func Key_Of

    func Has_Value(KV : Key_Value) return Boolean is
        -- Return #True if Key_Value object has a non-null value
        return KV.Value not null
    end func Has_Value

    func Key_Only(Key : Key_Type_KV) return Key_Value is
        -- Return a Key_Value object given a key, having no associated value
        return [Key => null]
    end func Key_Only
end package SSL.Containers.Key_Value

generic
    type KV_Type is new Keyed
package SSL.Containers.Basic_Map is
  -- A basic hashed-map module
    type Basic_Map is private

    func "[]"() return Basic_Map

    proc "|="(var Left : Basic_Map; Right : KV_Type)
      -- Add Key=>Value to Basic_Map, replacing pre-existing Basic_Mapping
      -- for Key, if any.

    proc "<|="(var Left : Basic_Map; var Right : optional KV_Type)
      -- Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
      -- for Key, if any, leaving Right null.

    proc "+="(var Left : Basic_Map; Right : KV_Type) is "|="
      -- A synonym for adding a key=>value KV_Type

    func "in"(Left : KV_Type'Key_Type; Right : Basic_Map) return Boolean
      -- Return True if given key has a Basic_Mapping in the Basic_Map

    proc "-="(var M : Basic_Map; Key : KV_Type'Key_Type)   -- aka Exclude
      -- Remove Basic_Mapping for Right, if present

    func "index_set"(M : Basic_Map) return Set<KV_Type'Key_Type>
      -- Return set of keys with Basic_Mappings

    func "indexing"(ref M : Basic_Map; Key : KV_Type'Key_Type) {Key in M} 
      return ref KV_Type
      -- Used for references to M[Key]; requires the Key to be in M.

    func "var_indexing"(ref var M : Basic_Map; Key : KV_Type'Key_Type) 
      return ref var optional KV_Type
      -- Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Basic_Map) return optional KV_Type
      -- Remove one Basic_Mapping from the Basic_Map.  
      -- Return null if Basic_Map is empty

    func Count(M : Basic_Map) return Univ_Integer
      -- Number of Basic_Mappings in the table

    func "magnitude"(Basic_Map) return Univ_Integer is Count

    func Is_Empty(M : Basic_Map) return Boolean
      -- Return True if map has no mappings

    proc Dump_Statistics(M : Basic_Map)
      -- A debugging routine to show bucket sizes of Basic_Map

end package SSL.Containers.Basic_Map

package body SSL.Containers.Basic_Map is
  -- A basic hashed-map module

  -- A Basic_Map is represented as a hash table, where each bucket is 
  -- a linked list of key/value KV_Types.
  -- When key/value KV_Types are deleted from the Basic_Map they end 
  -- up as "null"s in the list.  
  -- We expand the table when the Count gets to be twice
  -- that of the length of the table.

    type Hash_Bucket is record
      -- a simple linked-list is used as a hash bucket
        Elem : optional KV_Type
        Tail : optional Hash_Bucket
    end record Hash_Bucket

    type Basic_Map is record
        Count : Univ_Integer
        Table : optional Basic_Array<optional Hash_Bucket>
    end record;

    const Initial_Table_Size := 4
    const Debugging : Boolean := #False
    
    func Empty(Table_Size : Univ_Integer) return Basic_Map is
        -- Create an empty Basic_Map with the given table size
        return (Count => 0, Table => Create(Table_Size, null))
    end func Empty

    proc Move_One(var To : Basic_Map; var Elem : optional KV_Type) is
        -- Move Element into table, without expanding table.
        -- Elem is set to null as a result.
        const Index := Hash(Key_Of(Elem)) mod |To.Table| + 1
        ref Bucket => To.Table[Index]
      
        if Bucket is null then
            -- Bucket is now empty, so create bucket
            -- with Elem as its only element.
            Bucket := (Elem <== Elem, Tail => null)
        else
            -- See whether Elem already in bucket
            var Has_Empty_Slot : Boolean := #False
            for B => Bucket then B.Tail while B not null loop
                if B.Elem is null then
                    -- Remember there is an empty slot
                    Has_Empty_Slot := #True
                elsif Key_Of(Elem) = Key_Of(B.Elem) then
                    -- Already there; replace it in case Value is different.
                    B.Elem <== Elem
                    return
                end if
            end loop
      
            if Has_Empty_Slot then
                -- Fill in the empty slot
                for B => Bucket then B.Tail while B not null loop
                    if B.Elem is null then
                        -- Use the empty slot
                        B.Elem <== Elem
                        exit loop
                    end if
                end loop
            else
                -- Make old bucket the new tail of the new bucket.
                Bucket := (Elem <== Elem, Tail <== Bucket)
            end if
        end if
      
        To.Count += 1
    end proc Move_One
      
    proc Add_One(var To : Basic_Map; Elem : KV_Type) is
        -- Add Element to table, without expanding it
        var Elem_Copy for To := Elem
      
        -- Just pass the buck to "Move_One"
        Move_One(To, Elem_Copy)
    end proc Add_One
      
    proc Expand_Table(var Expanding : Basic_Map) is
        -- Expand table of given Basic_Map.
        if Debugging then
            Println(" Expanding hash table, Count = " & Expanding.Count & 
              ", Length = " & |Expanding.Table|)
        end if
        var Old_Basic_Map <== Expanding
        Expanding := Empty(2 * |Old_Basic_Map.Table|)
        -- Move elements into new table
        loop
            var Elem for Expanding := Remove_Any(Old_Basic_Map)
                -- "for Expanding" means to allocate Elem in
                -- region associated with Expanding.
            if Elem is null then
                exit loop
            end if
            Move_One(Expanding, Elem)
        end loop
        if Debugging then
            Println(" After expansion, Count = " & Expanding.Count &
              ", Length = " & |Expanding.Table|)
        end if
    end proc Expand_Table
      
  exports
    func "[]"() return Basic_Map is
        return (Count => 0, Table => null)
    end func "[]"
      
    proc "|="(var Left : Basic_Map; Right : KV_Type) is
        if not Has_Value(Right) then
            -- Putting in Key => null is equivalent to deleting Key
            Left -= Key_Of(Right)
            return
        end if
      
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            -- Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if

        Add_One(Left, Right)
    end proc "|="
      
    proc "<|="(var Left : Basic_Map; var Right : optional KV_Type) is
        -- Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
        -- for Key, if any, leaving Right null.
        if not Has_Value(Right) then
            -- Putting in Key => null is equivalent to deleting Key
            Left -= Key_Of(Right)
            Right := null
            return
        end if
      
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            -- Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if
        Move_One(Left, Right)
    end proc "<|="
      
    func "in"(Left : KV_Type'Key_Type; Right : Basic_Map) return Boolean is
        if Right.Count = 0 then
            -- Empty Basic_Map
            return #False
        end if
        const Index := Hash(Left) mod Length(Right.Table) + 1
        ref Bucket => Right.Table[Index]
        if Bucket is null then
            -- Hash bucket is empty
            return #False
        end if
        -- Scan for Elem in hash bucket
        for B => Bucket then B.Tail while B not null loop 
            if B.Elem not null and then
              Has_Value(B.Elem) and then
              Key_Of(B.Elem) = Left then
                -- Found it
                return #True
            end if
        end loop
        -- Not in Basic_Map
        return #False
    end func "in"
      
    proc "-="(var M : Basic_Map; Key : KV_Type'Key_Type) is
            -- Remove the given key from the Basic_Map, if present
        if M.Count = 0 then
            -- Empty Basic_Map
            return
        end if
      
        const Index := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        if Bucket is null then
            -- Hash bucket is empty
            return
        end if
      
        -- Scan for Key in bucket
        for B => Bucket then B.Tail while B not null loop
            if B.Elem not null and then
              Key_Of(B.Elem) = Key then
                -- Found it.  Map it to null, and decrement Basic_Map count.
                B.Elem := null
                M.Count -= 1
                return
            end if
        end loop
        -- Not found
    end proc "-="
         
    func "index_set"(M : Basic_Map) return Result : Set<KV_Type'Key_Type> is
        -- Return set of keys with non-null Basic_Mappings
        Result := []
        if M.Count = 0 then
            return
        end if
        for each Bucket of M.Table loop
            for B => Bucket then B.Tail while B not null loop
                if B.Elem not null and then
                  Has_Value(B.Elem) then
                    Result |= Key_Of(B.Elem)
                end if
            end loop
        end loop
    end func "index_set"
      
    func "indexing"(ref M : Basic_Map; Key : KV_Type'Key_Type) {Key in M} 
            return ref KV_Type is
        -- Used for references to M[Key]; requires the Key to be in M.
        {M not null; M.Count > 0}
        const Index := Hash(Key) mod Length(M.Table) + 1
        -- Scan for Key in bucket
        for B => M.Table[Index] then B.Tail while B not null loop
            if B.Elem not null and then
              Key_Of(B.Elem) = Key then
                -- Found it.  Return reference to element of KV_Type
                {Has_Value(B.Elem)}
                return B.Elem
            end if
        end loop
        {#False}
    end func "indexing"
      
    func "var_indexing"(ref var M : Basic_Map; Key : KV_Type'Key_Type) 
            return ref var optional KV_Type is
        -- Used for assignments to M[Key]; Key is added to M if not present
        if M.Table not null then
            const Index := Hash(Key) mod Length(M.Table) + 1
            -- Scan for Key in bucket
            for B => M.Table[Index] then B.Tail while B not null loop
                if B.Elem not null and then
                  Key_Of(B.Elem) = Key then
                    -- Found it.  Return reference to element of KV_Type
                    return B.Elem
                end if
            end loop
        end if
      
        -- Not in table.  Add it, and then return reference
        if M.Table is null then
            M := Empty(Initial_Table_Size)
        elsif M.Count >= 2*Length(M.Table) then
            -- Expand table if averaging 2 or more per hash bucket
            Expand_Table(M)
        end if
      
        -- Add [Key => null] to front of appropriate bucket.
        const Index := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        Bucket := (Elem => Key_Only(Key), Tail <== Bucket)
        M.Count += 1
      
        -- Return ref to new element
        return Bucket.Elem
    end func "var_indexing"
      
    func Count(M : Basic_Map) return Univ_Integer is
              if M is null then
                  return 0
              else
                  return M.Count
              end if
    end func Count
      
    func Is_Empty(M : Basic_Map) return Boolean is
        -- Return True if map has no mappings
        return M.Count = 0
    end func Is_Empty
      
    func Remove_Any(var M : Basic_Map) return Result : optional KV_Type is
        if M.Count = 0 then
            -- Basic_Map is empty
            return null
        else
            -- Find a non-empty bucket and pull out an item.
            for each Bucket of M.Table loop
                if Bucket not null then
                    for B => Bucket then B.Tail while B not null loop 
                        if B.Elem not null then
                            -- Found an item, remove from Bucket and return
                            Result <== B.Elem
                            M.Count -= 1
                            return
                        end if
                    end loop
                    -- This bucket is completely empty, so might
                    -- as well empty it out.
                    Bucket := null
                end if
                -- Go on to the next bucket, this one's empty
            end loop
            -- Should never get here
            return null
        end if
    end func Remove_Any
      
    proc Dump_Statistics(M : Basic_Map) is
            -- A debugging routine to show bucket sizes of Basic_Map
        Println("Basic_Map statistics: Count = " & M.Count)
        if M.Table is null then
            Println(" Table is null")
        else
            Println(" Table of length " & Length(M.Table))
            for each [I => Bucket] of M.Table forward loop
                Print("  Bucket #" & I)
                if Bucket is null then
                    Println(" is null")
                else
                    var Len := 0
                    var Holes := 0
                    for B => Bucket then B.Tail while B not null loop
                        Len += 1
                        if B.Elem is null then
                            -- This list has a hole
                            Holes += 1
                        end if
                    end loop
                    if Holes > 0 then
                        Println(" of length " & Len & " with " & 
                          Holes & " holes")
                    else
                        Println(" of length " & Len)
                    end if
                end if
            end loop
        end if
    end proc Dump_Statistics
      
end package SSL.Containers.Basic_Map

proc SSL.Test.Test_Basic_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    subtype Enum_String_KV_Type is Key_Value<Univ_Enumeration, Univ_String>
    subtype Enum_String_Basic_Map is Basic_Map<Enum_String_KV_Type>

    var M : Enum_String_Basic_Map := [X => [X => Y], A => [A => B]]

    Println("Count = " & Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
        Println(K & " in M = " & (K in M))
    end loop

    Println("#xy in M = " & (#xy in M))

    M |= [X => null]

    Println("Count after deletion = " & Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " & Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " & Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    M -= A

    Println("Count after deletion = " & Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    var Ran := Random.Start(Hash(A))
    var MUI : Basic_Map<Key_Value<Univ_Integer, Univ_Integer>> := []

    Println("Adding 100 random KV_Typeings to Basic_Map.")
    for I in 1..100 loop
        const Key := Next(Ran) mod 100
        const Value := Next(Ran) mod 100
        MUI[Key] := [Key => Value]
    end loop
    Println("Basic_Map is now of count = " & Count(MUI))

    for each [K => KV] of MUI loop
        ref const V => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
        Println("MUI[" & K & "] = " & MUI[K].Value)
    end loop

    var I := 0
    for KV_Type in MUI loop
        I += 1
        Print(" [" & Key_Of(KV_Type) & " => " & KV_Type.Value & "]")
        if I mod 5 = 0 then
            Print('\n')
        end if
    end loop
    if I mod 5 /= 0 then
        Print('\n')
    end if

end proc SSL.Test.Test_Basic_Map

package body SSL.Containers.Set is
  -- A hashed-set module

  -- A Set is represented as a hash table, where each bucket is a linked list.
  -- When elements are deleted from the Set they end up a "null"s in the
  -- list.  We expand the table when the Count gets to be twice
  -- that of the length of the table.

    type KV_Wrapper is new Keyed<Element_Type> with record
            -- Create a wrapper for a key that implements the Keyed interface
        Key : Element_Type
    end record KV_Wrapper

    func Key_Of(ref const KV : KV_Wrapper) return ref const Element_Type
      is (KV.Key)
    func Has_Value(KV : KV_Wrapper) return Boolean is (#True)
        -- Return #True if KV_Wrapper object has a non-null value
    func Key_Only(Key : Element_Type) return KV_Wrapper is (Key => Key)
        -- Return a KV_Wrapper object given a key, 
        -- having no associated value
      
    type Set is record
        Data : Basic_Map<KV_Wrapper>
        -- Set is represented as a map from keys to nothing.
    end record Set;
      
  exports

    func "[]"() return Set is
        return (Data => [])
    end func "[]"
      
    func Singleton(Elem : Element_Type) return Result : Set is
        Result := []
        Result.Data |= (Key => Elem)
    end func Singleton
      
    func "|"(Left, Right : Element_Type) return Result : Set is
        Result := []
        Result.Data |= (Key => Left)
        Result.Data |= (Key => Right)
    end func "|"
      
    func "|"(Left : Set; Right : Element_Type) return Result : Set is
        Result := Left
        Result |= Right
    end func "|"
      
    func "|"(Left : Element_Type; Right : Set) return Result : Set is
        Result := Right
        Result |= Left
    end func "|"
      
    func "|"(Left : Set; Right : Set) return Result : Set is
        -- Union, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            Result := Right
            Result |= Left
        else
            Result := Left
            Result |= Right
        end if
    end func "|"
      
    proc "|="(var Left : Set; Right : Set) is
        if Count(Left.Data) = 0 then
            Left := Right
        else
            for Elem in Right loop
                Left |= Elem
            end loop
        end if
    end proc "|="
      
    proc "|="(var Left : Set; Right : Element_Type) is
        Left.Data |= (Key => Right)
    end proc "|="
      
    proc "<|="(var Left : Set; var Right : optional Element_Type) is
        -- Move Right into Set Left
        var KV : KV_Wrapper := (Key <== Right)
        Left.Data <|= KV
    end proc "<|="
      
    proc "<|="(var Left : Set; var Right : Set) is
        -- Move all elements of Right into Left, leaving Right empty.
        loop
            -- Extract element from Right, in region for Left
            var Elem for Left := Remove_Any(Right)
            if Elem is null then
                -- All done
                return
            end if
            -- Move element into Left
            Left <|= Elem
        end loop
    end proc "<|="
      
    func "in"(Left : Element_Type; Right : Set) return Boolean is
        return Left in Right.Data
    end func "in"
      
    func "=?"(Left, Right : Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
              var Overlaps := 0
              var Missing := 0
              for Elem in Left loop
                  if Elem not in Right then
                      Missing += 1
                  else
                      Overlaps += 1
                  end if
              end loop
      
              if Missing > 0 then
                  -- Can't be equal, but Left might be a proper superset
                  if Overlaps < Count(Right.Data) then
                      return #unordered
                  else
                      -- Left is a superset
                      return #greater
                  end if
              else
                  -- Might be equal or Left might be a proper subset
                  if Overlaps < Count(Right.Data) then
                      -- Left is a proper subset of Right
                      return #less
                  else
                      return #equal
                  end if
              end if
    end func "=?"
      
    func "and"(Left, Right : Set) return Result : Set is
        -- Intersection, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            -- Left is smaller
            Result := []
            for Elem in Left loop
                if Elem in Right then
                    Result |= Elem
                end if
            end loop
        else
            -- Left is bigger
            Result := Left
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
        end if
    end func "and"
      
    proc "and="(var Left : Set; Right : Set) is
        -- Intersection, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            -- Left is smaller
            for Elem in Left loop
                if Elem not in Right then
                    Left -= Elem
                end if
            end loop
        else
            -- Left is bigger
            var Result : Set for Left := []
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
            Left <== Result
        end if
    end proc "and="
      
    func "xor"(Left, Right : Set) return Result : Set is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        if Count(Left.Data) < Count(Right.Data) then
            -- Swap order to shorten iteration
            Result := Right
            Result xor= Left
        else
            Result := Left
            Result xor= Right
        end if
    end func "xor"
          
    proc "xor="(var Left : Set; Right : Set) is
        -- Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end proc "xor="
      
    func "-"(Left, Right : Set) return Result : Set is
        -- Set difference, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            -- Left is smaller, build up 
            Result := []
            for Elem in Left loop
                if Elem not in Right then
                    Result |= Elem
                end if
            end loop
        else
            -- Left is bigger, tear down
            Result := Left
            Result -= Right
        end if
    end func "-"
      
    proc "-="(var Left : Set; Right : Set) is
        -- Compute Set difference
        for Elem in Right loop
            Left -= Elem
        end loop
    end proc "-="
      
    proc "-="(var S : Set; Elem : Element_Type) is
            -- Remove the given element from the Set, if present
        S.Data -= Elem
    end proc "-="
         
    func Count(S : Set) return Univ_Integer is
        return Count(S.Data)
    end func Count
      
    func Is_Empty(S : Set) return Boolean is
        return Is_Empty(S.Data)
    end func Is_Empty
      
    func Remove_Any(var S : Set) return Result : optional Element_Type is
        var Result_Wrapper for Result := Remove_Any(S.Data)
        if Result_Wrapper is null then
            return null
        else
            Result <== Result_Wrapper.Key
        end if
    end func Remove_Any
      
    proc Dump_Statistics(S : Set) is
            -- A debugging routine to show bucket sizes of Set
        Dump_Statistics(S.Data)
    end proc Dump_Statistics
      
end package SSL.Containers.Set

proc SSL.Test.Test_Set(A, X, Y, Z : Univ_Integer) is
    var S : Set<Univ_Integer> := X | Y | Z
    if A in S then
        Println(A & " is in " & X & "|" & Y & "|" & Z)
    else
        Println(A & " is *not* in " & X & "|" & Y & "|" & Z)
    end if

    const Save_Set := S

    const CSet : Set<Univ_Integer> := [Z, Y, X]
    Println("[Z, Y, X] =? (X | Y | Z) --> " &
      ( CSet =? S ))

    var Ran := Random.Start(A)
    Println("Adding 100 random digits to Set.")
    for I in 1..100 loop
        S |= Next(Ran) mod 100
    end loop
    Println("Set is now of count = " & Count(S))
    Println("Contents of Set:")
    var I := 1
    for Elem in S loop
        Print(Elem & " ")
        if I mod 10 = 0 then
            Print('\n')
        end if
        I += 1
    end loop
    if Count(S) mod 10 /= 0 then
        Print('\n')
    end if
    Println("S Before adding random elements =? now --> " &
      (Save_Set =? S))
    Println("S =? S --> " & (S =? S))

    var Small_Set : Set<Univ_Integer> := []
    Small_Set += -1
    Small_Set or= [2]

    Println("S =? (-1 | 2) --> " & (S =? Small_Set))
    Println("[2 , -1] =? (-1 | 2) --> " & ([2, -1] =? Small_Set))

    Println("S =? [] --> " & (S =? []))

    Println("Count(S) = " & Count(S))
    
    const Before_Exclude := S
    S -= X
    Println("After Exclude(S, " & X & "), Count(S) = " & Count(S))
    Println("Before_Exclude =? After Exclude --> " & (Before_Exclude =? S))

    Dump_Statistics(S)
end proc SSL.Test.Test_Set

generic
    Literals : Vector<Univ_Enumeration>
package SSL.Core.Enum is
    type Enum is private;

    func "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit = Univ)}
      return Enum
    func "to_univ"(Val : optional Enum)
      return Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit = Result)}

    func "=?"(Left, Right : Enum) return Ordering
      is import("=?")

    -- Functions for Imageable
    func Image(Val : Enum) return Univ_String
    func Value(Str : Univ_String) return optional Enum

    -- Operators for Countable
    func "+"(Left : Univ_Integer; Right : Enum) return Enum 
      is import("+")
    func "+"(Left : Enum; Right : Univ_Integer) return Enum 
      is import("+")
    func "-"(Left, Right : Enum) return Univ_Integer 
      is import("-")
    func "-"(Left : Enum; Right : Univ_Integer) return Enum 
      is import("-")

    -- TBD: These should be properties some day (e.g. Color#first).
    func First() return Enum
    func Last() return Enum
    func Range() return Countable_Range<Enum> is "[..]" of Countable_Range<Enum>

    func "[..]"() return Countable_Range<Enum> is of Countable_Range<Enum>

    func Hash(Val : Enum) return Univ_Integer
      is import(#identity)

    func ".."(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    func "<.."(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    func "..<"(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    func "<..<"(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    func "|"(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>

    func Min(Left, Right : optional Enum) return optional Enum
      is import(#min)
    func Max(Left, Right : optional Enum) return optional Enum
      is import(#max)
end package SSL.Core.Enum

package body SSL.Core.Enum is
    type Enum is record
        const Value : Univ_Integer
    end record;
  exports
    func "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit = Univ)}
      return Enum is
        for I in 1 .. |Literals| loop
            if Literals[I] = Univ then
                return (Value => I-1)
            end if
        end loop
        {#False}
    end func "from_univ"

    func "to_univ"(Val : optional Enum)
      return Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit = Result)} is
        if Val is null then
            return null
        else
            return Literals[Val.Value+1]
        end if
    end func "to_univ"

    -- Functions for Imageable
    func Image(Val : Enum) return Univ_String is
        return Univ_Enumeration'Image([[Val]])
    end func Image

    func Value(Str : Univ_String) return optional Enum is
        return Univ_Enumeration'Value(Str)
    end func Value

    func First() return Enum is
        return (Value => 0)
    end func First

    func Last() return Enum is
        return (Value => |Literals| - 1)
    end func Last

end package SSL.Core.Enum

proc SSL.Test.Test_Enum() is
    subtype Color is Enum<[#red, #green, #blue]>
    subtype Day_Of_Week is Enum<[#Monday, #Tuesday, #Wednesday, #Thursday, 
        #Friday, #Saturday, #Sunday]>

    for C : Color in Color.First() .. Color.Last() forward loop
        Println("Next color = " & C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " & C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " & D3)
    end loop

    {#Monday in Day_Of_Week}

end proc SSL.Test.Test_Enum

generic
    type Key_Type is new Hashable;
    type Value_Type is new Assignable
package SSL.Containers.Map is
        -- A hashed-map module
    type Map is private

    subtype Pair is Key_Value<Key_Type, Value_Type>

    func "[]"() return Map

    proc "|="(var Left : Map; Right : Pair)
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any.

    func "|"(Left : Map; Right : Pair) return Map
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any in result.

    proc "<|="(var Left : Map; var Right : optional Pair)
        -- Move Key/Value pair into map, leaving Right null

    proc "<|="(var Left : Map; var Right : Map)
        -- Move key/value pairs from Right into Left, leaving Right empty,
        -- replacing any pre-existing entries with the same key.

    proc "+="(var Left : Map; Right : Pair) is "|="
        -- A synonym for adding a key=>value pair

    func "in"(Left : Key_Type; Right : Map) return Boolean
        -- Return True if given key has a mapping in the Map

    proc "-="(var M : Map; Key : Key_Type)   -- aka Exclude
        -- Remove mapping for Right, if present

    func "index_set"(M : Map) return Set<Key_Type>
        -- Return set of keys with mappings

    func Keys(M : Map) return Set<Key_Type> is "index_set"

    func "indexing"(ref M : Map; Key : Key_Type) {Key in M}
      return ref Value_Type
        -- Used for references to M[Key]; requires the Key to be in M.

    func "var_indexing"(ref var M : Map; Key : Key_Type) 
            return ref var optional Value_Type
        -- Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Map) return optional Pair
        -- Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Map) return Univ_Integer
        -- Number of mappings in the table

    func "magnitude"(Map) return Univ_Integer is Count

    func Is_Empty(M : Map) return Boolean
        -- Return True if no mappings in the table

    proc Dump_Statistics(M : Map)
            -- A debugging routine to show bucket sizes of Map

end package SSL.Containers.Map

package body SSL.Containers.Map is
        -- A hashed-map module
    type Map is record
        Data : Basic_Map<Key_Value<Key_Type, Value_Type>>
    end record;

  exports
    func "[]"() return Map is
              return (Data => [])
    end func "[]"

    func "|"(Left : Map; Right : Pair) return Result : Map is
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any in result.
              Result := Left
              Result.Data |= Right
    end func "|"

    proc "|="(var Left : Map; Right : Pair) is
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any.
        Left.Data |= Right
    end proc "|="

    proc "<|="(var Left : Map; var Right : optional Pair) is
        -- Move Key/Value pair into map, leaving Right null
        Left.Data <|= Right
    end proc "<|="

    proc "<|="(var Left : Map; var Right : Map) is
        -- Move key/value pairs from Right into Left, leaving Right empty,
        -- replacing any pre-existing entries with the same key.
        loop
            var Right_Elem for Left := Remove_Any(Right)
            if Right_Elem is null then
                return   -- All done
            end if

            Left.Data <|= Right_Elem
        end loop
    end proc "<|="

    func "in"(Left : Key_Type; Right : Map) return Boolean is
        return Left in Right.Data
    end func "in"

    proc "-="(var M : Map; Key : Key_Type) is
            -- Remove the given key from the Map, if present
        M.Data -= Key
    end proc "-="
         
    func "index_set"(M : Map) return Result : Set<Key_Type> is
        -- Return set of keys with non-null mappings
              if M.Data is null then
                  return []
              else
                 return "index_set"(M.Data)
              end if
    end func "index_set"

    func "indexing"(ref M : Map; Key : Key_Type) {Key in M} return ref Value_Type is
        -- Used for references to M[Key]; requires the Key to be in M.
        return M.Data[Key].Value
    end func "indexing"

    func "var_indexing"(ref var M : Map; Key : Key_Type) 
            return ref var optional Value_Type is
        -- Used for assignments to M[Key]; Key is added to M if not present
        return "var_indexing"(M.Data, Key).Value
    end func "var_indexing"

    func Count(M : Map) return Univ_Integer is
        return Count(M.Data)
    end func Count

    func Is_Empty(M : Map) return Boolean is
        -- Return True if no mappings in the table
        return Is_Empty(M.Data)
    end func Is_Empty

    func Remove_Any(var M : Map) return Result : optional Pair is
        return Remove_Any(M.Data)
    end func Remove_Any

    proc Dump_Statistics(M : Map) is
            -- A debugging routine to show bucket sizes of Map
        Dump_Statistics(M.Data)
    end proc Dump_Statistics

end package SSL.Containers.Map

proc SSL.Test.Test_Map(X : Univ_Enumeration; Y : Univ_String;
        A : Univ_Enumeration; B : Univ_String) is
    subtype Enum_String_Map is Map<Univ_Enumeration, Univ_String>

    var M : Enum_String_Map := [X => Y, A => B]

    Println("Count = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
        Println(K & " in M = " & (K in M))
    end loop

    Println("#xy in M = " & (#xy in M))

    M |= [X => null]

    Println("Count after deletion = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    M -= A

    Println("Count after deletion = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    var Ran := Random.Start(Hash(A))
    var MUI : Map<Univ_Integer, Univ_Integer> := []

    Println("Adding 100 random pairings to Map.")
    for I in 1..100 loop
        const Key := Next(Ran) mod 100
        const Value := Next(Ran) mod 100
        MUI[Key] := Value
    end loop
    Println("Map is now of count = " & Count(MUI))

    for each [K => V] of MUI loop
        Println("Mapping " & K & " => " & V)
        Println("MUI[" & K & "] = " & MUI[K])
    end loop

    for (Pair in MUI; I in 1..60 forward) loop
        Print(" [" & Pair.Key & " => " & Pair.Value & "]")
        if I mod 5 = 0 then
            Print('\n')
        end if
    end loop

    if Count(MUI) > 60 then
        Println(" ...")
    elsif Count(MUI) mod 5 /= 0 then
        Print('\n')
    end if

end proc SSL.Test.Test_Map

generic
    type Element_Type is new Comparable
package SSL.Containers.Ordered_Set is
  -- A set abstraction that supports efficiently storing potentially
  -- large ranges of values
    type Ordered_Set is private

    func "[]"() return Ordered_Set

    func Singleton(Elem : Element_Type) return Ordered_Set
        -- Return a set consisting of a single element

    func ".."(Left, Right : Element_Type) return Ordered_Set
        -- Closed interval of values
    func "<.."(Left, Right : Element_Type) return Ordered_Set
        -- Open-Closed interval of values
    func "..<"(Left, Right : Element_Type) return Ordered_Set
        -- Closed-Open interval of values
    func "<..<"(Left, Right : Element_Type) return Ordered_Set
        -- Open interval of values

    func "|"(Left, Right : Element_Type) return Ordered_Set
    func "|"(Left : Ordered_Set; Right : Element_Type) return Ordered_Set
    func "|"(Left : Element_Type; Right : Ordered_Set) return Ordered_Set
    func "|"(Left : Ordered_Set; Right : Ordered_Set) return Ordered_Set

    proc "|="(var Left : Ordered_Set; Right : Element_Type)
    proc "|="(var Left : Ordered_Set; Right : Ordered_Set)

    proc "<|="(var Left : Ordered_Set; var Right : optional Element_Type)
              -- Move element into set, leaving Right null afterward.

    proc "<|="(var Left : Ordered_Set; var Right : Ordered_Set)
        -- Move all elements of Right into Left, leaving Right empty.

    func "-"(Left, Right : Ordered_Set) return Ordered_Set
            -- Set difference
    proc "-="(var S : Ordered_Set; Elem : Element_Type)
            -- Remove the given element from the set, if present
    proc "-="(var Left : Ordered_Set; Right : Ordered_Set)
            -- Remove all elements of Right from Left, if present

    func "or"(Left : Ordered_Set; Right : Ordered_Set) 
            return Ordered_Set is "|"   -- union
    proc "or="(var Left : Ordered_Set; Right : Ordered_Set) is "|="

    func "+"(Left : Ordered_Set; Right : Ordered_Set) 
            return Ordered_Set is "|"   -- Union
    proc "+="(var Left : Ordered_Set; Right : Ordered_Set) is "|="
    proc "+="(var Left : Ordered_Set; Right : Element_Type) is "|="
         
    func "and"(Left, Right : Ordered_Set) return Ordered_Set
        -- Intersection
    proc "and="(var Left : Ordered_Set; Right : Ordered_Set)

    func "xor"(Left, Right : Ordered_Set) return Ordered_Set
        -- Symmetric difference
    proc "xor="(var Left : Ordered_Set; Right : Ordered_Set)

    func "in"(Left : Element_Type; Right : Ordered_Set) return Boolean

    func "=?"(Left, Right : Ordered_Set) return Ordering
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise

    func Is_Empty(S : Ordered_Set) return Boolean

    func Lower_Bound(S : Ordered_Set) return optional Element_Type
        -- Lower bound of set
    func Lower_Bound_Is_Open(S : Ordered_Set) return Boolean
        -- Whether lower bound is "open" or "closed"

    func Upper_Bound(S : Ordered_Set) return optional Element_Type
        -- Upper bound of set
    func Upper_Bound_Is_Open(S : Ordered_Set) return Boolean
        -- Whether upper bound is "open" or "closed"

    func Remove_First(var S : Ordered_Set)
      return optional Interval<Element_Type>
        -- Remove first interval of set (lowest low bound)

    func Remove_Last(var S : Ordered_Set) return optional Interval<Element_Type>
        -- Remove last interval of set (highest high bound)

    func Remove_Any(var S : Ordered_Set) return optional Interval<Element_Type>
        -- Remove an arbitrary interval of set

end package SSL.Containers.Ordered_Set

package body SSL.Containers.Ordered_Set is

    subtype Element_Interval is Interval<Element_Type>

    type Ordered_Set is record
        Items : optional AA_Tree<Element_Interval>
    end record Ordered_Set

    proc Remove_Interval(var S : Ordered_Set; Remove_IV : Element_Interval) is
      -- Remove the given interval from the set, if present
        if Remove_IV.Low > Remove_IV.High then
            -- Nothing to remove
            return
        end if

          -- Find an interval within the AA_Tree that overlaps
        for Remaining_IV := Remove_IV while Remaining_IV not null loop
            -- Get overlap, if any
            var IV := Overlapping(S.Items, Remaining_IV)

            if IV is null then
                -- No overlap, nothing left to remove
                exit loop
            end if
        
            -- Found an overlapping interval; delete it and add back what's left
            Delete(S.Items, IV)
            if Is_Strictly_Within(Remaining_IV, IV) then
                -- Add back left and right remnants
                -- Remaining_IV is fully subsumed.
                S.Items |= (Low => IV.Low, Low_Is_Open => IV.Low_Is_Open, 
                  High => Remaining_IV.Low, 
                  High_Is_Open => not Remaining_IV.Low_Is_Open)
                S.Items |= (Low => Remaining_IV.High, 
                  Low_Is_Open => not Remaining_IV.High_Is_Open,
                  High => IV.High, 
                  High_Is_Open => IV.High_Is_Open)
                -- we are all done now
                exit loop
            end if

            -- May be something left
            const Overlap := IV and Remaining_IV
            IV -= Overlap

            if not Is_Empty(IV) then
                -- Worth putting the interval back
                S.Items |= IV
            end if

            continue loop with Remaining_IV => Remaining_IV - Overlap

        end loop

    end proc Remove_Interval

    func Is_Subset(Left, Right : Ordered_Set) return Boolean is
        -- Return True if Left is a subset of Right
        for Left_IV in Left loop
            for Remaining_IV := Left_IV while not Is_Empty(Remaining_IV) loop
                const Right_IV := Overlapping(Right.Items, Remaining_IV)
                if Right_IV is null then
                    -- Found some values that are not in Right
                    return #False
                end if

                -- Loop around with what is left
                continue loop with Remaining_IV => Remaining_IV - Right_IV
            end loop
        end loop
        -- Everything in Left was found in Right
        return #True
    end func Is_Subset

  exports
    func "[]"() return Ordered_Set is
              return (Items => [])
    end func "[]"

    func Singleton(Elem : Element_Type) return Result : Ordered_Set is
        -- Return a set consisting of a single element
        Result := []
        Result.Items |= Singleton(Elem)
    end func Singleton

    func ".."(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, Low_Is_Open => #False, 
              High => Right, High_Is_Open => #False)
        end if
    end func ".."
          
    func "<.."(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #True,
              High => Right, High_Is_Open => #False)
        end if
    end func "<.."
          
    func "<..<"(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #True,
              High => Right, High_Is_Open => #True)
        end if
    end func "<..<"
          
    func "..<"(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #False,
              High => Right, High_Is_Open => #True)
        end if
    end func "..<"
          
    func "|"(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        Result |= Left
        if Left /= Right then
            Result |= Right
        end if
    end func "|"

    func "|"(Left : Ordered_Set; Right : Element_Type) 
      return Result : Ordered_Set is
        Result := Left
        Result |= Right
    end func "|"

    func "|"(Left : Element_Type; Right : Ordered_Set) return Ordered_Set is
              return Right | Left
    end func "|"

    func "|"(Left : Ordered_Set; Right : Ordered_Set) 
      return Result : Ordered_Set is
        Result := Left
        Result |= Right
    end func "|"

    proc "|="(var Left : Ordered_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := Singleton(Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            -- Nothing overlaps, need to add it
            --  (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end proc "|="

    proc "<|="(var Left : Ordered_Set; var Right : optional Element_Type) is
              -- Move element into set, leaving Right null afterward.
        -- TBD: No copy minimization done at the moment
        Left |= Right
        Right := null
    end proc "<|="

    proc "|="(var Left : Ordered_Set; Right : Ordered_Set) is
        if Count(Left.Items) = 0 then
            Left := Right
        else
            -- Make a copy of the Right set
            var Right_Copy for Left := Right

            -- Merge all of its intervals into Left
            Left <|= Right_Copy
        end if
    end proc "|="

    proc "<|="(var Left : Ordered_Set; var Right : Ordered_Set) is
        -- Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) = 0 then
            Left.Items <== Right.Items
        else
            -- Iterate through the tree
            loop
                -- Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)
                if Right_IV is null then
                    return
                end if

                -- See whether it overlaps with an existing interval
                -- in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    -- Incorporate left interval into Right_IV
                    Right_IV |= Left_IV

                    if Right_IV = Left_IV then
                        -- Right_IV fully subsumed by existing interval
                        Right_IV := null
                        exit loop
                    end if

                    -- Need to delete Left_IV 
                    Delete(Left.Items, Left_IV)

                    -- Now see if there is anything still overlapping
                    Left_IV := Overlapping(Left.Items, Right_IV)
                end loop

                if not Is_Empty(Right_IV) then
                    -- Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end proc "<|="

    func "-"(Left, Right : Ordered_Set) return Result : Ordered_Set is
      -- Set difference
        Result := Left
        Result -= Right
    end func "-"

    proc "-="(var S : Ordered_Set; Elem : Element_Type) is
      -- Remove the given element from the set, if present
        Remove_Interval(S, Singleton(Elem))
    end proc "-="

    proc "-="(var Left : Ordered_Set; Right : Ordered_Set) is
      -- Remove all intervals of Right from Left, if present
        for IV in Right loop
            Remove_Interval(Left, IV)
        end loop
    end proc "-="

    func "and"(Left, Right : Ordered_Set) return Result : Ordered_Set is
        -- Intersection

        -- Add elements that are in both Right and Left into result
        Result := []
        for Right_IV in Right loop
            for Remaining_IV := Right_IV while Remaining_IV not null loop
                var Left_IV := Overlapping(Left.Items, Remaining_IV)

                if Left_IV is null then
                    exit loop
                end if

                -- Compute overlap, add into result, and then loop
                -- around after removing it from Remaining_IV
                const Overlap := Remaining_IV and Left_IV

                Result.Items |= Overlap

                continue loop with Remaining_IV => Remaining_IV - Overlap
            end loop
        end loop
    end func "and"

    proc "and="(var Left : Ordered_Set; Right : Ordered_Set) is
        -- Intersection
        Left := Left and Right
    end proc "and="

    func "xor"(Left, Right : Ordered_Set) return Ordered_Set is
        -- Symmetric difference

        return (Left - Right) or (Right - Left)
    end func "xor"

    proc "xor="(var Left : Ordered_Set; Right : Ordered_Set) is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        const Only_In_Right := Right - Left
        Left -= Right
        Left += Only_In_Right
    end proc "xor="

    func "in"(Left : Element_Type; Right : Ordered_Set) return Boolean is
        return Overlapping(Right.Items, Singleton(Left)) not null
    end func "in"

    func "=?"(Left, Right : Ordered_Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
        if Is_Subset(Left, Right) then
            if Is_Subset(Right, Left) then
                return #equal
            else
                return #less
            end if
        elsif Is_Subset(Right, Left) then
            return #greater
        else
            return #unordered
        end if
    end func "=?"

    func Is_Empty(S : Ordered_Set) return Boolean is
        -- Return count of items in set
        return Count(S.Items) = 0
    end func Is_Empty

    func Lower_Bound(S : Ordered_Set) return optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end func Lower_Bound

    func Lower_Bound_Is_Open(S : Ordered_Set) return Boolean is
        const First_IV := First(S.Items)
        if First_IV is null then
            return #True   -- TBD: or null?
        else
            return First_IV.Low_Is_Open
        end if
    end func Lower_Bound_Is_Open

    func Upper_Bound(S : Ordered_Set) return optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end func Upper_Bound

    func Upper_Bound_Is_Open(S : Ordered_Set) return Boolean is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return #True   -- TBD: or null?
        else
            return Last_IV.High_Is_Open
        end if
    end func Upper_Bound_Is_Open

    func Remove_First(var S : Ordered_Set) 
      return optional Interval<Element_Type> is
        -- Remove first interval of set (lowest low bound)
        return Remove_First(S.Items)
    end func Remove_First

    func Remove_Last(var S : Ordered_Set) 
      return optional Interval<Element_Type> is
        -- Remove last interval of set (highest high bound)
        return Remove_Last(S.Items)
    end func Remove_Last

    func Remove_Any(var S : Ordered_Set) 
      return optional Interval<Element_Type> is
        -- Remove an arbitrary interval of set
        return Remove_Any(S.Items)
    end func Remove_Any

end package SSL.Containers.Ordered_Set

proc SSL.Test.Test_Ordered_Set(A, X, Y, Z : Univ_Real) is
    var S : Ordered_Set<Univ_Real> := X | Y..Z
    Println(A & " in " & X & "|" & Y & ".." & Z & "=" & ( A in S ))

    const Agg : Ordered_Set<Univ_Real> := [X, Y, Z]
    const Or : Ordered_Set<Univ_Real> := Y | Z | X
    const Open_Ind : Map<Boolean, Univ_String> := [#False => "", #True => "<"]

    Println(" [X, Y, Z] =? (Y | Z | X) --> " & ( Agg =? Or ))

    S := []

    var R := 0.0
    for I in 1..10 forward loop
        R += 1.0
        S += R
        Println("Adding " & R & " to S, Is_Empty(S) = " & Is_Empty(S))
    end loop

    var Xor := S xor [2.0, 5.0, 12.0, 15.0]
    Print("S xor [2.0, 5.0, 12.0, 15.0] = ")
    for IV in Xor forward loop
        if IV.Low /= IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] & ".." & 
              Open_Ind[IV.High_Is_Open] | IV.High & " ")
        else
            Print(IV.Low & " ")
        end if
    end loop
    Print('\n')
end proc SSL.Test.Test_Ordered_Set

package SSL.Core.Univ_Real is
    type Univ_Real is private

    func "+"(Right : Univ_Real) return Univ_Real
      is import(#identity)

    func "-"(Right : Univ_Real) return Univ_Real
      is import(#real_negate)

    func "abs"(Right : Univ_Real) return Univ_Real
      is import(#real_abs)

    func "magnitude"(Univ_Real) return Univ_Real is "abs"

    func "+"(Left, Right : Univ_Real) return Result : Univ_Real 
      is import(#real_add)

    func "-"(Left, Right : Univ_Real) return Result : Univ_Real
      is import(#real_subtract)

    func "*"(Left, Right : Univ_Real) return Result : Univ_Real 
      is import(#real_multiply)

    func "*"(Left : Univ_Real; Right : Univ_Integer) return Univ_Real
      is import(#real_int_multiply)

    func "*"(Left : Univ_Integer; Right : Univ_Real) return Univ_Real

    func "/"(Left, Right : Univ_Real) return Result : Univ_Real
      is import(#real_divide)

    func "/"(Left : Univ_Real; Right : Univ_Integer) return Univ_Real
      is import(#real_int_divide)

    func "**"(Left : Univ_Real; Right : Univ_Integer) return Univ_Real
      is import(#real_exp)

    proc "+="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_add)

    proc "-="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_subtract)

    proc "*="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_multiply)

    proc "/="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_divide)

    proc "**="(var Left : Univ_Real; Right : Univ_Integer) 
      is import(#real_assign_exp)


    func "=?"(Left, Right : Univ_Real) return Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Univ_Real) return optional Univ_Real
      is import(#real_min)
    func Max(Left, Right : optional Univ_Real) return optional Univ_Real
      is import(#real_max)

    func Sqrt(Val : Univ_Real {Val >= 0.0}) return Univ_Real

    func Hash(Val : Univ_Real) return Univ_Integer
      is import(#identity)

    proc Print(X : Univ_Real) is import(#print_real)

    proc Put(X : Univ_Real) is Print

    func Image(Val : Univ_Real) return Univ_String
      is import(#to_string_real)

    func Value(Str : Univ_String) return optional Univ_Real
      is import(#from_string_real)

    func Round_To_Int(Real : Univ_Real) return Univ_Integer
      is import(#round_to_int)

    func Int_To_Real(Int : Univ_Integer) return Univ_Real
      is import(#int_to_real)

    func "in"(Left : Univ_Real; Right : Ordered_Set<Univ_Real>) return Boolean
      is of Ordered_Set<Univ_Real>

end package SSL.Core.Univ_Real

package body SSL.Core.Univ_Real is
  exports
    func "*"(Left : Univ_Integer; Right : Univ_Real) return Univ_Real is
        -- Hand off to built-in real * int func
        return Right * Left
    end func "*"

    func Sqrt(Val : Univ_Real {Val >= 0.0}) return Result : Univ_Real is
        {Val >= 0.0}
        Result := Val / 2.0
        while Result > 0.0 and then Result * Result / Val 
          not in 0.9999999999999 .. 1.00000000000001 loop
            Result := (Val / Result + Result)/2.0
        end loop
    end func Sqrt

end package SSL.Core.Univ_Real
    
proc SSL.Test.Test_Real() is
    var X := 3.5
    var Y := 5.22
    var Z := X + Y

    Println("X = " & X & ", Y = " & Y & ", X + Y = " & Z)
    var Teeny := 0.000023
    Println("Teeny = " & Teeny)
    var Small := 0.005
    Println("Small = " & Small)
    var Medium := 235.123
    Println("Medium = " & Medium)
    var Big := 11.0**5
    Println("Big = " & Big)
    var Huge := 13.0**15
    Println("Huge = " & Huge)

    Println("Y in 1.0 .. 6.0 = " & ( Y in 1.0 .. 6.0 ))
    
    Println("Y in 1.0 ..< 5.22 = " & ( Y in 1.0 ..< 5.22 ))

    Println("Sqrt(2.0) = " & Sqrt(2.0))

    var Neg := -2.0;
    Println("Sqrt(-2.0) = " & Sqrt(Neg))
end proc SSL.Test.Test_Real

generic
    Digits : Univ_Integer := 15
package SSL.Core.Float is
        -- A floating point type that provides at least the
        -- given number of digits of precision.
    type Float is private

    func "from_univ"(Univ : Univ_Real) return Float
            is import(#identity)

    func "to_univ"(Val : Float) return Univ_Real
            is import(#identity)

    func "+"(Right : Float) return Float
            is import(#identity)

    func "-"(Right : Float) return Float
            is import(#real_negate)

    func "abs"(Right : Float) return Float
            is import(#real_abs)

    func "magnitude"(Float) return Float is "abs"

    func "+"(Left, Right : Float) return Result : Float 
            is import(#real_add)

    func "-"(Left, Right : Float) return Result : Float
            is import(#real_subtract)

    func "*"(Left, Right : Float) return Result : Float 
            is import(#real_multiply)

    func "*"(Left : Float; Right : Univ_Integer) return Result : Float 
            is import(#real_int_multiply)

    func "*"(Left : Univ_Integer; Right : Float) return Result : Float

    func "/"(Left, Right : Float) return Result : Float
            is import(#real_divide)

    func "/"(Left : Float; Right : Univ_Integer) return Result : Float
            is import(#real_int_divide)

    func "**"(Left : Float; Right : Univ_Integer) return Float
            is import(#real_exp)

    proc "+="(var Left : Float; Right : Float) 
            is import(#real_assign_add)

    proc "-="(var Left : Float; Right : Float) 
            is import(#real_assign_subtract)

    proc "*="(var Left : Float; Right : Float) 
            is import(#real_assign_multiply)

    proc "/="(var Left : Float; Right : Float) 
            is import(#real_assign_divide)

    proc "**="(var Left : Float; Right : Univ_Integer) 
            is import(#real_assign_exp)


    func "=?"(Left, Right : Float) return Ordering
            is import(#real_compare)

    func Min(Left, Right : optional Float) return optional Float
            is import(#real_min)
    func Max(Left, Right : optional Float) return optional Float
            is import(#real_max)

    func Hash(Val : Float) return Univ_Integer
            is import(#identity)

    func Round_To_Int(Val : Float) return Univ_Integer
            is import(#round_to_int)

    func Int_To_Float(Int : Univ_Integer) return Float
            is import(#int_to_real)

    proc Print(X : Float) is import(#print_real)

    proc Put(X : Float) is Print

    func Image(Val : Float) return Univ_String
            is import(#to_string_real)

    func Value(Str : Univ_String) return optional Float
            is import(#from_string_real)

    func "in"(Left : Float; Right : Ordered_Set<Float>) return Boolean
            is of Ordered_Set<Float>
        -- "in" defined in Ordered_Set

          
end package SSL.Core.Float

package body SSL.Core.Float is
    type Float is record
        const Value : Univ_Real
    end record;
  exports
    func "*"(Left : Univ_Integer; Right : Float) return Result : Float is
        -- Hand off to built-in real*int func
        return Right * Left
    end func "*"
end package SSL.Core.Float
          
proc SSL.Test.Test_Float() is
    subtype My_Float is Float<Digits => 8>

    var X : My_Float := 3.5
    var Y : My_Float := 5.22
    var Z : My_Float := X + Y

    Println("X = " & X & ", Y = " & Y & ", X + Y = " & Z)
    var Teeny := 0.000023
    Println("Teeny = " & Teeny)
    var Small := 0.005
    Println("Small = " & Small)
    var Medium := 235.123
    Println("Medium = " & Medium)
    var Big := 11.0**5
    Println("Big = " & Big)
    var Huge := 13.0**15
    Println("Huge = " & Huge)

    var X2 : My_Float := 3.5 * 2

    Println("X * 2 = " & X * 2 & ", 2 * X = " & 2 * X & ", X2 = " & X2)
    Println("X / 2 = " & X / 2 )

    if X in 1.5 ..< 3.6 then
        Println("X *is* in 1.5 ..< 3.6")
    else
        Println("X *not* in 1.5 ..< 3.6??")
    end if

    Println("X in 1.5 ..< 3.5 = " & (X in 1.5 ..< 3.5) )
end proc SSL.Test.Test_Float

generic
    Delta : Univ_Real
package SSL.Core.Fixed is
  -- Fixed point types, represented as an integer
  -- multiple of the given Delta
    type Fixed is private

    func "from_univ"(Univ : Univ_Real) return Fixed
    func "to_univ"(Val : optional Fixed) return optional Univ_Real

    func "+"(Right : Fixed) return Fixed
            is import(#identity)

    func "-"(Right : Fixed) return Fixed
            is import(#negate)

    func "abs"(Right : Fixed) return Fixed
            is import("abs")

    func "magnitude"(Fixed) return Fixed is "abs"

    func "+"(Left, Right : Fixed) return Fixed
            is import("+")
    func "-"(Left, Right : Fixed) return Fixed
            is import("-")
    func "*"(Left : Fixed; Right : Univ_Real) return Fixed
            is import(#fixed_real_mul)
    func "*"(Left : Univ_Real; Right : Fixed) return Fixed
            is import(#real_fixed_mul)
    func "*"(Left : Fixed; Right : Univ_Integer) return Fixed
            is import("*")
    func "*"(Left : Univ_Integer; Right : Fixed) return Fixed
            is import("*")
    func "/"(Left : Fixed; Right : Univ_Real) return Fixed
            is import(#fixed_real_div)
    func "/"(Left : Fixed; Right : Univ_Integer) return Fixed
            is import("/")

    proc "+="(var Left : Fixed; Right : Fixed) 
            is import("+=")

    proc "-="(var Left : Fixed; Right : Fixed) 
            is import("-=")

    proc "*="(var Left : Fixed; Right : Fixed) 
            is import("*=")

    proc "/="(var Left : Fixed; Right : Univ_Integer) 
            is import("/=")

    proc "/="(var Left : Fixed; Right : Univ_Real)

    func "=?"(Left, Right : Fixed) return Ordering
            is import("=?")

    func Min(Left, Right : optional Fixed) return optional Fixed
            is import(#min)
    func Max(Left, Right : optional Fixed) return optional Fixed
            is import(#max)

    func Hash(Val : Fixed) return Univ_Integer
            is import(#identity)

    func Round_To_Int(Val : Fixed) return Univ_Integer

    proc Print(X : Fixed)

    proc Put(X : Fixed) is Print

    func Image(Val : Fixed) return Univ_String

    func Value(Str : Univ_String) return optional Fixed

    func "in"(Left : Fixed; Right : Ordered_Set<Fixed>) 
            return Boolean is of Ordered_Set<Fixed>
          
end package SSL.Core.Fixed

package body SSL.Core.Fixed is
    type Fixed is record
        const Value : Univ_Integer
    end record;

  exports
    func "from_univ"(Univ : Univ_Real) return Fixed is
        return (Value => Univ_Real.Round_To_Int(Univ/Delta))
    end func "from_univ"

    func "to_univ"(Val : optional Fixed) return optional Univ_Real is
        if Val is null then
            return null
        else
            return Delta * Int_To_Real(Val.Value)
        end if
    end func "to_univ"

    proc "/="(var Left : Fixed; Right : Univ_Real) is
        Left := Left / Right
    end proc "/="

    proc Print(X : Fixed) is
        var Val : Univ_Real := [[X]]
        Print(Val)
    end proc Print

    func Image(Val : Fixed) return Univ_String is
        return Univ_Real'Image([[Val]])
    end func Image

    func Value(Str : Univ_String) return optional Fixed is
        return Univ_Real'Value(Str)
    end func Value

    func Round_To_Int(Val : Fixed) return Univ_Integer is
        return Univ_Real.Round_To_Int([[Val]])
    end func Round_To_Int

end package SSL.Core.Fixed

proc SSL.Test.Test_Fixed(X : Univ_Real) is
    subtype My_Fixed is Fixed<Delta => 1.0E-6>

    var XTI : My_Fixed := X
    const Minute : My_Fixed := 60.0
    Println("X = " & XTI)
    Println("X * 2 = " & (XTI*2))
    Println("X + X = " & (XTI + XTI))
    Println("X - X = " & (XTI - XTI))
    Println("X / 2 = " & (XTI / 2))
    Println("X / 2.0 = " & (XTI / 2.0))
    Println("X * 3.0 = " & (XTI * 3.0))
    Println("5.0 * X = " & (5.0 * XTI))
    Println("-5.0 * X = " & (-5.0 * XTI))
    Println("-5.0 = " & -5.0)
    Println("Minute = " & Minute)
    Println("-5.0*Minute = " & -5.0*Minute)

    Println("Round_To_Int(X) = " & Round_To_Int(XTI))

    const Rng : Ordered_Set<My_Fixed> := 1.0 ..< 5.0

    Print("Rng = ")
    const Open_Ind : Map<Boolean, Univ_String> := [#False => "", #True => "<"]
    for IV in Rng forward loop
        if IV.Low /= IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] & ".." & 
              Open_Ind[IV.High_Is_Open] | IV.High & " ")
        else
                  Print(IV.Low & " ")
        end if
    end loop
    Print('\n')

    Println("X = " & XTI)
    Println("X in Rng = " & (XTI in Rng))

    if XTI in 1.0 ..< 5.0 then
        Println("X in 1.0 ..< 5.0")
    else
        Println("X not in 1.0 ..< 5.0")
    end if

    Println("X in 1.0 ..< 5.0 = " & (XTI in 1.0 ..< 5.0))

end proc SSL.Test.Test_Fixed

package SSL.Core.Time is
  -- Time in nanoseconds since Jan 1, 1970
    type Time is private

    type Time_Interval is new Fixed<Delta => 1.0E-9>

    const Second : Time_Interval := 1.0
    const Millisecond : Time_Interval := 1.0/1000
    const Microsecond : Time_Interval := 1.0/10**6
    const Nanosecond : Time_Interval := 1.0/10**9

    const Minute : Time_Interval := 60.0
    const Hour : Time_Interval := 60 * Minute
    const Day : Time_Interval := 24 * Hour

    type Month_Enum is new Enum< 
       [#Jan, #Feb, #Mar, #Apr, #May, #Jun,
        #Jul, #Aug, #Sep, #Oct, #Nov, #Dec] >

    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      return Time

    func Zero() return Time

    func "+"(Left : Time; Right : Time_Interval) return Time
      is import("+")
    func "+"(Left : Time_Interval; Right : Time) return Time
      is import("+")
    func "-"(Left : Time; Right : Time_Interval) return Time
      is import("-")
    func "-"(Left, Right : Time) return Time_Interval
      is import("-")

    func "=?"(Left, Right : Time) return Ordering
      is import("=?")
end package SSL.Core.Time

package body SSL.Core.Time is
    type Time is record
        const Since_1970 : Time_Interval
    end record

    type Year_Kind is new Enum< [#normal, #leap] >

    const Month_Base : Array<Array<Univ_Integer, Indexed_By => Year_Kind>,
      Indexed_By => Month_Enum> := 
        [#Jan => [0, 0], #Feb => [31, 31], #Mar => [59, 60], #Apr => [90, 91],
         #May => [120, 121], #Jun => [151, 152], #Jul => [181, 182],
         #Aug => [212, 213], #Sep => [243, 244], #Oct => [273, 274],
         #Nov => [304, 305], #Dec => [334, 335]]

    func Kind_Of_Year(Year : Univ_Integer) return Year_Kind is
        if Year mod 4 = 0 and then
          (Year mod 100 /= 0 or else Year mod 400 = 0) then
            -- Every 100 years leap year is omitted, 
            -- except for multiples of 400 which *are* leap years.
            return #leap
        else
            return #normal
        end if
    end func Kind_Of_Year

    func Leaps_Before(Year : Univ_Integer) return Univ_Integer is
        -- Number of leap years before this year, starting from 1970
        if Year < 2101 then
            return (Year-1969)/4
        else
            -- Every 100 years leap year is omitted, 
            -- except for multiples of 400 which *are* leap years.
            return (Year-1969)/4 - (Year-2001)/100
        end if
    end func Leaps_Before

  exports

    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      return Time is
        -- Determine number of nanos since Jan 1, 1970
        const Kind := Kind_Of_Year(1970)
        const Base := Month_Base[Month][Kind]

        return (Since_1970 => 
          (Year-1970) * (365*Day) + 
          (Leaps_Before(Year) + Base + Day_Of_Month)*Day +
          Time_Of_Day - Time_Zone)
    end func Create

    func Zero() return Time is
        return (Since_1970 => 0.0)
    end func Zero

end package SSL.Core.Time

proc SSL.Test.Test_Time(X : Univ_Real) is
    var XTI : Time.Time_Interval := X
    const Local_Minute : Time.Time_Interval := 60.0
    Println("X = " & XTI)
    Println("X * 2 = " & XTI*2)
    Println("X + X = " & (XTI + XTI))
    Println("X - X = " & (XTI - XTI))
    Println("X / 2 = " & (XTI / 2))
    Println("X / 2.0 = " & (XTI / 2.0))
    Println("X * 3.0 = " & (XTI * 3.0))
    Println("5.0 * X = " & (5.0 * XTI))
    Println("-5.0 * X = " & (-5.0 * XTI))
    Println("-5.0 = " & -5.0)
    Println("Local_Minute = " & Local_Minute)
    Println("-5.0*Local_Minute = " & (-5.0*Local_Minute))
    Println("Time.Minute = " & Time.Minute)
    Println("-5.0*Time.Minute = " & (-5.0*Time.Minute))
    Println("Time.Hour = " & Time.Hour )
    Println("-5.0*Time.Hour = " & (-5.0*Time.Hour))

    var T : Time := Create(Year => 2011, Month => #Oct, Day_Of_Month => 18,
      Time_Of_Day => 10*Time.Hour + 5*Time.Minute,
      Time_Zone => -5.0*Time.Hour)

    Println("18-Oct-2011 = " & ( T - Zero() ))
    Println("X = " & XTI )
    Println("18-Oct-2011 - X = " & ( (T - XTI) - Zero() ) )

end proc SSL.Test.Test_Time
     
package SSL.Core.Clock is
    -- A module that provides access to a wall clock and
    -- to other timers, and an ability to delay the caller
    -- for a given amount of time, or until a specified time
    -- in the future.
    type Clock is protected private
    
    func Create() return Clock
        -- Create a clock, which corresponds to the current wall clock time

    func Create(Now : Time) return Clock
        -- Create a clock, where Now() return s the given time when created

    func Now(locked C : Clock) return Time
        -- Return current reading of clock

    queued proc Delay(C : Clock; Until : Time)
        -- Wait until the given clock reads >= Until

    queued proc Delay(C : Clock; For : Time.Time_Interval)
        -- Wait until the given clock reads "Now(C) + For"

    proc Set(locked var C : Clock; To : Time)
        -- Update clock so it reads the given time
end package SSL.Core.Clock

package body SSL.Core.Clock is
    type Clock is protected record
        Timer_Delta : Time.Time_Interval
        -- Amount to be subtracted from Current Time
        -- to produce value of timer
    end record

    func Current_Time(locked C : Clock) return Time 
      is import(#clock_current_time)
        -- NOTE: Clock parameter is ignored; return s wall clock

    proc Wait_For_Delay(queued C : Clock; Until : Time) is 
      import(#clock_delay)
        -- Wait until the wall clock reads >= Until
        -- NOTE: Clock parameter is ignored

  exports
    func Create() return Clock is
        -- Create a clock, which corresponds to the current wall clock time
        -- Println("Create Clock with Delta 0.0")
        return (Timer_Delta => 0.0)
    end func Create

    func Create(Now : Time) return Result : Clock is
        -- Create a clock, where Now() return s the given time when created
        const Delta := Current_Time(Create()) - Now
        -- Println("Create Clock with Delta = " & Delta)
        return (Timer_Delta => Current_Time(Create()) - Now)
    end func Create

    func Now(locked C : Clock) return Result : Time is
        -- Return current reading of clock
        Result := Current_Time(C) - C.Timer_Delta
        -- Println("Now return ing " & Result-Zero())
    end func Now

    queued proc Delay(C : Clock; Until : Time) is
        -- Wait until the given clock reads >= Until
        Wait_For_Delay(C, Until + C.Timer_Delta)
    end proc Delay

    queued proc Delay(C : Clock; For : Time.Time_Interval) is
        -- Wait until the given clock reads "Now(C) + For"
        -- NOTE: Timer_Delta is irrelevant for this one
        -- Println("Wait for delay of " & For)
        const Time_Now := Current_Time(C)
        const Until := Time_Now + For
        -- Println("Time_Now + " & For & " - Time_Now = " & Until - Time_Now)
        Wait_For_Delay(C, Until)
    end proc Delay

    proc Set(locked var C : Clock; To : Time) is
        -- Update clock so it reads the given time
        C.Timer_Delta := Current_Time(C) - To
    end proc Set

end package SSL.Core.Clock

proc SSL.Test.Test_Clock() is
    var C := Clock.Create()
    const Start := C.Now()

  then
    Println("About to delay 4.0 seconds")
    C.Delay(4.0)
    Println("Done with delay of 4.0")
  ||
    Println("About to delay 2.0 seconds")
    C.Delay(2.0)
    Println("Done with delay of 2.0")
||    -- check that indent of 0 works
    for I in 1..7 loop
        Println("In loop delaying for 1.0")
        C.Delay(1.0)
        Println("Done with delay " & I & " of 1.0")
    end loop
then  -- check that indent of 0 works
    Println("Elapsed time: " & (C.Now() - Start))
end proc SSL.Test.Test_Clock

generic
    Modulus : Univ_Integer
package SSL.Core.Modular is
  -- This is an unsigned type whose arithmetic is "modulo" the modulus
    type Modular is private

    func "from_univ"(Lit : Univ_Integer) return Modular 
      is import(#integer_from_univ)

    func "to_univ"(Val : Modular) return Univ_Integer 
      is import(#integer_to_univ)

    func "+"(Right : Modular) return Modular
      is import(#identity)

    func "-"(Right : Modular) return Modular

    func "abs"(Right : Modular) return Modular
      is import(#identity)

    func "magnitude"(Modular) return Modular is "abs"

    func "+"(Left, Right : Modular) return Result : Modular

    func "-"(Left, Right : Modular) return Result : Modular

    func "*"(Left, Right : Modular) return Result : Modular

    func "/"(Left, Right : Modular) return Result : Modular
      is import("/")

    func "mod"(Left, Right : Modular) return Modular
      is import("mod")

    func "rem"(Left, Right : Modular) return Modular
      is import("rem")

    func "**"(Left : Modular; Right : Univ_Integer) return Result : Modular

    proc "+="(var Left : Modular; Right : Modular)

    proc "-="(var Left : Modular; Right : Modular)

    proc "*="(var Left : Modular; Right : Modular)

    proc "/="(var Left : Modular; Right : Modular) 
      is import("/=")

    proc "**="(var Left : Modular; Right : Univ_Integer)

    func "=?"(Left, Right : Modular) return Ordering
      is import("=?")

    func ">>"(Modular; Modular) return Modular is import(">>")

    func "<<"(Modular; Modular) return Modular is import("<<")

    func "and"(Left, Right : Modular) return Modular is import(#bit_and)
    func "or"(Left, Right : Modular) return Modular
    func "xor"(Left, Right : Modular) return Modular
    func "not"(M : Modular) return Modular

    func Min(Left, Right : optional Modular) return optional Modular
      is import(#min)
    func Max(Left, Right : optional Modular) return optional Modular
      is import(#max)

    func Hash(Val : Modular) return Univ_Integer
      is import(#identity)

    proc Print(X : Modular) is import(#print_int)

    proc Put(X : Modular) is Print

    func Image(Val : Modular) return Univ_String
      is import(#to_string_int)

    func Value(Str : Univ_String) return optional Modular

    func First() return Modular

    func Last() return Modular

    func "[..]"() return Countable_Range<Modular> is of Countable_Range<Modular>

    func ".."(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    func "<.."(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    func "..<"(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    func "<..<"(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    func "|"(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
  implements -- for Countable
    -- These operations are needed so Modular satifies
    -- requirements of "Countable" interface, but these
    -- operations are not directly callable (if they were callable,
    -- we would have ambiguity when adding an Modular to an int-literal).

    func "+"(Left : Modular; Right : Univ_Integer) return Result : Modular

    func "+"(Left : Univ_Integer; Right : Modular) return Result : Modular

    func "-"(Left : Modular; Right : Univ_Integer) return Result : Modular

    func "-"(Left, Right : Modular) return Result : Univ_Integer

end package SSL.Core.Modular

package body SSL.Core.Modular is
    type Modular is record
        const Content : Univ_Integer;  -- So this ends up as a wrapper
    end record Modular

    func Bit_Or(Left, Right : Univ_Integer) return Univ_Integer 
      is import(#bit_or)

    func Bit_Xor(Left, Right : Univ_Integer) return Univ_Integer 
      is import(#bit_xor)
  exports
    func "-"(Right : Modular) return Modular is
        return (Content => Modulus - Right.Content)
    end func "-"

    func "+"(Left, Right : Modular) return Result : Modular is
        return (Content => (Left.Content + Right.Content) mod Modulus)
    end func "+"

    func "-"(Left, Right : Modular) return Result : Modular is
        return (Content => (Left.Content - Right.Content) mod Modulus)
    end func "-"

    func "*"(Left, Right : Modular) return Result : Modular is
        return (Content => (Left.Content * Right.Content) mod Modulus)
    end func "*"

    func "**"(Left : Modular; Right : Univ_Integer) return Result : Modular is
        return (Content => (Left.Content ** Right) mod Modulus)
    end func "**"

    proc "+="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content + Right.Content) mod Modulus)
    end proc "+="

    proc "-="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content - Right.Content) mod Modulus)
    end proc "-="

    proc "*="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content * Right.Content) mod Modulus)
    end proc "*="

    proc "**="(var Left : Modular; Right : Univ_Integer) is
        Left := (Content => (Left.Content ** Right) mod Modulus)
    end proc "**="

    func Value(Str : Univ_String) return optional Modular is
        const Val : Univ_Integer := Value(Str)
        if Val is null or else Val in 0..<Modulus then
            return (Content => Val)
        else
            return null
        end if
    end func Value

    func "or"(Left, Right : Modular) return Modular is
        return (Content => Bit_Or(Left.Content, Right.Content) mod Modulus)
    end func "or"

    func "xor"(Left, Right : Modular) return Modular is
        return (Content => Bit_Xor(Left.Content, Right.Content) mod Modulus)
    end func "xor"

    func "not"(M : Modular) return Modular is
        return (Content => Modulus - 1 - M.Content)
    end func "not"

    func First() return Modular is
        return (Content => 0)
    end func First

    func Last() return Modular is
        return (Content => Modulus-1)
    end func Last

    -- implements -- for Countable
    -- These operations are needed so Modular satifies
    -- requirements of "Countable" interface, but these
    -- operations are not directly callable (if they were callable,
    -- we would have ambiguity when adding an Modular to an int-literal).

    func "+"(Left : Modular; Right : Univ_Integer) return Result : Modular is
        return (Content => (Left.Content + Right) mod Modulus)
    end func "+"

    func "+"(Left : Univ_Integer; Right : Modular) return Result : Modular is
        return (Content => (Left + Right.Content) mod Modulus)
    end func "+"

    func "-"(Left : Modular; Right : Univ_Integer) return Result : Modular is
        return (Content => (Left.Content - Right) mod Modulus)
    end func "-"

    func "-"(Left, Right : Modular) return Result : Univ_Integer is
        return (Left.Content - Right.Content) mod Modulus
    end func "-"
end package SSL.Core.Modular
    
proc SSL.Test.Test_Modular() is
    type Mod16 is new Modular<16>

    Println("Testing mod 16")
    Println("0xA + 0xA = " & (Mod16'(0xA) + Mod16'(0xA)))
    Println("0xA or 0x1 = " & (Mod16'(0xA) or Mod16'(0x1)))
    Println("0xA xor 0x2 = " & (Mod16'(0xA) xor Mod16'(0x2)))
    Println("not 0xA = " & (not Mod16'(0xA)))
end proc SSL.Test.Test_Modular

generic
    type Element_Type is new Comparable
package SSL.Containers.Discrete_Ordered_Set is
  -- A set over individual but ordered elements
    type Discrete_Ordered_Set is private

    func "[]"() return Discrete_Ordered_Set

    func Singleton(Elem : Element_Type) return Discrete_Ordered_Set

    func "|"(Left, Right : Element_Type) return Discrete_Ordered_Set
    func "|"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      return Discrete_Ordered_Set
    func "|"(Left : Element_Type; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set
    func "|"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set

    proc "|="(var Left : Discrete_Ordered_Set; Right : Element_Type)
    proc "|="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    proc "<|="(var Left : Discrete_Ordered_Set;
      var Right : optional Element_Type)
        -- Move element into set, leaving Right null afterward.

    proc "<|="(var Left : Discrete_Ordered_Set;
      var Right : Discrete_Ordered_Set)
        -- Move all elements of Right into Left, leaving Right empty.

    func "-"(Left, Right : Discrete_Ordered_Set) return Discrete_Ordered_Set
      -- Set difference
    func "-"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      return Discrete_Ordered_Set
      -- Remove one element
    proc "-="(var S : Discrete_Ordered_Set; Elem : Element_Type)
      -- Remove the given element from the set, if present
    proc "-="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      -- Remove all elements of Right from Left, if present

    func "or"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is "|"   -- union
    proc "or="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      is "|="

    func "+"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is "|"   -- Union
    proc "+="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      is "|="
    proc "+="(var Left : Discrete_Ordered_Set; Right : Element_Type) is "|="
   
    func "and"(Left, Right : Discrete_Ordered_Set) return Discrete_Ordered_Set
        -- Intersection
    proc "and="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    func "xor"(Left, Right : Discrete_Ordered_Set) return Discrete_Ordered_Set
        -- Symmetric difference
    proc "xor="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    func "in"(Left : Element_Type; Right : Discrete_Ordered_Set) return Boolean

    func "=?"(Left, Right : Discrete_Ordered_Set) return Ordering
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise

    func Count(S : Discrete_Ordered_Set) return Univ_Integer

    func "magnitude"(Discrete_Ordered_Set) return Univ_Integer is Count

    func Is_Empty(S : Discrete_Ordered_Set) return Boolean

    func First(S : Discrete_Ordered_Set) return optional Element_Type
    func Last(S : Discrete_Ordered_Set) return optional Element_Type

    func Remove_First(var S : Discrete_Ordered_Set) return optional Element_Type
        -- Remove first element of set (lowest value)

    func Remove_Last(var S : Discrete_Ordered_Set) return optional Element_Type
        -- Remove last element of set (highest value)

    func Remove_Any(var S : Discrete_Ordered_Set) return optional Element_Type
        -- Remove an arbitrary element of set

end package SSL.Containers.Discrete_Ordered_Set

package body SSL.Containers.Discrete_Ordered_Set is

    type Discrete_Ordered_Set is record
        Items : optional AA_Tree<Element_Type>
    end record Discrete_Ordered_Set

  exports
    func "[]"() return Discrete_Ordered_Set is
        return (Items => [])
    end func "[]"

    func Singleton(Elem : Element_Type) return Result : Discrete_Ordered_Set is
        Result := []
        Result.Items |= Elem
    end func Singleton

    func "|"(Left, Right : Element_Type) return Result : Discrete_Ordered_Set is
        Result := [];
        Result.Items |= Left;
        Result.Items |= Right;
    end func "|"

    func "|"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      return Result : Discrete_Ordered_Set is
        Result := Left
        Result.Items |= Right
    end func "|"

    func "|"(Left : Element_Type; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is
        return Right | Left
    end func "|"

    func "|"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Result : Discrete_Ordered_Set is
        Result := Left
        Result |= Right
    end func "|"

    proc "|="(var Left : Discrete_Ordered_Set; Right : Element_Type) is
        Left.Items |= Right;
    end proc "|="

    proc "<|="(var Left : Discrete_Ordered_Set;
      var Right : optional Element_Type)
      is
        -- Move element into set, leaving Right null afterward.
        Left.Items <|= Right
    end proc "<|="

    proc "<|="(var Left : Discrete_Ordered_Set;
      var Right : Discrete_Ordered_Set)
      is
  -- Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) = 0 then
            Left.Items <== Right.Items
        else
            -- Iterate through the tree
            loop
                -- Extract element from right
                var Elem for Left := Remove_Any(Right.Items)

                if Elem is null then
                    return   -- All done
                end if

                Left.Items <|= Elem

            end loop
        end if
    end proc "<|="

    proc "|="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
        -- Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end proc "|="

    func "-"(Left, Right : Discrete_Ordered_Set) 
      return Result : Discrete_Ordered_Set is
      -- Set difference
        Result := Left
        Result -= Right
    end func "-"

    func "-"(Left : Discrete_Ordered_Set; Right : Element_Type)
      return Result : Discrete_Ordered_Set is
      -- Remove one element
        Result := Left
        Result -= Right
    end func "-"
        
    proc "-="(var S : Discrete_Ordered_Set; Elem : Element_Type) is
      -- Remove the given element from the set, if present
        Delete(S.Items, Elem);
    end proc "-="

    proc "-="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
      -- Remove all elements of Right from Left, if present
        for Elem in Right loop
            Left -= Elem
        end loop
    end proc "-="

    func "and"(Left, Right : Discrete_Ordered_Set)
      return Result : Discrete_Ordered_Set is
        -- Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end func "and"

    proc "and="(var Left : Discrete_Ordered_Set;
      Right : Discrete_Ordered_Set) is
        -- Intersection
        for Elem in Left loop
            if Elem not in Right then
                Left -= Elem
            end if
        end loop
    end proc "and="

    func "xor"(Left, Right : Discrete_Ordered_Set) 
      return Result : Discrete_Ordered_Set is
        -- Symmetric difference
        Result := Left
        Result xor= Right
    end func "xor"

    proc "xor="(var Left : Discrete_Ordered_Set;
      Right : Discrete_Ordered_Set) is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end proc "xor="

    func "in"(Left : Element_Type; Right : Discrete_Ordered_Set)
      return Boolean is
        return Overlapping(Right.Items, Left) not null
    end func "in"

    func "=?"(Left, Right : Discrete_Ordered_Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            -- Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                -- Left is a superset
                return #greater
            end if
        else
            -- Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                -- Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end func "=?"

    func Count(S : Discrete_Ordered_Set) return Result : Univ_Integer is
        -- Return count of items in set
        return Count(S.Items);
    end func Count

    func Is_Empty(S : Discrete_Ordered_Set) return Boolean is
        return Is_Empty(S.Items)
    end func Is_Empty

    func First(S : Discrete_Ordered_Set) return optional Element_Type is
        return First(S.Items);
    end func First

    func Last(S : Discrete_Ordered_Set) return optional Element_Type is
        return Last(S.Items);
    end func Last

    func Remove_First(var S : Discrete_Ordered_Set) 
      return Result : optional Element_Type is
        -- Return first element of set
        return Remove_First(S.Items)
    end func Remove_First

    func Remove_Last(var S : Discrete_Ordered_Set) 
      return Result : optional Element_Type is
        -- Remove last element of set
        return Remove_Last(S.Items);
    end func Remove_Last

    func Remove_Any(var S : Discrete_Ordered_Set)
      return optional Element_Type is
        -- Remove any element of set
        return Remove_Any(S.Items);
    end func Remove_Any

end package SSL.Containers.Discrete_Ordered_Set

generic
    type Rep_Type is new Imageable;
    Rep_Map : Map<Univ_Enumeration, Rep_Type>
package SSL.Core.Enum_With_Rep is
  -- An enumeration type specified using a map from literal to value
  -- of an underlying representation type.

    type Enum_With_Rep is private

    func "from_univ"(Univ : Univ_Enumeration) 
      {(for some [Lit => Val] of Rep_Map => Lit = Univ)}
      return Enum_With_Rep
    func "to_univ"(Val : optional Enum_With_Rep)
      return Result : optional Univ_Enumeration
      {Result is null or else
        (for some [Lit => Value] of Rep_Map => Lit = Result)}

    -- Functions to convert from/to rep
    func From_Rep (Rep : optional Rep_Type) return optional Enum_With_Rep
    func To_Rep (Val : optional Enum_With_Rep) return optional Rep_Type

    func "[..]"() return Discrete_Ordered_Set<Enum_With_Rep>

    func "=?"(Left, Right : Enum_With_Rep) return Ordering

    -- Functions for Imageable
    func Image(Val : Enum_With_Rep) return Univ_String
    func Value(Str : Univ_String) return optional Enum_With_Rep

    func Hash(Val : Enum_With_Rep) return Univ_Integer

    func Min(Left, Right : optional Enum_With_Rep) return optional Enum_With_Rep
    func Max(Left, Right : optional Enum_With_Rep) return optional Enum_With_Rep

end package SSL.Core.Enum_With_Rep

package body SSL.Core.Enum_With_Rep is
    type Enum_With_Rep is record
        const Rep : Rep_Type
    end record Enum_With_Rep
  exports
    func "from_univ"(Univ : Univ_Enumeration) 
      return Enum_With_Rep is
        return (Rep => Rep_Map[Univ]);
    end func "from_univ"

    func "to_univ"(Val : optional Enum_With_Rep) 
      return Result : optional Univ_Enumeration is
        if Val is null then
            return null
        else
            for each [Lit => Rep] of Rep_Map loop
                if Val.Rep = Rep then
                    return Lit
                end if
            end loop
            return null
        end if
    end func "to_univ"

    func From_Rep (Rep : optional Rep_Type) return optional Enum_With_Rep is
        if Rep is null then
            return null
        else
            return (Rep => Rep)
        end if
    end func From_Rep

    func To_Rep (Val : optional Enum_With_Rep) return optional Rep_Type is
        if Val is null then
            return null
        else
            return Val.Rep
        end if
    end func To_Rep

    -- Functions for Imageable
    func Image(Val : Enum_With_Rep) return Univ_String is
        const Enum : optional Univ_Enumeration := [[Val]];
        if Enum not null then
            -- use enum image
            return Univ_Enumeration'Image(Enum);
        else
            -- use rep-type Image
            return Rep_Type'Image(Val.Rep)
        end if
    end func Image

    func Value(Str : Univ_String) return optional Enum_With_Rep is
        if Str[1] = '#' then
            -- Presume is an enum
            return Univ_Enumeration'Value(Str)
        else
            -- Use rep-type Value
            return (Rep => Rep_Type'Value(Str))
        end if
    end func Value

    func "[..]"() return Discrete_Ordered_Set<Enum_With_Rep> is
        return [for each Rep of Rep_Map => From_Rep(Rep)]
    end func "[..]";

    func "=?"(Left, Right : Enum_With_Rep) return Ordering is
        return Left.Rep =? Right.Rep
    end func "=?"

    func Hash(Val : Enum_With_Rep) return Univ_Integer is
        return Hash (Val.Rep)
    end func Hash

    func Min(Left, Right : optional Enum_With_Rep) return optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep > Left.Rep then
            return Left
        else
            return Right
        end if
    end func Min

    func Max(Left, Right : optional Enum_With_Rep) return optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep < Left.Rep then
            return Left
        else
            return Right
        end if
    end func Max

end package SSL.Core.Enum_With_Rep

proc SSL.Test.Test_Enum_With_Rep() is
    type Color is new Enum_With_Rep<Univ_Integer,
               [#red => 1, #green => 3, #blue => 5]>;

    type Day_Of_Week is new Enum_With_Rep<Modular<2**7>,
          [#Monday => 1<<1, #Tuesday => 1<<2, #Wednesday => 1<<3,
           #Thursday => 1<<4, #Friday => 1<<5,
            #Saturday => 1<<6, #Sunday => 1<<7]>

    for C in Color forward loop
        Println("Next color = " & C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " & C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " & D3)
    end loop

    {#Monday in Day_Of_Week}

    for D4 in Day_Of_Week reverse loop
        Println("Prev day of week = " & D4)
    end loop

    for D5 in Day_Of_Week forward loop
        Println("To_Rep(" & D5 & ") = " & To_Rep(D5))
    end loop

    for I in 1..10 forward loop
        Println("Day_Of_Week.From_Rep(" & I & ") = " &
          Day_Of_Week.From_Rep(I))
    end loop

end proc SSL.Test.Test_Enum_With_Rep

package SSL.Core.IO is
  -- Locked versions of the Print, Println and Readln operations
    type IO is protected private

    func Get_IO() return IO  -- Get handle on IO subsystem

    proc Println(locked var IO; Univ_String)
    proc Print(locked var IO; Univ_String)
    proc Print(locked var IO; Univ_Character)
    proc Print(locked var IO; Univ_Integer)
    proc Print(locked var IO; Univ_Real)
    proc Print(locked var IO; Univ_Enumeration) 

    func Readln(locked var IO) return optional Univ_String

    proc Put_Line(locked var IO; Univ_String) is Println
    proc Put(locked var IO; Univ_String) is Print
    proc New_Line(locked var IO) is (Put('\n'))
    proc Put(locked var IO; Univ_Character) is Print
    proc Put(locked var IO; Univ_Integer) is Print
    proc Put(locked var IO; Univ_Real) is Print
    proc Put(locked var IO; Univ_Enumeration) is Print

    func Get_Line(locked var IO) return optional Univ_String is Readln
end package SSL.Core.IO

package body SSL.Core.IO is
    type IO is protected null record

  exports
    func Get_IO() return IO is
        return ()
    end func Get_IO

    proc Println(locked var IO; Univ_String) is
        Println (Univ_String)
    end proc Println

    proc Print(locked var IO; Univ_String) is
        Print (Univ_String)
    end proc Print

    proc Print(locked var IO; Univ_Character) is
        Print (Univ_Character)
    end proc Print

    proc Print(locked var IO; Univ_Integer) is
        Print (Univ_Integer)
    end proc Print

    proc Print(locked var IO; Univ_Real) is
        Print (Univ_Real)
    end proc Print

    proc Print(locked var IO; Univ_Enumeration) is
        Print (Univ_Enumeration)
    end proc Print

    func Readln(locked var IO) return optional Univ_String is
        return Readln()
    end func Readln

end package SSL.Core.IO

proc SSL.Test.Test_IO (X, Y : Univ_String; Z : Univ_Integer) is
    var IO := Core.IO.Get_IO()
    const Pi := 3.141592653589793
    const True := Boolean'(#True)

    IO.Print ("Pi = ")
    IO.Print (Pi)
    IO.Print (", True prints as ")
    IO.Print (True)
    IO.Print ('\n')
    IO.Print ("X = \"" & X & '"')
    IO.Print (", Y = \"" & Y & '"')
    IO.Println (", Z = " & Z )
    IO.Print ("Give me somethin: ")
    var Input := IO.Readln()
    IO.Println ("You gave me: \"" & Input & '"')

end proc SSL.Test.Test_IO
    
with SSL.Test.Test_IO

proc Test_IO (X, Y : Univ_String; Z : Univ_Integer) is
    SSL.Test.Test_IO (X, Y, Z)
end proc Test_IO

package SSL.Core.Output_Stream is
  -- Output stream interface; all operations
  -- expressed in terms of Univ_String print and close
    type Output_Stream is abstract private

    abstract proc Put(var Output_Stream; Univ_String)
    abstract proc Close(var optional Output_Stream)
    abstract proc Flush(var optional Output_Stream)

    proc Print(var Output_Stream'Class; Univ_String)

    proc Println(var Output_Stream'Class; Univ_String)

    proc Print(var Output_Stream'Class; Univ_Character)
    proc Print(var Output_Stream'Class; Univ_Integer)
    proc Print(var Output_Stream'Class; Univ_Real)
    proc Print(var Output_Stream'Class; Univ_Enumeration) 

    proc Put_Line(var Output_Stream'Class; Univ_String) is Println

    proc Put(var Output_Stream'Class; Univ_Character) is Print
    proc New_Line(var Output_Stream'Class) is (Put(Output_Stream, "\n"))
    proc Put(var Output_Stream'Class; Univ_Integer) is Print
    proc Put(var Output_Stream'Class; Univ_Real) is Print
    proc Put(var Output_Stream'Class; Univ_Enumeration) is Print
end package SSL.Core.Output_Stream

package body SSL.Core.Output_Stream is
  -- Output stream interface; all operations
  -- expressed in terms of Univ_String print
  exports
    proc Print(var Output_Stream'Class; Univ_String) is
        Output_Stream.Put(Univ_String)
    end proc Print

    proc Println(var Output_Stream'Class; Univ_String) is
        Output_Stream.Put(Univ_String)
        Output_Stream.Put("\n")
    end proc Println

    proc Print(var Output_Stream'Class; Univ_Character) is
        Output_Stream.Put(Image(Univ_Character))
    end proc Print

    proc Print(var Output_Stream'Class; Univ_Integer) is
        Output_Stream.Put(Image(Univ_Integer))
    end proc Print

    proc Print(var Output_Stream'Class; Univ_Real) is
        Output_Stream.Put(Image(Univ_Real))
    end proc Print

    proc Print(var Output_Stream'Class; Univ_Enumeration) is
        Output_Stream.Put(Image(Univ_Enumeration))
    end proc Print

end package SSL.Core.Output_Stream

package SSL.Core.Input_Stream is
    type Input_Stream is abstract private

    abstract func Get_Line(var Input_Stream) return optional Univ_String
    abstract proc Close(var optional Input_Stream)

    func Readln(var Input_Stream'Class)
      return optional Univ_String
end package SSL.Core.Input_Stream

package body SSL.Core.Input_Stream is
  exports
    func Readln(var Input_Stream'Class) return optional Univ_String is
         return Get_Line(Input_Stream)
    end func Readln
end package SSL.Core.Input_Stream

package SSL.Core.File_Output_Stream is
    type File_Output_Stream is new Output_Stream with private

    func Create(var IO; Name : Univ_String) return optional File_Output_Stream
      is import(#create_output_file)
    func Append(var IO; Name : Univ_String) return optional File_Output_Stream
      is import(#append_output_file)
    proc Close(var optional File_Output_Stream)
      is import(#close_output_file)
    proc Flush(var optional File_Output_Stream)
      is import(#flush_output_file)
    proc Put(var File_Output_Stream; Univ_String)
      is import(#print_to_file)
end package SSL.Core.File_Output_Stream

package body SSL.Core.File_Output_Stream is
    type File_Output_Stream is record
        const Name : Univ_String
        const Index : Univ_Integer
    end record File_Output_Stream

  exports
end package SSL.Core.File_Output_Stream

package SSL.Core.File_Input_Stream is
    type File_Input_Stream is new Input_Stream with private

    func Open(var IO; Name : Univ_String) return optional File_Input_Stream
      is import(#open_input_file)
    proc Close(var optional File_Input_Stream)
      is import(#close_input_file)
    func Get_Line(var File_Input_Stream) return optional Univ_String
      is import(#read_from_file)
end package SSL.Core.File_Input_Stream

package body SSL.Core.File_Input_Stream is
    type File_Input_Stream is record
        const Name : Univ_String;
        const Index : Univ_Integer
    end record File_Input_Stream
  exports
end package SSL.Core.File_Input_Stream

proc SSL.Test.Test_File (Name, X, Y : Univ_String; Z : Univ_Integer) is
    var IO := Core.IO.Get_IO()
    var File := File_Output_Stream.Create(IO, Name);
    const Pi := 3.14159265389793
    const True := Boolean'(#True)

    IO.Put_Line ("Writing to file: " & Name)

    File.Put ("Pi = ")
    Output_Stream.Put (File, Pi)
    File.Put (", True prints as ")
    Put (File, True)
    Put (File, '\n')
    File.Put ("X = \"" & X & '"')
    Put_Line (File, ", Y = \"" & Y & '"')
    IO.Put ("Give me somethin: ")
    var Inp := IO.Get_Line()
    IO.Put_Line ("You gave me: \"" & Inp & '"')
    File.Put_Line ("User input = \"" & Inp & '"')
    File.Close();

    var Inp_File := File_Input_Stream.Open(IO, Name)
    IO.Put_Line ("Contents of file " & Name)
    loop
        const Line := Inp_File.Get_Line()
        if Line is null then
            exit loop
        end if
        IO.Put_Line(Line)
    end loop

    IO.Put_Line("All done")

end proc SSL.Test.Test_File
