// ParaSail Prototype Standard Library

// Copyright (C) 2011-2014, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors at http://groups.google.com/group/parasail-programming-language

interface PSL<> is
end interface PSL

interface PSL::Core<> is
end interface PSL::Core

interface PSL::Containers<> is
end interface PSL::Containers

interface PSL::Test<> is
end interface PSL::Test

abstract interface PSL::Core::Any<> is
end interface PSL::Core::Any

abstract interface PSL::Core::Assignable<> is
end interface PSL::Core::Assignable
interface PSL::Core::Boolean<> is
    op "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#false | #true]}
      -> Boolean is import(#bool_from_univ)

    op "to_univ"(Val : Boolean) -> Univ_Enumeration 
      is import(#bool_to_univ)

    op "=?"(Left, Right : Boolean) -> Ordering
      is import("=?")
        // NOTE: #true > #false

    op "not"(Boolean) -> Boolean is import("not")
    op "and"(Left, Right : Boolean) -> Boolean is import("and")
    op "or"(Left, Right : Boolean) -> Boolean is import("or")
    op "xor"(Left, Right : Boolean) -> Boolean is import("xor")

    op "and="(var Left : Boolean; Right : Boolean)
    op "or="(var Left : Boolean; Right : Boolean)
    op "xor="(var Left : Boolean; Right : Boolean)

    func Hash(Val : Boolean) -> Univ_Integer
      is import(#identity)

    // For Imageable
    func To_String(Val : optional Boolean) -> Univ_String
    func From_String(Str : Univ_String) -> optional Boolean

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Boolean) -> Boolean 
      is import("+")
    op "+"(Left : Boolean; Right : Univ_Integer) -> Boolean 
      is import("+")
    op "-"(Left, Right : Boolean) -> Univ_Integer 
      is import("-")
    op "-"(Left : Boolean; Right : Univ_Integer) -> Boolean 
      is import("-")

    func Min(Left, Right : optional Boolean) -> optional Boolean
      is import(#min)
    func Max(Left, Right : optional Boolean) -> optional Boolean
      is import(#max)

    // TBD: These should be properties some day (e.g. Boolean#first).
    func First()->Boolean
    func Last()->Boolean

    op ".."(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "<.."(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "..<"(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "<..<"(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "|"(Left, Right : Boolean) -> Countable_Set<Boolean>
end interface PSL::Core::Boolean

class PSL::Core::Boolean is
    type Boolean_Set is Countable_Set<Boolean>

  exports
    op "and="(var Left : Boolean; Right : Boolean) is
        Left := Left and Right
    end op "and="

    op "or="(var Left : Boolean; Right : Boolean) is
        Left := Left or Right
    end op "or="

    op "xor="(var Left : Boolean; Right : Boolean) is
        Left := Left xor Right
    end op "xor="

    func To_String(Val : optional Boolean) -> Univ_String is
        if Val is null then
            return "null"
        elsif Val then
            return "#true"
        else
            return "#false"
        end if
    end func To_String

    func From_String(Str : Univ_String) -> optional Boolean is
        if Str == "#true" then
            return #true
        elsif Str == "#false" then
            return #false
        else
            return null
        end if
    end func From_String

    func First()->Boolean is
        return #false
    end func First

    func Last()->Boolean is
        return #true
    end func Last

    // NOTE: For implementation reasons, we put these here rather than defining
    //       them in the interface using "is in Countable_Set<Boolean>"
    op ".."(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::".."(Left, Right)
    end op ".."

    op "<.."(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"<.."(Left, Right)
    end op "<.."

    op "..<"(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"..<"(Left, Right)
    end op "..<"
    op "<..<"(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"<..<"(Left, Right)
    end op "<..<"

    op "|"(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"|"(Left, Right)
    end op "|"
end class PSL::Core::Boolean

func PSL::Test::Test_Boolean(UX, UY : Univ_Enumeration) is
    const X : Boolean := UX
    const Y : Boolean := UY

    Println("not " | X | " = " | (not X))
    if X != Y then
       Println("not " | Y | " = " | (not Y))
    end if
    Println(X | " and " | Y | " = " | (X and Y))
    Println(X | " or " | Y | " = " | (X or Y))
    Println(X | " xor " | Y | " = " | (X xor Y))

    var XX := X
    XX and= Y
    Println(X | " and= " | Y | " = " | XX)
    XX := X
    XX or= Y
    Println(X | " or= " | Y | " = " | XX)
    XX := X
    XX xor= Y
    Println(X | " xor= " | Y | " = " | XX)
end func PSL::Test::Test_Boolean
interface PSL::Containers::Set<Element_Type is Hashable<>> is
  // A hashed-set module
    op "[]"() -> Set

    func Singleton(Elem : Element_Type) -> Set

    op "|"(Left, Right : Element_Type) -> Set
    op "|"(Left : Set; Right : Element_Type) -> Set
    op "|"(Left : Element_Type; Right : Set) -> Set
    op "|"(Left : Set; Right : Set) -> Set

    op "|="(var Left : Set; Right : Set)

    op "|="(var Left : Set; Right : Element_Type)
        // Add element to Set.

    op "<|="(var Left : Set; var Right : optional Element_Type)
        // Move element into Set.

    op "<|="(var Left : Set; var Right : Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "in"(Left : Element_Type; Right : Set) -> Boolean<>

    op "=?"(Left, Right : Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    op "or"(Left, Right : Set) -> Set is "|"  // Union
    op "or="(var Left : Set; Right : Set) is "|="

    op "+"(Left, Right : Set) -> Set is "|"   // Union
    op "+="(var Left : Set; Right : Set) is "|="
    op "+="(var Left : Set; Right : Element_Type) is "|="   // aka Include

    op "and"(Left, Right : Set) -> Set
        // Intersection
    op "and="(var Left : Set; Right : Set)

    op "xor"(Left, Right : Set) -> Set
        // Symmetric difference
    op "xor="(var Left : Set; Right : Set)

    op "-"(Left, Right : Set) -> Set
        // Set difference

    op "-="(var Left : Set; Right : Set)
        // Compute Set difference

    op "-="(var S : Set; Elem : Element_Type)   // aka Exclude
        // Remove one element, if present

    func Count(S : Set) -> Univ_Integer

    op "magnitude"(Set) -> Univ_Integer is Count

    func Is_Empty(S : Set) -> Boolean<>

    func Remove_Any(var S : Set) -> optional Element_Type
      // Remove and return an arbitrary element of the Set S

    func Any_Element(S : Set) -> optional Element_Type
      // Return an arbitrary element of the Set S;
      // return null if S is empty.

    optional func Dump_Statistics(S : Set)
      // A debugging routine to show bucket sizes of Set

end interface PSL::Containers::Set
interface PSL::Core::Univ_Enumeration<> is
    op "=?"(Left, Right : Univ_Enumeration) -> Ordering 
      is import(#unordered_compare)

    func To_String(Val : Univ_Enumeration) -> Univ_String
      is import(#to_string_enum)

    func From_String(Str : Univ_String) -> optional Univ_Enumeration
      is import(#from_string_enum)

    func Print(Val : Univ_Enumeration) 
      is import(#print_univ_enum)
    func Println(Val : Univ_Enumeration) 
      is (Println(To_String(Val)))

    func Hash(Val : Univ_Enumeration) -> Univ_Integer
      is import(#hash_enum)

    op "in"(Left : Univ_Enumeration; Right : Set<Univ_Enumeration>) 
      -> Boolean<>
      is in Set<Univ_Enumeration>

end interface PSL::Core::Univ_Enumeration
abstract interface PSL::Core::Optional<> is
    op "null"() -> Optional
    op "is null"(Optional) -> Boolean
end interface PSL::Core::Optional
interface PSL::Core::Ordering<> is
  // Enumeration type used to represent value of "=?" operator
    op "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#less | #equal | #greater | #unordered]}
      -> Ordering is import(#ordering_from_univ)

    op "to_univ"(Val : Ordering) -> Univ_Enumeration 
      is import(#ordering_to_univ)

    op "to_bool"(Ord : Ordering; Mask : Univ_Integer) -> Boolean 
      is import(#ordering_to_bool)

    op "=?"(Left, Right : Ordering) -> Ordering is import("=?")

    func Hash(Val : Ordering) -> Univ_Integer
      is import(#identity)

    // For Imageable
    func To_String(Val : Ordering) -> Univ_String
    func From_String(Str : Univ_String) -> optional Ordering

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Ordering) -> Ordering 
      is import("+")
    op "+"(Left : Ordering; Right : Univ_Integer) -> Ordering 
      is import("+")
    op "-"(Left, Right : Ordering) -> Univ_Integer 
      is import("-")
    op "-"(Left : Ordering; Right : Univ_Integer) -> Ordering 
      is import("-")

    func Min(Left, Right : optional Ordering) -> optional Ordering
      is import(#min)
    func Max(Left, Right : optional Ordering) -> optional Ordering
      is import(#max)

    // TBD: These should be properties some day (e.g. Ordering#first).
    func First()->Ordering
    func Last()->Ordering

    op ".."(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "<.."(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "..<"(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "<..<"(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "|"(Left, Right : Ordering) -> Countable_Set<Ordering>
end interface PSL::Core::Ordering

class PSL::Core::Ordering is
    type Ordering_Set is Countable_Set<Ordering>

  exports
    func First()->Ordering is
        return #less
    end func First

    func Last()->Ordering is
        return #unordered
    end func Last

    func To_String(Val : Ordering) -> Univ_String is
        case Val of
          [#less] =>
            return "#less"
          [#equal] =>
            return "#equal"
          [#greater] =>
            return "#greater"
          [#unordered] =>
            return "#unordered"
        end case
    end func To_String

    func From_String(Str : Univ_String) -> optional Ordering is
        case Str of
          ["#less"] =>
            return #less
          ["#equal"] =>
            return #equal
          ["#greater"] =>
            return #greater
          ["#unordered"] =>
            return #unordered
          [..] =>
            return null
        end case
    end func From_String

    // NOTE: For implementation reasons, we put these here rather than defining
    //       them in the interface using "is in Countable_Set<Ordering>"
    op ".."(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::".."(Left, Right)
    end op ".."

    op "<.."(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"<.."(Left, Right)
    end op "<.."

    op "..<"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"..<"(Left, Right)
    end op "..<"
    op "<..<"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"<..<"(Left, Right)
    end op "<..<"

    op "|"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"|"(Left, Right)
    end op "|"
end class PSL::Core::Ordering
abstract interface PSL::Core::Comparable<> implements Assignable<> is
    op "=?"(Left, Right : Comparable) -> Ordering
end interface PSL::Core::Comparable
abstract interface PSL::Core::Ordered<> implements Comparable<> is
  // The "=?" operator on Ordered types never returns #unordered
  // They also provide a Min and Max operator.

  // Note that Min and Max may be given null operands.
  // They each return null if both operands are null, and return the
  // non-null operand if only one of the operands is null.
  // This allows null to be used as the initial value when computing
  // the "Max" or "Min" of a possibly-empty sequence, rather than
  // having to start with the equivalent of negative or positive infinity.

    type Full_Ordering is Ordering
      // {Full_Ordering in #less | #equal | #greater}

    op "=?"(Left, Right : Ordered) -> Full_Ordering

    func Min(Left, Right : optional Ordered) -> optional Ordered
    func Max(Left, Right : optional Ordered) -> optional Ordered
end interface PSL::Core::Ordered
abstract interface PSL::Core::Hashable<> implements Comparable<> is
    // Types which aren't ordered nevertheless are often
    // hashable, which makes it possible to create an efficient
    // set or map using them as the index type.
    op "=?"(Left, Right : Hashable) -> Ordering
    func Hash(Val : Hashable) -> Univ_Integer
end interface PSL::Core::Hashable
interface PSL::Containers::Countable_Set<Element_Type is Countable<>> is
    //  A set of values of a "countable" type (e.g. integer or enum),
    //  where we can efficiently represent intervals (i.e. contiguous ranges)
    //  of values of the type, allowing large sets to be handled.
    op "[]"() -> Countable_Set
    op "[..]"() -> Countable_Set

    func Singleton(Elem : Element_Type) -> Countable_Set

    op ".."(Left, Right : Element_Type) -> Countable_Set
    op "<.."(Left, Right : Element_Type) -> Countable_Set
    op "..<"(Left, Right : Element_Type) -> Countable_Set
    op "<..<"(Left, Right : Element_Type) -> Countable_Set

    op "|"(Left, Right : Element_Type) -> Countable_Set
    op "|"(Left : Countable_Set; Right : Element_Type) -> Countable_Set
    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set
    op "|"(Left : Countable_Set; Right : Countable_Set) -> Countable_Set

    op "|="(var Left : Countable_Set; Right : Element_Type)
    op "|="(var Left : Countable_Set; Right : Countable_Set)

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Countable_Set; var Right : Countable_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Countable_Set) -> Countable_Set
      // Set difference
    op "-"(Left : Countable_Set; Right : Element_Type) -> Countable_Set
      // Remove one element
    op "-="(var S : Countable_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Countable_Set; Right : Countable_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Countable_Set; Right : Countable_Set) 
      -> Countable_Set is "|"   // union
    op "or="(var Left : Countable_Set; Right : Countable_Set) is "|="

    op "+"(Left : Countable_Set; Right : Countable_Set) 
      -> Countable_Set is "|"   // Union
    op "+="(var Left : Countable_Set; Right : Countable_Set) is "|="
    op "+="(var Left : Countable_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Countable_Set) -> Countable_Set
        // Intersection
    op "and="(var Left : Countable_Set; Right : Countable_Set)

    op "xor"(Left, Right : Countable_Set) -> Countable_Set
        // Symmetric difference
    op "xor="(var Left : Countable_Set; Right : Countable_Set)

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean

    op "=?"(Left, Right : Countable_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    func Count(S : Countable_Set) -> Univ_Integer

    op "magnitude"(Countable_Set) -> Univ_Integer is Count

    func Is_Empty(S : Countable_Set) -> Boolean

    func First(S : Countable_Set) -> optional Element_Type
    func Last(S : Countable_Set) -> optional Element_Type
    func Any_Element(S : Countable_Set) -> optional Element_Type

    op "indexing"(S : Countable_Set; Index : Univ_Integer)
      -> optional Element_Type
         //  Return "Index"th element of set S, counting 1 .. Count(S)

    op "slicing"(S : Countable_Set; 
      Index_Set : Countable_Range<Univ_Integer>) -> Countable_Set
         //  Return subset of set S, elements S[Index_Set.First] through
         //  S[Index_Set.Last], counting 1 .. Count(S)

    op "/"(Set : Countable_Set; Num_Pieces : Univ_Integer)
      -> Vector<Countable_Set>
        // Divide a set into a vector of sets, each of similar size

    func Remove_First(var S : Countable_Set) -> optional Element_Type
        // Remove first element of set (lowest value)

    func Remove_Last(var S : Countable_Set) -> optional Element_Type
        // Remove last element of set (highest value)

    func Remove_Any(var S : Countable_Set) -> optional Element_Type
        // Remove an arbitrary element of set

    func Ranges(S : Countable_Set) ->
      Ordered_Set<Countable_Range<Element_Type>>
        // Return set of disjoint ranges that represent the set of values in S

end interface PSL::Containers::Countable_Set

abstract interface PSL::Core::Countable<> implements Ordered<> is
    op "+"(Left : Countable; Right : Univ_Integer) -> Countable
    op "+"(Left : Univ_Integer; Right : Countable) -> Countable

    op "-"(Left : Countable; Right : Univ_Integer) -> Countable
    op "-"(Left, Right : Countable) -> Univ_Integer

    op "=?"(Left, Right : Countable) -> Ordered::Full_Ordering

    func First() -> Countable

    func Last() -> Countable

    func Min(Left, Right : optional Countable) -> optional Countable
    func Max(Left, Right : optional Countable) -> optional Countable

    func Hash(Val : Countable) -> Univ_Integer

    op ".."(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "<.."(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "..<"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "<..<"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "|"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>

    //  Countable also implements Imageable
    func To_String(Val : Countable) -> Univ_String
    optional func From_String(Univ : Univ_String) -> optional Countable
end interface PSL::Core::Countable
interface PSL::Core::Univ_Integer<> is
    op "+"(Right : Univ_Integer) -> Univ_Integer
      is import(#identity)

    op "-"(Right : Univ_Integer) -> Univ_Integer
      is import(#negate)

    op "abs"(Right : Univ_Integer) -> Univ_Integer
      is import("abs")

    op "magnitude"(Univ_Integer) -> Univ_Integer is "abs"

    op "+"(Left, Right : Univ_Integer) -> Result : Univ_Integer 
      is import("+")

    op "-"(Left, Right : Univ_Integer) -> Result : Univ_Integer
      is import("-")

    op "*"(Left, Right : Univ_Integer) -> Result : Univ_Integer 
      is import("*")

    op "/"(Left, Right : Univ_Integer) -> Result : Univ_Integer
      is import("/")

    op "**"(Left, Right : Univ_Integer) -> Univ_Integer
      is import("**")

    op "mod"(Left, Right : Univ_Integer) -> Univ_Integer
      is import("mod")

    op "rem"(Left, Right : Univ_Integer) -> Univ_Integer
      is import("rem")


    op "+="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("+=")

    op "-="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("-=")

    op "*="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("*=")

    op "/="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("/=")

    op "**="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("**=")


    op "=?"(Left, Right : Univ_Integer) -> Ordering
      is import("=?")

    op ">>"(Univ_Integer; Univ_Integer) -> Univ_Integer is import(">>")

    op "<<"(Univ_Integer; Univ_Integer) -> Univ_Integer is import("<<")

    func Min(Left, Right : optional Univ_Integer) -> optional Univ_Integer
      is import(#min)
    func Max(Left, Right : optional Univ_Integer) -> optional Univ_Integer
      is import(#max)

    func Hash(Val : Univ_Integer) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Univ_Integer) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Univ_Integer
      is import(#from_string_int)

    func Print(X : Univ_Integer) is import(#print_int)
    func Println(X : Univ_Integer) is (Println(To_String(X)))

    func First() -> Univ_Integer is
      import(#univ_integer_first)

    func Last() -> Univ_Integer is
      import(#univ_integer_last)

    op ".."(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "<.."(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "..<"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "<..<"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "|"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
end interface PSL::Core::Univ_Integer
interface PSL::Core::Countable_Range<Bound_Type is Countable<>> is
    // Simple contiguous Countable_Range of integers (i.e. an interval)
    const First : Bound_Type
    const Last : Bound_Type
    op ".."(Left, Right : Bound_Type) -> Countable_Range
    op "<.."(Left, Right : Bound_Type) -> Countable_Range
    op "..<"(Left, Right : Bound_Type) -> Countable_Range
    op "<..<"(Left, Right : Bound_Type) -> Countable_Range
    op "in"(Val : Bound_Type; Interval : Countable_Range) -> Boolean
    func Length(R : Countable_Range) -> Univ_Integer
    op "magnitude"(Countable_Range) -> Univ_Integer is Length
    op "[..]"() -> Countable_Range
    op "[]"() -> Countable_Range
    func Singleton(Bound : Bound_Type) -> Countable_Range

    op "/"(R : Countable_Range; Num_Pieces : Univ_Integer)
      -> Vector<Countable_Range>
        // Divide a range into a vector of subranges, each of similar size

    func Remove_First(var S : Countable_Range) -> optional Bound_Type
    func Remove_Last(var S : Countable_Range) -> optional Bound_Type
    func Remove_Any(var S : Countable_Range) -> optional Bound_Type

    op "=?"(Left, Right : Countable_Range) -> Ordering
    //  Return #equal if Left.First == Right.First and Left.Last == Right.Last
    //  Return #less if Left.Last < Right.First
    //  Return #greater Left.First > Right.Last
    //  Return #unordered otherwise (i.e. they overlap and are not identical)
end interface PSL::Core::Countable_Range

class PSL::Core::Countable_Range is
exports  // check that indent of 0 works
    op ".."(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left, Last => Right)
    end op ".."

    op "<.."(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left+1, Last => Right)
    end op "<.."

    op "..<"(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left, Last => Right-1)
    end op "..<"

    op "<..<"(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left+1, Last => Right-1)
    end op "<..<"

    op "in"(Val : Bound_Type; Interval : Countable_Range) -> Boolean is
        return Val >= Interval.First and then Val <= Interval.Last
    end op "in"

    func Length(R : Countable_Range) -> Univ_Integer is
        return R.Last - R.First + 1
    end func Length

    op "[]"() -> Countable_Range is
        return Bound_Type::First()+1 .. Bound_Type::First()
    end op "[]"

    op "[..]"() -> Countable_Range is
        return Bound_Type::First() .. Bound_Type::Last()
    end op "[..]"

    func Singleton(Bound : Bound_Type) -> Countable_Range is
        return Bound .. Bound
    end func Singleton

    op "/"(R : Countable_Range; Num_Pieces : Univ_Integer)
      -> Result : Vector<Countable_Range> is
       // Divide a range into a vector of subranges, each of similar size
        {> Num_Pieces > 0 <}

        if Num_Pieces <= 1 then
            //  Return a vector of length 1 if Num_Pieces is 1 (or less)
            return Create(1, R)
        end if

        const Size := Length(R)
        const Small_Piece_Size := Size / Num_Pieces
        const Big_Piece_Size := Small_Piece_Size + 1
        const Num_Big_Pieces := Size rem Num_Pieces

        //  Create the result
        Result := Create(Num_Pieces, [])

        //  Fill in the elements of the result vector with slices of the set.
        var Index := R.First

        //  Big pieces first
        for I in 1 .. Num_Big_Pieces forward loop
            Result[I] := Index .. Index + Big_Piece_Size - 1
            Index := Index + Big_Piece_Size
        end loop

        //  Small pieces next
        if Small_Piece_Size > 0 then
            for I in Num_Big_Pieces + 1 .. Num_Pieces forward loop
                Result[I] := Index .. Index + Small_Piece_Size - 1
                Index := Index + Small_Piece_Size
            end loop
        end if

        {> Index == R.Last + 1 <}
            
    end op "/"

    func Remove_First(var S : Countable_Range) 
      -> Result : optional Bound_Type is
        if S.First <= S.Last then
            Result := S.First
            S := (First => S.First+1, Last => S.Last)
        else
            Result := null
        end if
    end func Remove_First
        
    func Remove_Last(var S : Countable_Range) 
      -> Result : optional Bound_Type is
        if S.First <= S.Last then
            Result := S.Last
            S := (First => S.First, Last => S.Last-1)
        else
            Result := null
        end if
    end func Remove_Last

    func Remove_Any(var S : Countable_Range) 
      -> Result : optional Bound_Type is
        if S.First <= S.Last then
            if (S.Last - S.First) mod 2 == 0 then
                return Remove_First(S)
            else
                return Remove_Last(S)
            end if
        else
            return null
        end if
    end func Remove_Any

    op "=?"(Left, Right : Countable_Range) -> Ordering is
    //  Return #equal if Left.First == Right.First and Left.Last == Right.Last
    //  Return #less if Left.Last < Right.First
    //  Return #greater Left.First > Right.Last
    //  Return #unordered otherwise (i.e. they overlap and are not identical)
        if Left.Last < Right.First then
           return #less
        elsif Left.First > Right.Last then
           return #greater
        elsif Left.First == Left.First
          and then Left.Last == Right.Last
        then
           return #equal
        else
           return #unordered
        end if
    end op "=?"
end class PSL::Core::Countable_Range

func PSL::Test::Test_Countable_Range(A, X, Y : Integer) is
    var R : Countable_Range<Integer> := X .. Y
    Println(A | " in " | X | ".." | Y | "=" | ( A in R ))

    for J in R loop 
        Println("Remove_Any(" | X | ".." | Y | ") = " | J)
    end loop

    R := 1 .. 10
    Println("R := 1..10");

    for K in R reverse loop 
        Println("Remove_Last(R) = " | K)
    end loop

    Println("Length(R) = " | Length(R))

    for Num in 1 .. 11 forward loop
       Print("R / " | Num | " =")
       for each Piece of R / Num forward loop
          if Length(Piece) == 0 then
             Print (" []")
          else
             Print (" " | Piece.First | ".." | Piece.Last)
          end if
       end loop
       Print('\n')
    end loop
end func PSL::Test::Test_Countable_Range
interface PSL::Core::Univ_Character<> is
    op "+"(Left : Univ_Character; Right : Univ_Integer) -> Univ_Character
      is import("+")
    op "+"(Left : Univ_Integer; Right : Univ_Character) -> Univ_Character
      is import("+")

    op "-"(Left : Univ_Character; Right : Univ_Integer) -> Univ_Character
      is import("-")
    op "-"(Left, Right : Univ_Character) -> Univ_Integer
      is import("-")

    op "*"(Left : Univ_Integer; Right : Univ_Character) -> Univ_String
        // Produce specified number of "Right" chars in a row
    op "*"(Left : Univ_Character; Right : Univ_Integer) -> Univ_String
        // Produce specified number of "Left" chars in a row

    op "=?"(Left, Right : Univ_Character) -> Ordering
      is import("=?")

    func To_String(Val : Univ_Character) -> Univ_String
      is import(#to_string_char)

    func From_String(Str : Univ_String) -> optional Univ_Character
      is import(#from_string_char)

    func Print(C : Univ_Character) is import(#print_char)
    func Println(C : Univ_Character) is (Println(To_String(C)))

    func Hash(Val : Univ_Character) -> Univ_Integer
      is import(#identity)

    func First() -> Univ_Character

    func Last() -> Univ_Character

    func Min(Left, Right : optional Univ_Character) -> optional Univ_Character
      is import(#min)
    func Max(Left, Right : optional Univ_Character) -> optional Univ_Character
      is import(#max)

    op ".."(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "<.."(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "..<"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "<..<"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "|"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
end interface PSL::Core::Univ_Character
    
class PSL::Core::Univ_Character is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_Character) -> Univ_String is
        // Produce specified number of "Right" chars in a row
        return Left * To_String(Right)   // Just pass the buck to the string op
    end op "*"

    op "*"(Left : Univ_Character; Right : Univ_Integer) -> Univ_String is
        // Produce specified number of "Left" chars in a row
        return Right * To_String(Left)   // Just pass the buck to the string op
    end op "*"

    func First() -> Univ_Character is
        return '\0'
    end func First

    func Last() -> Univ_Character is
        return '\0' + 2**31-1
    end func Last
end class PSL::Core::Univ_Character
abstract interface PSL::Core::Imageable<> is
    func To_String(Val : Imageable) -> Univ_String<>

    func From_String(Str : Univ_String<>) -> optional Imageable

    // NOTE: We include Hashable<> operations here
    //       so that Set<Imageable+> works nicely.
    //       Clearly if something is Imageable it is possible
    //       to implement "=?" and Hash using the string image,
    //       so we might as well requires these operations too.

    op "=?"(Left, Right : Imageable) -> Ordering
    func Hash(Val : Imageable) -> Univ_Integer
end interface PSL::Core::Imageable
interface PSL::Containers::Packed_Array
  <Elem_Type is Countable<>; Indexed_By is Countable<>;
   Allow_Null : Boolean := #false> 
  implements Indexable<Elem_Type, Indexed_By> is
  // A packed array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
  // The element type must be countable, and only the range First()..Last()
  // need be represented.
  // If Allow_Null is #true, then one extra value per element is allowed
  // so that "null" can be represented (the "all ones" value is used for null).
  // In an instantiation, the Elem_Type should include "optional"
  // if Allow_Null is #true.

    const Bounds : Countable_Range<Indexed_By>

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : Elem_Type)
      -> Packed_Array

    func Length(Arr : Packed_Array) -> Univ_Integer
    op "magnitude"(Packed_Array) -> Univ_Integer is Length

    func Bounds(Arr : Packed_Array) -> Countable_Range<Indexed_By>
    func First(Arr : Packed_Array) -> Indexed_By is (Arr.Bounds().First)
    func Last(Arr : Packed_Array) -> Indexed_By is (Arr.Bounds().Last)

    interface Packed_Array_Ref<> is
        func Create(ref Arr : Packed_Array; Index : Indexed_By)
          -> ref Packed_Array_Ref
        op "ref"(ref Packed_Array_Ref) -> ref Elem_Type
        op "end"(var Packed_Array_Ref)
    end interface Packed_Array_Ref

    op "indexing"(Arr : Packed_Array; Index : Indexed_By)
      -> optional Elem_Type
    op "var_indexing"(ref var Arr : Packed_Array; Index : Indexed_By)
      -> ref var Packed_Array_Ref
    op "index_set"(Arr : Packed_Array) -> Countable_Range<Indexed_By>
    func Set(var Arr : Packed_Array; Index : Indexed_By; New_Val : Elem_Type)
    op "<|="(var Left : Packed_Array; var Right : Elem_Type)
    op "|"(Left : Packed_Array; Right : Key_Value<Indexed_By, Elem_Type>)
      -> Packed_Array
    op "[]"() -> Packed_Array
    func Dump()
end interface PSL::Containers::Packed_Array

class PSL::Containers::Packed_Array is
  // A packed array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
  // The element type must be countable, and only the range First()..Last()
  // need be represented.
  // If Allow_Null is #true, then one extra value per element is allowed
  // so that "null" can be represented (the "all ones" value is used for null).
  // In an instantiation, the Elem_Type should include "optional"
  // if Allow_Null is #true.
    const Word_Size := 62  // So as to avoid the null value of Univ_Integer
    func Num_Bits(Num_Vals : Univ_Integer) -> Univ_Integer is
        for (Bits in 1 .. Word_Size-1; Pow := 2 then Pow + Pow) forward loop
            if Pow >= Num_Vals then
                return Bits
            end if
        end loop
        return Word_Size
    end func Num_Bits

    type Word is Modular<2**Word_Size>

    //  TBD: the following causes order-of-eval problems:
    //    const Num_Elem_Vals := (Elem_Type::Last() - Elem_Type::First()) + 1
        
    func Num_Elem_Vals() -> Univ_Integer is
        //  Return number of values needed, including one for null if allowed.
        return (Elem_Type::Last() - Elem_Type::First()) + (Allow_Null? 2 : 1)
    end func Num_Elem_Vals

    const Bits_Per_Elem := Num_Bits (Num_Elem_Vals())
    const Elems_Per_Word := Word_Size / Bits_Per_Elem
    const Mask : Word := 2 ** Bits_Per_Elem - 1

    func Compute_Spreader() -> Result : Word is
      // Compute a value which when multiplied by the initial value
      // "spreads" it over the packed array
        Result := 0
        for (I in 1 .. Elems_Per_Word;
             One_Bit := 1 then One_Bit << Bits_Per_Elem) forward loop
           Result += One_Bit
        end loop
    end func Compute_Spreader

    const Spreader : Word := Compute_Spreader()

    type Word_Array is Basic_Array<Word>
    var Data : Word_Array

    func Nth_Elem(Arr : Packed_Array; Index : Indexed_By)
      -> optional Elem_Type is
        const Zero_Based_Index := Index - Arr.Bounds.First
        const Word_Index := Zero_Based_Index / Elems_Per_Word + 1
        const Word_Val := Arr.Data[ Word_Index ]
        const Val_Offset :=
           Mask and (Word_Val >>
             ((Zero_Based_Index rem Elems_Per_Word) * Bits_Per_Elem))
        if Allow_Null and then Val_Offset == Mask then
           return null
        else
           return Elem_Type::First() + Val_Offset
        end if
    end func Nth_Elem

  exports

    class Packed_Array_Ref is
        ref Arr : Packed_Array;
        const Index : Indexed_By;
        var Elem : Elem_Type;
      exports
        func Create(ref Arr : Packed_Array; Index : Indexed_By)
          -> ref Packed_Array_Ref is
            return (Arr, Index, Elem => Nth_Elem(Arr, Index))
        end func Create
        op "ref"(ref Packed_Array_Ref) -> ref Elem_Type is
            return Packed_Array_Ref.Elem
        end op "ref"
        op "end"(var Packed_Array_Ref) is
            Set(Packed_Array_Ref.Arr, Packed_Array_Ref.Index,
              New_Val => Packed_Array_Ref.Elem)
        end op "end"
    end class Packed_Array_Ref

    func Dump() is
        Println ("Bits_Per_Elem = " | Bits_Per_Elem)
        Println ("Elems_Per_Word = " | Elems_Per_Word)
        Println ("Mask = " | Mask)
    end func Dump

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : Elem_Type)
      -> Result : Packed_Array is
        const Num_Words :=
          (Length(Bounds) + Elems_Per_Word - 1) / Elems_Per_Word
        const Adjusted_Val := Initial_Value is null?
                                Mask : Initial_Value - Elem_Type::First()
        return (Data => Create(Num_Words, Adjusted_Val * Spreader),
          Bounds => Bounds)
    end func Create

    func Length(Arr : Packed_Array) -> Univ_Integer is
        return Length(Arr.Bounds)
    end func Length

    func Bounds(Arr : Packed_Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end func Bounds

    op "indexing"(Arr : Packed_Array; Index : Indexed_By)
      -> optional Elem_Type is (Nth_Elem(Arr, Index))

    op "var_indexing"(ref var Arr : Packed_Array; Index : Indexed_By)
      -> ref var Packed_Array_Ref is
        if Index not in Arr.Bounds then
           //  Need to extend the array
           Set (Arr, Index, Allow_Null? null: Elem_Type::First())
        end if
        return Create(Arr, Index)
    end op "var_indexing"

    op "index_set"(Arr : Packed_Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end op "index_set"

    func Set(var Arr : Packed_Array; Index : Indexed_By; New_Val : Elem_Type) is
        if |Arr.Bounds| == 0 then
            // First element in array
            Arr := Create (Index .. Index, New_Val);
            return
        end if

        if Index < Arr.Bounds.First then
            //  Extending low bound (ugh)
            var Old_Arr <== Arr;
            //  Create a new array, and copy old values over
            Arr := Create (Index .. Old_Arr.Bounds.Last, New_Val);
            for each [I => E] of Old_Arr loop
                Arr[I] := Old_Arr[I]
            end loop
            Old_Arr := null
            return
        end if

        if Index > Arr.Bounds.Last then
            //  Extending high bound
            Arr := (Data <== Arr.Data,
                    Bounds => (First => Arr.Bounds.First, Last => Index))
        end if
        const Zero_Based_Index := Index - Arr.Bounds.First
        const Word_Index := Zero_Based_Index / Elems_Per_Word + 1
        if Word_Index > |Arr.Data| then
            // Need to extend the the word array
            Arr.Data[ Word_Index ] := (Allow_Null? Mask * Spreader: 0)
        end if
        const Elem_Loc :=
          (Zero_Based_Index rem Elems_Per_Word) * Bits_Per_Elem
        const Adjusted_Val := (New_Val is null?
          Mask : New_Val - Elem_Type::First()) << Elem_Loc
        const Elem_Mask := Mask << Elem_Loc
        Arr.Data[ Word_Index ] := (Arr.Data[ Word_Index ] and not Elem_Mask) or
          Adjusted_Val
    end func Set

    op "<|="(var Left : Packed_Array; var Right : Elem_Type) is
        // Add Right onto Array
        if Length(Left) == 0 then
            Left := (Data => Create(1, 0),
              Bounds => Indexed_By::First() .. Indexed_By::First())
            Set (Left, Indexed_By::First(), Right)
        else
            Set (Left, Left.Bounds.Last + 1, Right)
        end if
    end op "<|="
    
    op "|"(Left : Packed_Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Packed_Array is
        Result := Left
        Set (Result, Right.Key, Right.Value)
    end op "|"

    op "[]"() -> Result : Packed_Array is
        return (Data => Create(0, 0),
          Bounds => Indexed_By::First()+1 .. Indexed_By::First())
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Packed_Array

func PSL::Test::Test_Packed() is
    type Color is Enum< [#red, #green, #blue] >
    type RCB is Packed_Array
      <optional Integer<Range => 0..0xFF>, Indexed_By => Color,
       Allow_Null => #true>

    RCB::Dump()

    const Red : RCB := [#red => 0x33, #green => 0, #blue => 0]
    const Blue : RCB := [#blue => 0x33, #green => 0, #red => 0]
    const Yellow : RCB := [#green => 0x33, #blue => 0x33, #red => 0] 
    const White : RCB := [0xFF, 0xFF, 0xFF]
    const Partial : RCB := [0xFF, 0xFF, null]
    
    const RCBs : Vector<RCB> := [Red, Blue, Yellow, White, Partial]
    const Names : Vector<Univ_String> :=
      ["Red", "Blue", "Yellow", "White", "Partial"]

    for each [I => C] of RCBs forward loop
        Println(Names[I] | " = [#red => " | C[#red] |
          ", #green => " | C[#green] | ", #blue => " | C[#blue] | "]")
    end loop

    var Arr : RCB := Create(#red .. #blue, 0x77)
    Print("Arr = ")
    for (each [I => X] of Arr; Sep := "[" then ", ") forward loop
        Print(Sep | I | " => " | X)
    end loop
    Println("]")

    Println ("About to update Arr[#green] with 0x33 (= " | 0x33 | ")")
    block
        ref Green_Elem => Arr[#green]
        Green_Elem := 0x32
        Green_Elem += 1

        //  "end"(Green_Elem) should be invoked here
    end block

    Println ("About to update Arr[#blue] with 0x55 (= " | 0x55 | ")")

    Arr[#blue] := 0x22
    //  "end"(Arr[#blue]) should be invoked here

    //  Arr[#blue] := Arr[#blue] * 5
    Arr[#blue] *= 5
    //  "end"(Arr[#blue]) should be invoked here

    Arr[#blue] := Arr[#blue] / 2
    //  "end"(Arr[#blue]) should be invoked here

    Print("Arr now = ")
    for (each [I => X] of Arr; Sep := "[" then ", ") forward loop
        Print(Sep | I | " => " | X)
    end loop
    Println("]")

    const RR : RCB :=
      [#red => Arr[#green],
       #green => "var_indexing"(Arr, #blue),  //  "end" invoked here
       #blue => Arr[#red]]
    Print("RR = ")
    for (each [I => X] of RR; Sep := "[" then ", ") forward loop
        Print(Sep | I | " => " | X)
    end loop
    Println("]")

    var VV : Vector<Univ_Integer> := [3, Arr[#green], Arr[#red] / 5]
    VV := VV | [7, Arr[#blue]]
    Print("VV = ")
    for (each Z of VV; Sep := "[" then ", ") forward loop
        Print (Sep | Z)
    end loop
    Println("]")
    
end func PSL::Test::Test_Packed

interface PSL::Core::Univ_String<> is
    func Print(Univ_String) is import(#print_string)
    func Println(Univ_String) is import(#println_string)
    func Readln() -> optional Univ_String is import(#read_string)

    op "*"(Left : Univ_Integer; Right : Univ_String) -> Univ_String
        // Produce specified number of "Right" strings in a row
    op "*"(Left : Univ_String; Right : Univ_Integer) -> Univ_String
        // Produce specified number of "Left" strings in a row

    op "|"(Left, Right : Univ_String) -> Univ_String 
      is import(#concat_string)

    op "=?"(Left, Right : Univ_String) -> Ordering
      is import(#string_compare)

    op "|="(var Left : Univ_String; Right : Univ_String)
      is import(#assign_concat_string)

    op "indexing"(Str : Univ_String; Index : Univ_Integer<>) -> Univ_Character
      is import(#string_indexing)
        // a "read-only" element, indexed 1 .. |Str|

    op "index_set"(Str : Univ_String) -> Countable_Range<Univ_Integer>
        // Return set of indices for string

    op "slicing"(Str : Univ_String;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> Univ_String is import(#string_slicing)
        // a "read-only" slice

    func Length(Str : Univ_String) -> Univ_Integer
      is import(#string_length)

    op "magnitude"(Univ_String) -> Univ_Integer
      is import(#string_length)

    func Hash(Val : Univ_String) -> Univ_Integer
      is import(#hash_string)

    op "|"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      -> Univ_String

    op "|"(Left : Left_Type is Imageable<>; Right : Univ_String)
      -> Univ_String

    op "|="(var Left : Univ_String; Right : Right_Type is Imageable<>)

    // Operations to convert to/from a Vector of Univ_Character's
    func To_Vector(Str : Univ_String) -> Vector<Univ_Character>
    func From_Vector(Vec : Vector<Univ_Character>) -> Univ_String

    func Replace(Orig : Univ_String;
      Char : Univ_Character; With : Univ_Character) -> Univ_String
    //  Replace each appearance of Char with "With"

    func Hex_Image(Val : optional Univ_Integer) -> Univ_String
      //  Return a base-16 image of Val

  implements for Imageable
    // These operations are needed so Univ_String satifies
    // requirements of "Imageable" interface, but these
    // operations are not directly callable, to avoid ambiguities.

    func To_String(Val : Univ_String) -> Univ_String
      is import (#identity)
    func From_String(Str : Univ_String) -> optional Univ_String
      is import (#identity)

end interface PSL::Core::Univ_String
    
class PSL::Core::Univ_String is
  exports
    op "index_set"(Str : Univ_String) -> Countable_Range<Univ_Integer> is
        // Return set of indices for string
        return 1..|Str|
    end op "index_set"

    op "*"(Left : Univ_Integer; Right : Univ_String) -> Univ_String is
        // Produce specified number of "Right" strings in a row
        if Left <= 0 then
            return ""
        elsif Left == 1 then
            return Right
        else
            // Recurse to produce half-length, and then combine
            const Partial : Univ_String := (Left/2) * Right
            if Left mod 2 == 1 then
                return Partial | Partial | Right
            else
                return Partial | Partial
            end if
        end if
    end op "*"

    op "*"(Left : Univ_String; Right : Univ_Integer) -> Univ_String is
        // Produce specified number of "Left" strings in a row
        return Right * Left   // Just pass the buck to other "*"
    end op "*"

    op "|"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      -> Univ_String is
        if Right is null then
            return Left | "null"
        else
            return Left | Right_Type::To_String(Right)
        end if
    end op "|"

    op "|"(Left : Left_Type is Imageable<>; Right : Univ_String)
      -> Univ_String is
        if Left is null then
            return "null" | Right
        else
            return Left_Type::To_String(Left) | Right
        end if
    end op "|"

    op "|="(var Left : Univ_String; Right : Right_Type is Imageable<>) is
        if Right is null then
            Left |= "null"
        else
            Left |= Right_Type::To_String(Right)
        end if
    end op "|="

    func To_Vector(Str : Univ_String) -> Vector<Univ_Character> is
        return [for I in 1 .. |Str| => Str[I]]
    end func To_Vector

    func From_Vector(Vec : Vector<Univ_Character>) -> Univ_String is
        var Result := "";
        for each C of Vec forward loop
            Result |= C;
        end loop;
        return Result;
    end func From_Vector;

    func Replace(Orig : Univ_String;
      Char : Univ_Character; With : Univ_Character) -> Result : Univ_String is
    //  Replace each appearance of Char with "With"

       Result := ""

       var Prev_Match := 0
       for each [I => C] of Orig forward loop
          //  Look for a match
          if C == Char then
             // Concatenate on unchanged part and replacement character
             Result |= Orig[Prev_Match <..< I] | With
             Prev_Match := I;
          end if
       end loop

       if Prev_Match == 0 then
          Result := Orig
       elsif Prev_Match < |Orig| then
          Result |= Orig[Prev_Match <.. |Orig|]
       end if
    end func Replace

    func Hex_Image(Val : optional Univ_Integer) -> Univ_String is
       const Word_Size := 64
       const Max_Digits := Word_Size / 4
       if Val is null then
          return '8' | ((Max_Digits-1)*'0')
       elsif Val == 0 then
          return "0"
       else
          var Vec : Vector<Univ_Character> := Create(Max_Digits, ' ')
          for (V := Val while V != 0;
               Index in 1..Max_Digits reverse)
          loop
             const Digit := V mod 16
             if Digit >= 10 then
                Vec[Index] := 'A' + (Digit-10)
             else
                Vec[Index] := '0' + Digit
             end if
    
             if V == Digit then
                return From_Vector(Vec[Index .. Max_Digits])
             else
                continue loop with V => (V - Digit) / 16
             end if
          end loop
          return From_Vector(Vec)
       end if
    end func Hex_Image
    
end class PSL::Core::Univ_String

func PSL::Test::Test_String() is
    const U := "tab\t"
    const T := U[4]
    Println("U = " | U | ", |U| = " | |U| | ", U[4] = '" | T | "'")
    const X := "this is a string"
    const Y := X[3]
    {Y == 'i'} // string indexing problem
    const Z := X[6..7]
    {Z == "is"} // string slicing problem, expected 'is', found Z 
    Println("X = " | X | ", X[3] = " | Y | ", X[6..7] = " | Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " | "hello")

    const Seven_Xs := "x" * 7
    {Seven_Xs == "xxxxxxx"} // Char multiplication check

    Println("Here are seven x's: " | Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)

    Println("About to iterate over '" | X | "'")
    for each C of X forward loop
        Print(" " | C)
    end loop
    Println("")

    Println("X.Replace('s', With => 'x') = " | X.Replace('s', With => 'x'))
end func PSL::Test::Test_String
interface PSL::Core::Random<> is
    func Start(Seed : Univ_Integer := 1) -> Random
      // Start a new random number sequence with a standard multiplier/modulus

    func Start(Seed : Univ_Integer;
       Mult, Mod : Univ_Integer) -> Random
      // Start a new random number sequence with given multiplier and modulus

    func Next(var Seq : Random) -> Univ_Integer
      // Get next value in random number sequence

    func Next_Real(var Seq : Random) -> Univ_Real
      // Get next Univ_Real value in random number sequence,
      // in range 0.0 ..< 1.0
end interface PSL::Core::Random

class PSL::Core::Random is
    var Last_Value : Univ_Integer
    const Mult : Univ_Integer
    const Mod : Univ_Integer
    const Debugging : Boolean := #false
exports  // check that indent of 0 works
    func Start(Seed : Univ_Integer) -> Random is
      // Start a new random number sequence with a standard multiplier/modulus
        return (Last_Value => Seed,
          Mult => 7**5, Mod => 2**31 - 1)
    end func Start

    func Start(Seed : Univ_Integer;
      Mult, Mod : Univ_Integer) -> Random is
      // Start a new random number sequence with given multiplier and modulus
        if Debugging then
            Println("Random: Seed = " | Seed | ", Mult = " | Mult | 
              ", Mod = " | Mod)
        end if

        //  We want the multiplier to be less than the Modulus,
        //  and no less than 2
        {> Mult in 2 ..< Mod <}

        return (Last_Value => Seed, Mult => Mult, Mod => Mod)
    end func Start

    func Next(var Seq : Random) -> Result : Univ_Integer is
      // Get next value in random number sequence
        Result := Seq.Last_Value * Seq.Mult mod Seq.Mod
        if Result == 0 then
            --  Oh dear, we hit zero, return one instead
            Result := 1
        end if
        Seq.Last_Value := Result;
    end func Next

    func Next_Real(var Seq : Random) -> Univ_Real is
      // Get next Univ_Real value in random number sequence,
      // in range 0.0 ..< 1.0
        return (Int_To_Real (Next(Seq)) - 1.0) / Int_To_Real (Seq.Mod - 1)
    end func Next_Real
end class PSL::Core::Random
abstract interface PSL::Core::Sequence<Element_Type is Assignable<>> is
    func Remove_First(var S : Sequence) -> optional Element_Type
      // Returns null when sequence is empty
end interface PSL::Core::Sequence
interface PSL::Core::Direction<> is
    // This is passed to the "to_sequence" operator to generate
    // appropriate direction of sequence
    op "from_univ"(Lit : Univ_Enumeration)
      {Lit in #unordered | #forward | #reverse | #concurrent} -> Direction 
      is import(#direction_from_univ)

    op "to_univ"(Val : Direction) -> Univ_Enumeration 
      is import(#direction_to_univ)

    op "=?"(Left, Right : Direction) -> Ordering
      is import("=?")
end interface PSL::Core::Direction
interface PSL::Core::Integer
  <Range : Countable_Range<Univ_Integer> := -2**62 .. +2**62> is
    // NOTE: We restrict Integer to this range so Univ_Integer can use
    //       values outside this range as indices into an extended-range
    //       integer table.
    op "from_univ"(Lit : Univ_Integer) -> Integer 
      is import(#integer_from_univ)

    op "to_univ"(Val : Integer) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Integer) -> Integer
      is import(#identity)

    op "-"(Right : Integer) -> Integer
      is import(#negate)

    op "abs"(Right : Integer) -> Integer
      is import("abs")

    op "magnitude"(Integer) -> Integer is "abs"

    op "+"(Left, Right : Integer) -> Result : Integer 
      is import("+")

    op "-"(Left, Right : Integer) -> Result : Integer
      is import("-")

    op "*"(Left, Right : Integer) -> Result : Integer 
      is import("*")

    op "/"(Left, Right : Integer) -> Result : Integer
      is import("/")

    op "mod"(Left, Right : Integer) -> Integer
      is import("mod")

    op "rem"(Left, Right : Integer) -> Integer
      is import("rem")

    op "**"(Left, Right : Integer) -> Result : Integer
      is import("**")

    op "+="(var Left : Integer; Right : Integer) 
      is import("+=")

    op "-="(var Left : Integer; Right : Integer) 
      is import("-=")

    op "*="(var Left : Integer; Right : Integer) 
      is import("*=")

    op "/="(var Left : Integer; Right : Integer) 
      is import("/=")

    op "**="(var Left : Integer; Right : Integer) 
      is import("**=")

    op "=?"(Left, Right : Integer) -> Ordering
      is import("=?")

    op ">>"(Integer; Integer) -> Integer is import(">>")

    op "<<"(Integer; Integer) -> Integer is import("<<")

    func Min(Left, Right : optional Integer) -> optional Integer
      is import(#min)
    func Max(Left, Right : optional Integer) -> optional Integer
      is import(#max)

    func Hash(Val : Integer) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Integer) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Integer
      is import(#from_string_int)

    func Print(X : Integer) is import(#print_int)
    func Println(X : Integer) is (Println(To_String(X)))

    func First() -> Integer

    func Last() -> Integer

    op "[..]"()->Countable_Range<Integer> is in Countable_Range<Integer>

    op ".."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "<.."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "<..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "|"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
  implements for Countable
    // These operations are needed so Integer satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an integer to an int-literal).

    op "+"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("+")

    op "+"(Left : Univ_Integer; Right : Integer) -> Result : Integer 
      is import("+")

    op "-"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("-")

    op "-"(Left, Right : Integer) -> Result : Univ_Integer
      is import("-")

end interface PSL::Core::Integer

class PSL::Core::Integer is
    const Content : Univ_Integer;  // So this ends up as a wrapper
  exports
    func First() -> Integer is
        return Range.First
    end func First

    func Last() -> Integer is
        return Range.Last
    end func Last

end class PSL::Core::Integer
interface PSL::Core::List<List_Elem is Assignable<>> is
    var Elem : List_Elem
    var Next : optional List

    op "|"(Left : List_Elem; Right : List_Elem) -> List
    op "|"(Left : List_Elem; Right : List) -> List
    op "|"(Left : List; Right : List) -> List
    op "|"(Left : List; Right : List_Elem) -> List

    op "|="(var Left : List; Right : List)
    op "|="(var Left : List; Right : List_Elem)
    func Length(L : optional List) -> Univ_Integer
    op "magnitude"(L : optional List) -> Univ_Integer is Length

    op "[]"() -> optional List is (null)

    func Remove_First(var L : List) -> optional List_Elem
    func Remove_Last(var L : List) -> optional List_Elem
    func Remove_Any(var L : List) -> optional List_Elem
end interface PSL::Core::List

class PSL::Core::List is
  exports
    op "|"(Left : List_Elem; Right : List_Elem) -> List is
        return (Elem => Left, Next => (Elem => Right, Next => null))
    end op "|"

    op "|"(Left : List_Elem; Right : List) -> List is
        return (Elem => Left, Next => Right)
    end op "|"

    op "|"(Left : List; Right : List) -> List is
        if Left is null then
            // Left is null, so just return Right
            return Right
        else
            // Recurse with tail of left Basic_list
            return (Elem => Left.Elem, Next => Left.Next | Right)
        end if
    end op "|"

    op "|"(Left : List; Right : List_Elem) -> List is
        return Left | (Elem => Right, Next => null)
    end op "|"

    op "|="(var Left : List; Right : List) is
        if Left is null then
            Left := Right
        else
            // Recurse with tail of Basic_list
            Left.Next |= Right
        end if
    end op "|="

    op "|="(var Left : List; Right : List_Elem) is
        // Just pass the buck
        Left |= (Elem => Right, Next => null)
    end op "|="

    func Length(L : optional List) -> Result : Univ_Integer is
        Result := 0
        for Lst := L then Lst.Next while Lst not null loop
            Result += 1
        end loop
    end func Length

    func Remove_First(var L : List) 
      -> Result : optional List_Elem is
        if L is null then
            return null
        else
            Result := L.Elem
            L <== L.Next
              // carve off L.Next and set L to that
        end if
    end func Remove_First

    func Remove_Last(var L : List) 
      -> Result : optional List_Elem is
        if L is null then
            return null
        elsif L.Next is null then
            Result := L.Elem
            L := null
        else
            // Recurse to remove last element
            return Remove_Last(L.Next)
        end if
    end func Remove_Last

    func Remove_Any(var L : List) 
      -> Result : optional List_Elem is
        // Easiest to remove first element
        return Remove_First(L)
    end func Remove_Any

end class PSL::Core::List
func PSL::Test::Test_List(X, Y : Univ_Integer) is
    type Univ_List is List<Univ_Integer>

    func Println(L : Univ_List) is
        // Print a univ Basic_list
        var N := L
        while N not null loop
            const E : Univ_Integer := N.Elem
            Print(E)
            N := N.Next
            if N not null then
                Print(", ")
            end if
        end loop

        Print("\n")
    end func Println

    func Println_It(L : Univ_List) is
        // Print a univ Basic_list using destructive iterator
        Print("Forward: ")
        var F := L
        while F not null loop
            const E : Univ_Integer := Remove_First(F)
            Print(E)
            if F not null then
                Print(", ")
            end if
        end loop

        Print("\n")

        Print("Reverse: ")
        var R := L
        while R not null loop
            const Z : Univ_Integer := Remove_Last(R)
            Print(Z)
            if R not null then
                Print(", ")
            end if
        end loop

        Print("\n")
    end func Println_It

    var L1 : Univ_List := (Elem => X, Next => null)
    var L2 : Univ_List := (Elem => Y, Next => null)
    var L3 := L1 | L2

    Print("X = "); Println(X)
    Print("Y = "); Println(Y)
    Println("Combining " | X | " and " | Y | " produces ")
    Println(L3)
    Println("Combining X | Y | X | X | Y | Y produces ")
    Println_It(L3 | X | L3 | Y)
end func PSL::Test::Test_List
interface PSL::Core::Closed_Interval<Bound_Type is Comparable<>> is
    // This provides a simple "closed" interval X..Y
    // If a type is countable, then half-open or fully open intervals
    // can be converted into the equivalent closed interval.
    var Low : Bound_Type
    var High : Bound_Type
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean
    op "=?"(Left, Right : Closed_Interval) -> Ordering
end interface PSL::Core::Closed_Interval

class PSL::Core::Closed_Interval is
  exports
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean is
        return Left >= Right.Low and then Left <= Right.High
    end op "in"

    op "=?"(Left, Right : Closed_Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.

        if Left.High < Right.Low then
            return #less
        elsif Left.Low > Right.High then
            return #greater
        elsif Left.Low == Right.Low and then
          Left.High == Right.High then
            return #equal
        else
            return #unordered
        end if
    end op "=?"
end class PSL::Core::Closed_Interval
interface PSL::Core::Interval<Bound_Type is Comparable<>> is
    // This supports closed, half-open, and open intervals.
    // This is appropriate for uncountable types where you
    // can't normalize all intervals into closed intervals.
    var Low : Bound_Type
    var Low_Is_Open : Boolean
    var High : Bound_Type
    var High_Is_Open : Boolean

    func Singleton(Val : Bound_Type) -> Interval
      // Return interval consisting of a single value

    func Is_Empty(IV : optional Interval) -> Boolean
      // Return True if interval is null or it represents
      // no values

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean

    op "=?"(Left, Right : Interval) -> Ordering
      // "#greater" means Left is strictly greater than Right
      // "#less" means Left is strictly less than Right
      // "#equal" means Left and Right are the same interval
      // "#unordered" means anything else

    op "and"(Left, Right : Interval) -> optional Interval
      // Return intersection of the two intervals

    op "and="(var Left : optional Interval; Right : Interval)
      // Intersect Right into Left

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> optional Interval
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)}
      // Subtract Right interval from Left

    func Overlaps(Left, Right : optional Interval) -> Boolean
      // Return True if intervals overlap

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval is "or"

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)}
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is "or="

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)}
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.

end interface PSL::Core::Interval

class PSL::Core::Interval is
  exports
    func Singleton(Val : Bound_Type) -> Interval is
      // Return interval consisting of a single value
        return (Low => Val, Low_Is_Open => #false,
          High => Val, High_Is_Open => #false)
    end func Singleton

    func Is_Empty(IV : optional Interval) -> Boolean is
      // Return True if interval is null or it represents
      // no values
        return IV is null or else
          IV.Low > IV.High or else
          (IV.Low == IV.High and then (IV.Low_Is_Open or IV.High_Is_Open))
    end func Is_Empty

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean is
        case Left =? Right.Low of
          [#less] => return #false
          [#equal] => return not Right.Low_Is_Open
          [#greater] =>
            case Left =? Right.High of
              [#less] => return #true
              [#equal] => return not Right.High_Is_Open
              [#greater] => return #false
            end case
        end case
    end op "in"

    op "=?"(Left, Right : Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.
        // Return #unordered if any of the comparisons return #unordered.

        // First check for perfect equality
        if Left.Low == Right.Low and then
          Left.High == Right.High and then
          Left.Low_Is_Open == Right.Low_Is_Open and then
          Left.High_Is_Open == Right.High_Is_Open then
            // NOTE: We are considering X..Y-1 != X..<Y since
            //       we don't require countable elements.
            return #equal
        end if

        case Left.High =? Right.Low of
          [#unordered] =>
            return #unordered
          [#less] =>
            return #less
          [#equal] =>
            if Left.High_Is_Open or else Right.Low_Is_Open then
                // No overlap
                return #less
            else
                // We have already ruled out #equal
                return #unordered
            end if
          [#greater] =>
            // Not clearly less, see whether clearly greater.
            case Left.Low =? Right.High of
              [#unordered] =>
                return #unordered
              [#less] =>
                // We have already ruled out #equal
                return #unordered
              [#equal] =>
                if Left.Low_Is_Open or else Right.High_Is_Open then
                    // No overlap
                    return #greater
                else
                    // We have already ruled out #equal
                    return #unordered
                end if
              [#greater] =>
                return #greater
            end case
        end case
    end op "=?"

    op "and"(Left, Right : Interval) -> optional Interval is
      // Return intersection of the two intervals
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
        
        case Left.Low =? Right.Low of
          [#less] => 
            New_Low := Right.Low
            New_Low_Is_Open := Right.Low_Is_Open
          [#greater] => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open
          [#equal] => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open or Right.Low_Is_Open
          [#unordered] => 
            return null
        end case

        case Left.High =? Right.High of
          [#less] => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open
          [#greater] => 
            New_High := Right.High
            New_High_Is_Open := Right.High_Is_Open
          [#equal] => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open or Right.High_Is_Open
          [#unordered] => 
            return null
        end case

        return (Low => New_Low, Low_Is_Open => New_Low_Is_Open,
          High => New_High, High_Is_Open => New_High_Is_Open)
    end op "and"

    op "and="(var Left : optional Interval; Right : Interval) is
      // Intersect Right into Left
        if Left not null then
            Left := Left and Right
        end if
    end op "and="

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean is
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.
        if Right is null or else Left is null then
            return #false
        end if
        return (Left.Low > Right.Low or else 
          (Left.Low == Right.Low and then Left.Low_Is_Open > Right.Low_Is_Open))
          and then
            (Left.High < Right.High or else
             (Left.High == Right.High and then 
              Left.High_Is_Open > Right.High_Is_Open))
    end func Is_Strictly_Within

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> Result : optional Interval is
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
        
        case Left.Low =? Right.Low of
          [#less] => 
            // Return left part of Left
            Result := (Low => Left.Low, Low_Is_Open => Left.Low_Is_Open,
              High => Right.Low, High_Is_Open => not Right.Low_Is_Open)
          [#greater] => 
            // Return right part of Left
            Result := (Low => Right.High, Low_Is_Open => not Right.High_Is_Open,
              High => Left.High, High_Is_Open => Left.High_Is_Open)
          [#equal] => 
            if Left.Low_Is_Open >= Right.Low_Is_Open then
                // Return right part of Left
                Result := (Low => Right.High, 
                  Low_Is_Open => not Right.High_Is_Open,
                  High => Left.High, 
                  High_Is_Open => Left.High_Is_Open)
            else
                // Only one element is left
                return (Left.Low, #false, Left.Low, #false)
            end if
          [#unordered] => 
            return null
        end case

        if Result.Low > Result.High then
            // Empty interval
            return null
        elsif Result.Low == Result.High and then
          (Result.Low_Is_Open or Result.High_Is_Open) then
            // Empty interval
            return null
        else
            return Result
        end if
    end op "-"

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)} is
      // Subtract Right interval from Left
        if Left not null then
            Left := Left - Right
        end if
    end op "-="

    func Overlaps(Left, Right : optional Interval) -> Boolean is
        if Left is null or else Right is null then
            return #false
        else
            case Left =? Right of
              [#equal | #unordered] => return #true
              [#less | #greater] => return #false
            end case
        end if
    end func Overlaps

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} 
      -> Result : Interval is
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
        
        Result := Left
        Result or= Right
    end op "or"

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end op "or="

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)} is
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.
        if Left is null then
            Left <== Right
        elsif Right not null then
            var Right_Copy <== Right
                // Make copy and null out Right, so
                // we don't end up with Right partially nulled out
            
            case Left.Low =? Right_Copy.Low of
              [#less] => 
                // No change to Left.Low
                null
              [#greater] => 
                Left.Low <== Right_Copy.Low
                Left.Low_Is_Open := Right_Copy.Low_Is_Open
              [#equal] => 
                Left.Low_Is_Open and= Right_Copy.Low_Is_Open
            end case

            case Left.High =? Right_Copy.High of
              [#less] => 
                Left.High <== Right_Copy.High
                Left.High_Is_Open := Right_Copy.High_Is_Open
              [#greater] => 
                // No change to Left.High
                null
              [#equal] => 
                Left.High_Is_Open and= Right_Copy.High_Is_Open
            end case
        end if
    end op "<|="

end class PSL::Core::Interval

func PSL::Test::Test_Interval(X, Y, Z : Univ_Integer) is
    var Y_Up_To_Z : Interval<Univ_Integer> := 
      (Low => Y, Low_Is_Open => #false, High => Z, High_Is_Open => #true)

    Println(X | " in " | Y | "..<" | Z | " = " | (X in Y_Up_To_Z))

    var Y_To_Z : Closed_Interval<Univ_Integer> := (Low => Y, High => Z)

    Println(X | " in " | Y | ".." | Z | " = " | (X in Y_To_Z))

    var One_To_X : Closed_Interval<Univ_Integer> :=
      (Low => 1, High => X)

    Println(1 | ".." | X | "=?" | Y | ".." | Z | " = " | 
      (One_To_X =? Y_To_Z))

end func PSL::Test::Test_Interval
interface PSL::Core::AA_Tree<Element is Comparable<>> is

    // This module implements a balanced "AA" tree, originally
    // described by Arne Andersson in the "Proceedings of the Workshop
    // on Algorithms and Data Structures," pp 60-71, Springer Verlag, 1993.
    // The following algorithm and descriptions were taken from the
    // WikiPedia article on AA_Tree: 
    //       http://en.wikipedia.org/wiki/AA_tree
    // Note that various additional checks for a null tree have been added.

    // Only two operations are needed for maintaining balance in an AA tree.
    // These operations are called skew and split. Skew is a right rotation
    // when an insertion or deletion creates a left horizontal link. Split
    // is a conditional left rotation when an insertion or deletion creates two
    // horizontal right links, which once again corresponds to two
    // consecutive red links in red-black trees.

    op "[]"() -> optional AA_Tree
        // Create an empty tree

    func Insert(var T : optional AA_Tree; X : Element)
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

    func Delete(var T : optional AA_Tree; X : Element)
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

    op "in"(X : Element; T : optional AA_Tree) -> Boolean

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.

    op "|="(var T : optional AA_Tree; X : Element) is Insert

    op "<|="(var T : optional AA_Tree; var X : optional Element)
        // Move X into AA_Tree, leaving X null.

    func First(T : optional AA_Tree) -> optional Element
      // Return first (smallest) element in tree

    func Last(T : optional AA_Tree) -> optional Element
      // Return last (greatest) element in tree

    func Any_Element(T : optional AA_Tree) -> optional Element
      // Return an arbitrary element of tree

    func Remove_First(var T : optional AA_Tree) -> optional Element
      // Remove first (smallest) element in tree

    func Remove_Last(var T : optional AA_Tree) -> optional Element
      // Remove last (greatest) element in tree

    func Remove_Any(var T : optional AA_Tree) -> optional Element
      // Remove some element from tree

    func Count(T : optional AA_Tree) -> Univ_Integer
      // Return a count of the nodes in the tree

    op "magnitude"(AA_Tree) -> Univ_Integer is Count

    func Is_Empty(T : optional AA_Tree) -> Boolean
      // Return True if the tree is empty

    func Unsafe_Indexing(ref T : AA_Tree; X : Element) {X in T} -> ref Element
        // This is an unsafe operation, as it can destroy the integrity of the
        // tree.  If the object referred to by the result is altered, its new
        // value should compare #equal to the input X.  Otherwise, bad things
        // will happen.

end interface PSL::Core::AA_Tree

class PSL::Core::AA_Tree is
    var Value : Element
    var Level : Univ_Integer := 0
    var Left : optional AA_Tree
    var Right : optional AA_Tree

    func Node(var Value : optional Element; Level : Univ_Integer;
      Left, Right : optional AA_Tree) -> AA_Tree is
        // Create a new tree; move Value into it.
        return (Value <== Value, Level => Level, Left => Left, Right => Right)
    end func Node

    func Is_Leaf(T : optional AA_Tree) -> Boolean is
        return T not null and then
          T.Left is null and then T.Right is null
    end func Is_Leaf

    func Leftmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for L => T loop
            if L not null and then L.Left not null then
                // Continue with Left until we reach null
                continue loop with L => L.Left
            else
                // Found left-most
                return L
            end if
        end loop
    end func Leftmost

    func Successor(T : optional AA_Tree) -> optional Element is
        // Return element in tree greater than but closest to T.Value
        if T.Right not null then
            const Succ := Leftmost(T.Right)
            {Succ not null}
            return Succ.Value
        else
            return null
        end if
    end func Successor

    func Rightmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for R => T loop
            if R not null and then R.Right not null then
                // Keep following down Right side
                continue loop with R => R.Right
            else
                // Found right-most
                return R
            end if
        end loop
    end func Rightmost

    func Predecessor(T : optional AA_Tree) -> optional Element is
        // Return element in tree less than but closest to T.Value
        if T.Left not null then
            return Rightmost(T.Left).Value
        else
            return null
        end if
    end func Predecessor

    func Skew(var T : optional AA_Tree) is
      // input: T, a node representing an AA tree that needs to be rebalanced.
      // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Left not null and then
          T.Left.Level == T.Level then
            // The current T.Left becomes new root

            // Exchange value of T.Left with root
            T.Value <=> T.Left.Value
           
            // Move old root and T.Left.Right over to right side of tree
            T.Left.Right <=> T.Right
            T.Left.Left <=> T.Right
            T.Left <=> T.Right
        end if
    end func Skew

    func Split(var T : optional AA_Tree) is
        // input: T, a node representing an AA tree that needs to be rebalanced.
        // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Right not null and then
          T.Right.Right not null and then
          T.Level == T.Right.Right.Level then
            // T.Right becomes the new root
            // Exchange value and level between root and T.Right
            T.Value <=> T.Right.Value
            T.Level <=> T.Right.Level

            // Move old root and T.Right.Left to left side of tree
            T.Left <=> T.Right.Right
            T.Right.Left <=> T.Right.Right
            T.Left <=> T.Right

            // Increment level
            T.Level += 1
        end if
    end func Split

    func Decrease_Level(var T : optional AA_Tree) is
        // input: T, a tree for which we want to remove links that skip levels.
        // output: T with its level decreased.

        if T is null then
            return
        end if
           
        var Should_Be : Univ_Integer := 1

        if T.Left not null then
            Should_Be := T.Left.Level + 1
        end if

        if T.Right not null then
            Should_Be := Min(Should_Be, T.Right.Level + 1)
        end if
            
        if Should_Be < T.Level then
            T.Level := Should_Be
            if T.Right not null and then
              Should_Be < T.Right.Level then
                T.Right.Level := Should_Be
            end if
        end if
    end func Decrease_Level

  exports

    op "[]"() -> optional AA_Tree is
        // Create an empty tree
        return null
    end op "[]"

    // Insertion begins with the normal binary tree search and insertion
    // procedure. Then, as the call stack unwinds (assuming a recursive
    // implementation of the search), it's easy to check the validity of the
    // tree and perform any rotations as necessary. If a horizontal left link
    // arises, a skew will be performed, and if two horizontal right links
    // arise, a split will be performed, possibly incrementing the level of the
    // new root node of the current subtree. Note, in the code as given above,
    // the increment of T.Level. This makes it necessary to continue checking
    // the validity of the tree as the modifications bubble up from the leaves.
    
    op "<|="(var T : optional AA_Tree; var X : optional Element) is
        // Move X into AA_Tree, leaving X null.
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

        // Do the normal binary tree insertion procedure. 
        // Set the result of the recursive call to the correct 
        // child in case a new node was created or the
        // root of the subtree changes.

        if T is null then
            // Create a new leaf node with X.
            T := Node(X, 1, null, null)
            return
        end if

        case X =? T.Value of
          [#less] =>
            T.Left <|= X
          [#greater] =>
            T.Right <|= X
          [#equal | #unordered] =>
            // Note that the case of X == T.Value is unspecified. 
            // As given, an insert will have no effect. 
            // The implementor may desire different behavior.
            X := null
            return
        end case

        // Perform skew and then split. 
        // The conditionals that determine whether or
        // not a rotation will occur or not are inside 
        // of the procedures, as given above.

        Skew(T)
        Split(T)
    end op "<|="

    func Insert(var T : optional AA_Tree; X : Element) is
        // Just pass the buck to the "<|=" operation
        var X_Copy for T := X
        T <|= X_Copy
    end func Insert

    // As in most balanced binary trees, the deletion of an internal node can
    // be turned into the deletion of a leaf node by swapping the internal node
    // with either its closest predecessor or successor, depending on which are
    // in the tree or on the implementor's whims. Retrieving a predecessor is
    // simply a matter of following one left link and then all of the remaining
    // right links. Similarly, the successor can be found by going right once
    // and left until a null pointer is found. Because of the AA property of
    // all nodes of level greater than one having two children, the successor
    // or predecessor node will be in level 1, making their removal trivial.
    // 
    // To re-balance a tree, there are a few approaches. The one described by
    // Andersson in his original paper is the simplest, and it is described
    // here, although actual implementations may opt for a more optimized
    // approach. After a removal, the first step to maintaining tree validity
    // is to lower the level of any nodes whose children are two levels below
    // them, or who are missing children. Then, the entire level must be skewed
    // and split. This approach was favored, because when laid down
    // conceptually, it has three easily understood separate steps:
    // 
    //     Decrease the level, if appropriate.
    //     Skew the level.
    //     Split the level.
    // 
    // However, we have to skew and split the entire level this time instead of
    // just a node, complicating our code.

    func Delete(var T : optional AA_Tree; X : Element) is
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

        if T is null then
            // Not in tree -- should we complain?
            return
        end if

        case X =? T.Value of
          [#less] =>
            Delete(T.Left, X)
          [#greater] =>
            Delete(T.Right, X)
          [#equal] =>
            // If we're a leaf, easy, otherwise reduce to leaf case. 
            if Is_Leaf(T) then
                T := null
            elsif T.Left is null then
                // Get successor value and delete it from right tree,
                // and set root to have that value
                const Succ := Successor(T)
                Delete(T.Right, Succ)
                T.Value := Succ
            else
                // Get predecessor value and delete it from left tree,
                // and set root to have that value
                const Pred := Predecessor(T)
                Delete(T.Left, Pred)
                T.Value := Pred
            end if
          [#unordered] =>
            // Not in tree; should we complain?
            return
        end case

        // Rebalance the tree. Decrease the level of all nodes in this level if
        // necessary, and then skew and split all nodes in the new level.

        if T is null then
            return
        end if

        Decrease_Level(T)
        Skew(T)
        Skew(T.Right)
        if T.Right not null then
            Skew(T.Right.Right)
        end if
        Split(T)
        Split(T.Right)
    end func Delete

    op "in"(X : Element; T : optional AA_Tree) -> Result : Boolean is
        for P => T while P not null loop
            case X =? P.Value of
              [#less] =>
                continue loop with P => P.Left
              [#greater] =>
                continue loop with P => P.Right
              [#equal] =>
                return #true
              [#unordered] =>
                return #false
            end case
        end loop
        return #false   // Not found
    end op "in"

    func First(T : optional AA_Tree) -> optional Element is
      // Return first (smallest) element in tree
        if T is null then
            return null
        else 
            return Leftmost(T).Value
        end if
    end func First

    func Last(T : optional AA_Tree) -> optional Element is
      // Return last (greatest) element in tree
        if T is null then
            return null
        else
            return Rightmost(T).Value
        end if
    end func Last

    func Any_Element(T : optional AA_Tree) -> optional Element is
      // Return an arbitrary element of tree
        if T is null then
            return null
        end if
        return T.Value
    end func Any_Element

    func Remove_First(var T : optional AA_Tree) -> Result : optional Element is
      // Remove first (smallest) element in tree
        Result := First(T)
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_First

    func Remove_Last(var T : optional AA_Tree) -> Result : optional Element is
      // Remove last (greatest) element in tree
        Result := Last(T)
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Last

    func Remove_Any(var T : optional AA_Tree) -> Result : optional Element is
      // Remove some element from tree
        if T is null then
            return null
        end if
        Result := T.Value
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Any

    func Is_Empty(T : optional AA_Tree) -> Boolean is
      // Return True if the tree is empty
        return T is null
    end func Is_Empty

    func Count(T : optional AA_Tree) -> Univ_Integer is
      // Return a count of the nodes in the tree
        if T is null then
            return 0
        else
            return Count(T.Left) + Count(T.Right) + 1
        end if
    end func Count

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element is
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.
        if T is null or else T.Value is null then
            return null
        else
            case X =? T.Value of
              [#less] =>
                return Overlapping(T.Left, X)
              [#greater] =>
                return Overlapping(T.Right, X)
              [#equal | #unordered] =>
                // Close enough
                return T.Value
            end case
        end if
    end func Overlapping

    func Unsafe_Indexing(ref T : AA_Tree; X : Element) {X in T}
      -> ref Element is
        // This is an unsafe operation, as it can destroy the integrity of the
        // tree.  If the object referred to by the result is altered, its new
        // value should compare #equal to the input X.  Otherwise, bad things
        // will happen.

        {T not null and then T.Value not null}

        case X =? T.Value of
          [#less] =>
            return Unsafe_Indexing(T.Left, X)
          [#greater] =>
            return Unsafe_Indexing(T.Right, X)
          [#equal | #unordered] =>
            // Close enough
            return T.Value
        end case
        
    end func Unsafe_Indexing

end class PSL::Core::AA_Tree

func PSL::Test::Test_AA_Tree
  (A : Univ_Integer; B : Univ_Integer; C : Univ_Integer) is
    type Univ_Tree is AA_Tree<Univ_Integer>
    var T : Univ_Tree := []
    var X : Univ_Integer := A

    Insert(T, A)
    Println("Count = " | Count(T) | " after insert of " | A)
    Insert(T, B)
    Println("Count = " | Count(T) | " after insert of " | B)
    Insert(T, C)
    Println("Count = " | Count(T) | " after insert of " | C)

    Insert(T, A)
    Println("Count = " | Count(T) | " after another insert of " | A)

    Println(A | " in T = " | (A in T))
    Println(B | " in T = " | (B in T))
    Println(C | " in T = " | (C in T))
    Println("7 in T = " | (7 in T))

    for E := Remove_First(T) then Remove_First(T) while E not null loop
        Println("Remove_First = " | E)
    end loop

    Println("Count after loop : " | Count(T))

    for I in 1..10 forward loop
        Insert(T, I)
        Println("Count = " | Count(T) | " after insert of " | I)
    end loop

    for L := Remove_Last(T) then Remove_Last(T) while L not null loop
        Println("Remove_Last = " | L)
    end loop

    Println("Count after loop : " | Count(T))

    for J in 1..10 reverse loop
        Insert(T, J)
        Println("Count = " | Count(T) | " after insert of " | J)
    end loop

    Println("Count after loop : " | Count(T))

    Println("Overlapping(T, 5) = " | Overlapping(T, 5))

    for Z := Remove_Any(T) then Remove_Any(T) while Z not null loop
        Println("Remove_Any = " | Z)
    end loop

    Println("Count after loop : " | Count(T))

    for K in 1..10 loop
        Insert(T, K)
        Println("Count = " | Count(T) | " after insert of " | K)
    end loop

    for F := Remove_First(T) then Remove_First(T) while F not null loop
        Println("Remove_First = " | F)
    end loop

    Println("Count after loop : " | Count(T))

end func PSL::Test::Test_AA_Tree
abstract interface PSL::Containers::Keyed<Key_Type is Hashable<>> is
    func Key_Of(ref const KV : Keyed) -> ref const Key_Type
    func Has_Value(KV : Keyed) -> Boolean
        // Return #true if Keyed object has a non-null value
    func Key_Only(Key : Key_Type) -> Keyed
        // Return a Keyed object given a key, having no associated value
end interface PSL::Containers::Keyed

interface PSL::Containers::Key_Value
  <Key_Type is Assignable<>; Value_Type is Assignable<>> 
  implements Keyed<Key_Type> is
  // This supports the use of [Key => Value] as a way to
  // add a single element to an existing indexable container of some sort.
    var Key : optional Key_Type
    var Value : optional Value_Type
    op "[]"() -> Key_Value is ((Key => null, Value => null))
    op "var_indexing"(ref var KV : Key_Value; Index : Key_Type) 
      -> ref var Value_Type
    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type
    func Has_Value(KV : Key_Value) -> Boolean
        // Return #true if Key_Value object has a non-null value
    func Key_Only(Key : Key_Type) -> Key_Value is ((Key => Key, Value => null))
        // Return a Key_Value object given a key, having no associated value
end interface PSL::Containers::Key_Value

class PSL::Containers::Key_Value is
  exports
    op "var_indexing"(ref var KV : Key_Value; Index : Key_Type) 
      -> ref var Value_Type is
        KV.Key := Index
        return KV.Value
    end op "var_indexing"

    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type is
        return KV.Key
    end func Key_Of

    func Has_Value(KV : Key_Value) -> Boolean is
        // Return #true if Key_Value object has a non-null value
        return KV.Value not null
    end func Has_Value
end class PSL::Containers::Key_Value

interface PSL::Containers::Basic_Map<KV_Type is Keyed<>> is
  // A basic hashed-map module

    op "[]"() -> Basic_Map

    op "|="(var Left : Basic_Map; Right : KV_Type)
        // Add Key=>Value to Basic_Map, replacing pre-existing Basic_Mapping
        // for Key, if any.

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type)
        // Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
        // for Key, if any, leaving Right null.

    op "+="(var Left : Basic_Map; Right : KV_Type) is "|="
        // A synonym for adding a key=>value KV_Type

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean
        // Return True if given key has a Basic_Mapping in the Basic_Map

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type)   // aka Exclude
        // Remove Basic_Mapping for Right, if present

    op "index_set"(M : Basic_Map) -> Set<KV_Type::Key_Type>
        // Return set of keys with Basic_Mappings

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type
        // Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Basic_Map) -> optional KV_Type
        // Remove one Basic_Mapping from the Basic_Map.  
        // Return null if Basic_Map is empty

    func Any_Element(M : Basic_Map) -> optional KV_Type
        // Return one Basic_Mapping from the Basic_Map.
        // Return null if Basic_Map is empty

    func Count(M : Basic_Map) -> Univ_Integer
        // Number of Basic_Mappings in the table

    op "magnitude"(Basic_Map) -> Univ_Integer is Count

    func Is_Empty(M : Basic_Map) -> Boolean
        // Return True if map has no mappings

    func Dump_Statistics(M : Basic_Map)
      // A debugging routine to show bucket sizes of Basic_Map

end interface PSL::Containers::Basic_Map

class PSL::Containers::Basic_Map is
  // A basic hashed-map module

  // A Basic_Map is represented as a hash table, where each bucket is 
  // a linked list of key/value KV_Types.
  // We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface Hash_Bucket<> is
      // a simple linked-list is used as a hash bucket
        var Elem : optional KV_Type
        var Tail : optional Hash_Bucket
    end interface Hash_Bucket

    var Count : Univ_Integer
    var Table : optional Basic_Array<optional Hash_Bucket<>>
    const Initial_Table_Size := 4
    const Debugging : Boolean := #false
    
    func Empty(Table_Size : Univ_Integer) -> Basic_Map is
        // Create an empty Basic_Map with the given table size
        return (Count => 0, Table => Create(Table_Size, null))
    end func Empty

    func Move_One(var To : Basic_Map; var Elem : optional KV_Type) is
        // Move Element into table, without expanding table.
        // Elem is set to null as a result.
        const Index := Hash(Key_Of(Elem)) mod |To.Table| + 1
        ref Bucket => To.Table[Index]

        if Bucket is null then
            // Bucket is now empty, so create bucket
            // with Elem as its only element.
            Bucket := (Elem <== Elem, Tail => null)
        else
            // See whether Elem already in bucket
            var Has_Empty_Slot : Boolean := #false
            for B => Bucket then B.Tail while B not null loop
                if B.Elem is null then
                    // Remember there is an empty slot
                    Has_Empty_Slot := #true
                elsif Key_Of(Elem) == Key_Of(B.Elem) then
                    // Already there; replace it in case Value is different.
                    B.Elem <== Elem
                    return
                end if
            end loop

            if Has_Empty_Slot then
                // Fill in the empty slot
                for B => Bucket then B.Tail while B not null loop
                    if B.Elem is null then
                        // Use the empty slot
                        B.Elem <== Elem
                        exit loop
                    end if
                end loop
            else
                // Make old bucket the new tail of the new bucket.
                Bucket := (Elem <== Elem, Tail <== Bucket)
            end if
        end if

        To.Count += 1
    end func Move_One

    func Add_One(var To : Basic_Map; Elem : KV_Type) is
        // Add Element to table, without expanding it
        var Elem_Copy for To := Elem

        // Just pass the buck to "Move_One"
        Move_One(To, Elem_Copy)
    end func Add_One

    func Expand_Table(var Expanding : Basic_Map) is
        // Expand table of given Basic_Map.
        if Debugging then
            Println(" Expanding hash table, Count = " | Expanding.Count | 
              ", Length = " | |Expanding.Table|)
        end if
        var Old_Basic_Map <== Expanding
        Expanding := Empty(2 * |Old_Basic_Map.Table|)
        // Move elements into new table
        loop
            var Elem for Expanding := Remove_Any(Old_Basic_Map)
                // "for Expanding" means to allocate Elem in
                // region associated with Expanding.
            if Elem is null then
                exit loop
            end if
            Move_One(Expanding, Elem)
        end loop
        if Debugging then
            Println(" After expansion, Count = " | Expanding.Count |
              ", Length = " | |Expanding.Table|)
        end if
    end func Expand_Table

  exports
    op "[]"() -> Basic_Map is
        return (Count => 0, Table => null)
    end op "[]"

    op "|="(var Left : Basic_Map; Right : KV_Type) is
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            // Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if
        Add_One(Left, Right)
    end op "|="

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type) is
        // Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
        // for Key, if any, leaving Right null.
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            // Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if
        Move_One(Left, Right)
    end op "<|="

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean is
        if Right.Count == 0 then
            // Empty Basic_Map
            return #false
        end if
        const Index := Hash(Left) mod Length(Right.Table) + 1
        ref Bucket => Right.Table[Index]
        if Bucket is null then
            // Hash bucket is empty
            return #false
        end if
        // Scan for Elem in hash bucket
        for B => Bucket then B.Tail while B not null loop 
            if B.Elem not null and then
              Key_Of(B.Elem) == Left then
                // Found it
                return #true
            end if
        end loop
        // Not in Basic_Map
        return #false
    end op "in"

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type) is
      // Remove the given key from the Basic_Map, if present
        if M.Count == 0 then
            // Empty Basic_Map
            return
        end if

        const Index := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        if Bucket is null then
            // Hash bucket is empty
            return
        end if

        // Scan for Key in bucket
        for B => Bucket then B.Tail while B not null loop
            if B.Elem not null and then
              Key_Of(B.Elem) == Key then
                // Found it.  Map it to null, and decrement Basic_Map count.
                B.Elem := null
                M.Count -= 1
                return
            end if
        end loop
        // Not found
    end op "-="
   
    op "index_set"(M : Basic_Map) -> Result : Set<KV_Type::Key_Type> is
        // Return set of keys with non-null Basic_Mappings
        Result := []
        if M.Count == 0 then
            return
        end if
        for each Bucket of M.Table loop
            for B => Bucket then B.Tail while B not null loop
                if B.Elem not null then
                    Result |= Key_Of(B.Elem)
                end if
            end loop
        end loop
    end op "index_set"

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type is
        // Used for references to M[Key]; requires the Key to be in M.
        {M not null; M.Count > 0}
        const Index := Hash(Key) mod Length(M.Table) + 1
        // Scan for Key in bucket
        for B => M.Table[Index] then B.Tail while B not null loop
            if B.Elem not null and then Key_Of(B.Elem) == Key then
               // Found it.  Return reference to element of KV_Type
               return B.Elem
            end if
        end loop
        {#false}
    end op "indexing"

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type is
        // Used for assignments to M[Key]; Key is added to M if not present
        if M.Table not null then
            const Index := Hash(Key) mod Length(M.Table) + 1
            // Scan for Key in bucket
            for B => M.Table[Index] then B.Tail while B not null loop
                if B.Elem not null and then
                  Key_Of(B.Elem) == Key
                then
                    // Found it.  Return reference to element of KV_Type
                    return B.Elem
                end if
            end loop
        end if

        // Not in table.  Add it, and then return reference
        if M.Table is null then
            M := Empty(Initial_Table_Size)
        elsif M.Count >= 2*Length(M.Table) then
            // Expand table if averaging 2 or more per hash bucket
            Expand_Table(M)
        end if

        // Add [Key => null] to front of appropriate bucket.
        const Index := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        Bucket := (Elem => Key_Only(Key), Tail <== Bucket)
        M.Count += 1

        // Return ref to new element
        return Bucket.Elem
    end op "var_indexing"

    func Count(M : Basic_Map) -> Univ_Integer is
        if M is null then
            return 0
        else
            return M.Count
        end if
    end func Count

    func Is_Empty(M : Basic_Map) -> Boolean is
        // Return True if map has no mappings
        return M.Count == 0
    end func Is_Empty

    func Remove_Any(var M : Basic_Map) -> Result : optional KV_Type is
        if M.Count == 0 then
            // Basic_Map is empty
            return null
        else
            // Find a non-empty bucket and pull out an item.
            for each Bucket of M.Table loop
                if Bucket not null then
                    for B => Bucket then B.Tail while B not null loop 
                        if B.Elem not null then
                            // Found an item, remove from Bucket and return
                            Result <== B.Elem
                            M.Count -= 1
                            return
                        end if
                    end loop
                    // This bucket is completely empty, so might
                    // as well empty it out.
                    Bucket := null
                end if
                // Go on to the next bucket, this one's empty
            end loop
            // Should never get here
            return null
        end if
    end func Remove_Any

    func Any_Element(M : Basic_Map) -> optional KV_Type is
        // Return one Basic_Mapping from the Basic_Map.
        // Return null if Basic_Map is empty
        if M.Count == 0 then
            // Basic_Map is empty
            return null
        else
            // Find a non-empty bucket and return first item found
            for each Bucket of M.Table loop
                if Bucket not null then
                    for B => Bucket then B.Tail while B not null loop 
                        if B.Elem not null then
                            // Found an item; return it.
                            return B.Elem
                        end if
                    end loop
                end if
                // Go on to the next bucket, this one's empty
            end loop
            // Should never get here
            return null
        end if
    end func Any_Element

    func Dump_Statistics(M : Basic_Map) is
      // A debugging routine to show bucket sizes of Basic_Map
        Println("Basic_Map statistics: Count = " | M.Count)
        if M.Table is null then
            Println(" Table is null")
        else
            Println(" Table of length " | Length(M.Table))
            for each [I => Bucket] of M.Table forward loop
                Print("  Bucket #" | I)
                if Bucket is null then
                    Println(" is null")
                else
                    var Len := 0
                    var Holes := 0
                    for B => Bucket then B.Tail while B not null loop
                        Len += 1
                        if B.Elem is null then
                            // This list has a hole
                            Holes += 1
                        end if
                    end loop
                    if Holes > 0 then
                        Println(" of length " | Len | " with " | 
                          Holes | " holes")
                    else
                        Println(" of length " | Len)
                    end if
                end if
            end loop
        end if
    end func Dump_Statistics

end class PSL::Containers::Basic_Map

func PSL::Test::Test_Basic_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    type Enum_String_KV_Type is Key_Value<Univ_Enumeration, Univ_String>
    type Enum_String_Basic_Map is Basic_Map<Enum_String_KV_Type>

    var M : Enum_String_Basic_Map := [X => [X => Y], A => [A => B]]

    Println("Count = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
        Println(K | " in M = " | (K in M))
    end loop

    Println("#xy in M = " | (#xy in M))
    
    M -= X

    Println("Count after deletion = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    M -= A

    Println("Count after deletion = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    var Ran := Random::Start(Hash(A))
    var MUI : Basic_Map<Key_Value<Univ_Integer, Univ_Integer>> := []

    Println("Adding 100 random KV_Typeings to Basic_Map.")
    for I in 1..100 loop
        const Key := Next(Ran) mod 100
        const Value := Next(Ran) mod 100
        MUI[Key] := [Key => Value]
    end loop
    Println("Basic_Map is now of count = " | Count(MUI))

    for each [K => KV] of MUI loop
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
        Println("MUI[" | K | "] = " | MUI[K].Value)
    end loop

    var I := 0
    for KV_Type in MUI loop
        I += 1
        Print(" [" | Key_Of(KV_Type) | " => " | KV_Type.Value | "]")
        if I mod 5 == 0 then
            Print('\n')
        end if
    end loop
    if I mod 5 != 0 then
        Print('\n')
    end if

end func PSL::Test::Test_Basic_Map
class PSL::Containers::Set is
  // A hashed-set module

  // A Set is represented as a hash table, where each bucket is a linked list.
  // When elements are deleted from the Set they end up a "null"s in the
  // list.  We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface KV_Wrapper<> implements Keyed<Element_Type> is
      // Create a wrapper for a key that implements the Keyed interface
        var Key : Element_Type
        func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type
        func Has_Value(KV : KV_Wrapper) -> Boolean
            // Return #true if KV_Wrapper object has a non-null value
        func Key_Only(Key : Element_Type) -> KV_Wrapper
            // Return a KV_Wrapper object given a key, 
            // having no associated value
    end interface KV_Wrapper

    class KV_Wrapper is
      // Create a wrapper for a key that implements the Keyed interface
      exports
        func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type is
            return KV.Key
        end func Key_Of

        func Has_Value(KV : KV_Wrapper) -> Boolean is
            // Return #true if KV_Wrapper object has a non-null value
            return #true
        end func Has_Value

        func Key_Only(Key : Element_Type) -> KV_Wrapper is
            // Return a KV_Wrapper object given a key, 
            // having no associated value.
            // NOTE: This is not really meaningful for sets, since there
            //       isn't a value.
            return (Key => Key)
        end func Key_Only
    end class KV_Wrapper
        
    var Data : Basic_Map<KV_Wrapper<>>
        // Set is represented as a map from keys to nothing.

  exports
    op "[]"() -> Set is
        return (Data => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Set is
        Result := []
        Result.Data |= (Key => Elem)
    end func Singleton

    op "|"(Left, Right : Element_Type) -> Result : Set is
        Result := []
        Result.Data |= (Key => Left)
        Result.Data |= (Key => Right)
    end op "|"

    op "|"(Left : Set; Right : Element_Type) -> Result : Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Set) -> Result : Set is
        Result := Right
        Result |= Left
    end op "|"

    op "|"(Left : Set; Right : Set) -> Result : Set is
        // Union, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            Result := Right
            Result |= Left
        else
            Result := Left
            Result |= Right
        end if
    end op "|"

    op "|="(var Left : Set; Right : Set) is
        if Count(Left.Data) == 0 then
            Left := Right
        else
            for Elem in Right loop
                Left |= Elem
            end loop
        end if
    end op "|="

    op "|="(var Left : Set; Right : Element_Type) is
        Left.Data |= (Key => Right)
    end op "|="

    op "<|="(var Left : Set; var Right : optional Element_Type) is
        // Move Right into Set Left
        var KV : KV_Wrapper := (Key <== Right)
        Left.Data <|= KV
    end op "<|="

    op "<|="(var Left : Set; var Right : Set) is
        // Move all elements of Right into Left, leaving Right empty.
        loop
            // Extract element from Right, in region for Left
            var Elem for Left := Remove_Any(Right)
            if Elem is null then
                // All done
                return
            end if
            // Move element into Left
            Left <|= Elem
        end loop
    end op "<|="

    op "in"(Left : Element_Type; Right : Set) -> Boolean is
        return Left in Right.Data
    end op "in"

    op "=?"(Left, Right : Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right.Data) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right.Data) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    op "and"(Left, Right : Set) -> Result : Set is
        // Intersection, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            // Left is smaller
            Result := []
            for Elem in Left loop
                if Elem in Right then
                    Result |= Elem
                end if
            end loop
        else
            // Left is bigger
            Result := Left
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
        end if
    end op "and"

    op "and="(var Left : Set; Right : Set) is
        // Intersection, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            // Left is smaller
            for Elem in Left loop
                if Elem not in Right then
                    Left -= Elem
                end if
            end loop
        else
            // Left is bigger
            var Result : Set for Left := []
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
            Left <== Result
        end if
    end op "and="

    op "xor"(Left, Right : Set) -> Result : Set is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        if Count(Left.Data) < Count(Right.Data) then
            // Swap order to shorten iteration
            Result := Right
            Result xor= Left
        else
            Result := Left
            Result xor= Right
        end if
    end op "xor"
    
    op "xor="(var Left : Set; Right : Set) is
        // Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end op "xor="

    op "-"(Left, Right : Set) -> Result : Set is
        // Set difference, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            // Left is smaller, build up 
            Result := []
            for Elem in Left loop
                if Elem not in Right then
                    Result |= Elem
                end if
            end loop
        else
            // Left is bigger, tear down
            Result := Left
            Result -= Right
        end if
    end op "-"

    op "-="(var Left : Set; Right : Set) is
        // Compute Set difference
        for Elem in Right loop
            Left -= Elem
        end loop
    end op "-="

    op "-="(var S : Set; Elem : Element_Type) is
      // Remove the given element from the Set, if present
        S.Data -= Elem
    end op "-="
   
    func Count(S : Set) -> Univ_Integer is
        return Count(S.Data)
    end func Count

    func Is_Empty(S : Set) -> Boolean is
        return Is_Empty(S.Data)
    end func Is_Empty

    func Remove_Any(var S : Set) -> Result : optional Element_Type is
        var Result_Wrapper for Result := Remove_Any(S.Data)
        if Result_Wrapper is null then
            return null
        else
            Result <== Result_Wrapper.Key
        end if
    end func Remove_Any

    func Any_Element(S : Set) -> Result : optional Element_Type is
      // Return an arbitrary element of the Set S;
      // return null if S is empty.
        const Result_Wrapper for Result := Any_Element(S.Data)
        if Result_Wrapper is null then
            return null
        else
            return Result_Wrapper.Key
        end if
    end func Any_Element

    optional func Dump_Statistics(S : Set) is
      // A debugging routine to show bucket sizes of Set
        Dump_Statistics(S.Data)
    end func Dump_Statistics

end class PSL::Containers::Set

func PSL::Test::Test_Set(A, X, Y, Z : Univ_Integer) is
    var S : Set<Univ_Integer> := X | Y | Z
    if A in S then
        Println(A | " is in " | X | "|" | Y | "|" | Z)
    else
        Println(A | " is *not* in " | X | "|" | Y | "|" | Z)
    end if

    const Save_Set := S

    const CSet : Set<Univ_Integer> := [Z, Y, X]
    Println("[Z, Y, X] =? (X | Y | Z) --> " |
      ( CSet =? S ))

    var Ran := Random::Start(A)
    Println("Adding 100 random digits to Set.")
    for I in 1..100 loop
        const N := Next(Ran) mod 100
        S |= N
        S |= N  // Make sure it doesn't produce duplicates
    end loop
    Println("Set is now of count = " | Count(S))
    Println("Contents of Set:")
    var I := 1
    for Elem in S loop
        Print(Elem | " ")
        if I mod 10 == 0 then
            Print('\n')
        end if
        I += 1
    end loop
    if Count(S) mod 10 != 0 then
        Print('\n')
    end if
    Println("S Before adding random elements =? now --> " |
      (Save_Set =? S))
    Println("S =? S --> " | (S =? S))

    var Small_Set : Set<Univ_Integer> := []
    Small_Set += -1
    Small_Set or= [2]

    Println("S =? (-1 | 2) --> " | (S =? Small_Set))
    Println("[2 , -1] =? (-1 | 2) --> " | ([2, -1] =? Small_Set))

    Println("S =? [] --> " | (S =? []))

    Println("Count(S) = " | Count(S))
    
    const Before_Exclude := S
    S -= X
    Println("After Exclude(S, " | X | "), Count(S) = " | Count(S))
    Println("Before_Exclude =? After Exclude --> " | (Before_Exclude =? S))

    Dump_Statistics(S)
end func PSL::Test::Test_Set
class PSL::Containers::Countable_Set is
    //  A set of values of a "countable" type (e.g. integer or enum),
    //  where we can efficiently represent intervals (i.e. contiguous ranges)
    //  of values of the type, allowing large sets to be handled.

    type Element_Interval is Countable_Range<Element_Type>

    func Len(IV : Element_Interval) -> Univ_Integer is (IV.Last - IV.First + 1);

    var Items : optional AA_Tree<Element_Interval>
  exports
    op "[]"() -> Countable_Set is
        return (Items => [])
    end op "[]"

    op "[..]"() -> Countable_Set is
        return Element_Type::First() .. Element_Type::Last()
    end op "[..]"

    func Singleton(Elem : Element_Type) -> Result : Countable_Set is
        Result := []
        Result.Items |= (First => Elem, Last => Elem)
    end func Singleton

    op ".."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (First => Left, Last => Right)
        end if
    end op ".."
    
    op "<.."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (First => Left+1, Last => Right)
        end if
    end op "<.."
    
    op "<..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right-1 then
            Result.Items |= (First => Left+1, Last => Right-1)
        end if
    end op "<..<"
    
    op "..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (First => Left, Last => Right-1)
        end if
    end op "..<"
    
    op "|"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left >= Right-1 and then Left <= Right + 1 then
            // Can combine elements into a single interval
            if Left <= Right then
                Result.Items |= (First => Left, Last => Right)
            else
                Result.Items |= (First => Right, Last => Left)
            end if
        else
            // Make each element its own interval
            Result.Items |= (First => Left, Last => Left)
            Result.Items |= (First => Right, Last => Right)
        end if
    end op "|"

    op "|"(Left : Countable_Set; Right : Element_Type) 
      -> Result : Countable_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Countable_Set; Right : Countable_Set) 
      -> Result : Countable_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Countable_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := (First => Right, Last => Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end op "|="

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
        // NOTE: No copy minimization done for countable types.
        Left |= Right
        Right := null
    end op "<|="

    op "<|="(var Left : Countable_Set; var Right : Countable_Set) is
        // Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
            loop
                // Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)

                if Right_IV is null then
                    return   // All done
                end if

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    if Left_IV.First <= Right_IV.First and then
                      Left_IV.Last >= Right_IV.Last then
                        // Right_IV is subsumed; nothing to add in
                        Right_IV := null
                        exit loop
                    else
                        // Need to delete Left_IV and incorporate
                        // into Right_IV
                        Delete(Left.Items, Left_IV)
                        if Left_IV.First < Right_IV.First then
                            Right_IV :=
                              (First => Left_IV.First, Last => Right_IV.Last)
                        end if
                        if Left_IV.Last > Right_IV.Last then
                            Right_IV :=
                              (First => Right_IV.First, Last => Left_IV.Last)
                        end if

                        // Now see if there is anything still overlapping
                        Left_IV := Overlapping(Left.Items, Right_IV)
                    end if
                end loop

                if Right_IV not null then
                    // Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end op "<|="

    op "|="(var Left : Countable_Set; Right : Countable_Set) is
        // Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end op "|="

    op "-"(Left, Right : Countable_Set) -> Result : Countable_Set is
      // Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-"(Left : Countable_Set; Right : Element_Type)
      -> Result : Countable_Set is
      // Remove one element
        Result := Left
        Result -= Right
    end op "-"
        
    op "-="(var S : Countable_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
        const IV := Overlapping(S.Items, (First => Elem, Last => Elem))
          // Get interval, if any, which overlaps given element

        if IV not null then
            // Delete interval and put back after removing Elem
            Delete(S.Items, IV)
            if IV.Last > IV.First then
                // We need to put something back
                if IV.First == Elem then
                    S.Items |= (First => IV.First + 1, Last => IV.Last)
                elsif IV.Last == Elem then
                    S.Items |= (First => IV.First, Last => IV.Last-1)
                else
                    // Elem is in the middle, put back intervals
                    // on either side.
                    S.Items |= (First => IV.First, Last => Elem-1)
                    S.Items |= (First => Elem+1, Last => IV.Last)
                end if
            end if
        end if

    end op "-="

    op "-="(var Left : Countable_Set; Right : Countable_Set) is
      // Remove all elements of Right from Left, if present
        for Elem in Right loop
            Left -= Elem
        end loop
    end op "-="

    op "and"(Left, Right : Countable_Set) -> Result : Countable_Set is
        // Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end op "and"

    op "and="(var Left : Countable_Set; Right : Countable_Set) is
        // Intersection
        for Elem in Left loop
            if Elem not in Right then
                Left -= Elem
            end if
        end loop
    end op "and="

    op "xor"(Left, Right : Countable_Set) -> Result : Countable_Set is
        // Symmetric difference
        Result := Left
        Result xor= Right
    end op "xor"

    op "xor="(var Left : Countable_Set; Right : Countable_Set) is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end op "xor="

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean is
        return Overlapping(Right.Items, (First => Left, Last => Left)) not null
    end op "in"

    op "=?"(Left, Right : Countable_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    func Count(S : Countable_Set) -> Result : Univ_Integer is
        // Return count of items in set

        Result := 0

        // Iterate through them to build up count
        for Next_IV in S.Items loop
            Result += Len (Next_IV)
        end loop
    end func Count

    func Is_Empty(S : Countable_Set) -> Boolean is
        return Is_Empty(S.Items)
    end func Is_Empty

    func First(S : Countable_Set) -> optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.First
        end if
    end func First

    func Last(S : Countable_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.Last
        end if
    end func Last

    func Any_Element(S : Countable_Set) -> optional Element_Type is
        const Any_IV := Any_Element(S.Items)
        if Any_IV is null then
            return null
        elsif (Any_IV.Last - Any_IV.First) mod 2 == 0 then
            // Return high bound when high-low is even
            // NOTE: We do this to avoid having algorithms become
            //       dependent on always getting values in ascending 
            //       or descending order.
            return Any_IV.Last
        else
            // Return low bound when high-low is odd
            return Any_IV.First
        end if
    end func Any_Element

    op "indexing"(S : Countable_Set; Index : Univ_Integer)
      -> optional Element_Type is
         //  Return "Index"th element of set S, counting 1 .. Count(S)
         if Index <= 0 then
             return null
         end if

         var Start_Offset := Index - 1

         for IV in S.Items forward loop
             const IV_Len := Len (IV)
             if Start_Offset < IV_Len then
                 //  It is in this interval
                 return IV.First + Start_Offset
             end if
             Start_Offset -= IV_Len
         end loop

         return null
    end op "indexing"

    op "slicing"(S : Countable_Set; 
      Index_Set : Countable_Range<Univ_Integer>) -> Result : Countable_Set is
         //  Return subset of set S, elements S[Index_Set.First] through
         //  S[Index_Set.Last], counting 1 .. Count(S)
         var Start_Offset := Index_Set.First - 1
         var End_Offset := Index_Set.Last - 1

         Result := []

         if Start_Offset < 0 then
             Start_Offset := 0
         end if

         if End_Offset < Start_Offset then
             return
         end if

         for IV in S.Items forward loop
             const IV_Len := Len (IV)
             if Start_Offset < IV_Len then
                 //  It starts in this interval
                 if End_Offset < IV_Len then
                     //  It ends in this interval as well
                     Result.Items |=
                        (First => IV.First + Start_Offset,
                         Last => IV.First + End_Offset)
                     return
                 else
                     //  It extends to the next interval
                     Result.Items |=
                        (First => IV.First + Start_Offset,
                         Last => IV.Last)
                     Start_Offset := 0
                 end if
             else
                 Start_Offset -= IV_Len
             end if
             End_Offset -= IV_Len
         end loop
    end op "slicing"

    op "/"(Set : Countable_Set; Num_Pieces : Univ_Integer)
      -> Result : Vector<Countable_Set> is
       // Divide a set into a vector of sets, each of similar size
        {> Num_Pieces > 0 <}

        if Num_Pieces <= 1 then
            //  Return a vector of length 1 if Num_Pieces is 1 (or less)
            return Create(1, Set)
        end if

        const Size := Count(Set)
        const Small_Piece_Size := Size / Num_Pieces
        const Big_Piece_Size := Small_Piece_Size + 1
        const Num_Big_Pieces := Size rem Num_Pieces

        //  Create the result
        Result := Create(Num_Pieces, [])

        //  Fill in the elements of the result vector with slices of the set.
        var Index := 1

        //  Big pieces first
        for I in 1 .. Num_Big_Pieces forward loop
            Result[I] := Set[Index .. Index + Big_Piece_Size - 1]
            Index += Big_Piece_Size
        end loop

        //  Small pieces next
        if Small_Piece_Size > 0 then
            for I in Num_Big_Pieces + 1 .. Num_Pieces forward loop
                Result[I] := Set[Index .. Index + Small_Piece_Size - 1]
                Index += Small_Piece_Size
            end loop
        end if

        {> Index == Size + 1 <}
            
    end op "/"

    func Remove_First(var S : Countable_Set) 
      -> Result : optional Element_Type is
        // Return first element of set

        // Get first interval in tree
        var First_IV := Remove_First(S.Items)
        if First_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if First_IV.Last > First_IV.First then
            // Need to put back the remainder
            S.Items |= (First => First_IV.First+1, Last => First_IV.Last)
        end if

        // Return first item
        return First_IV.First
    end func Remove_First

    func Remove_Last(var S : Countable_Set) -> Result : optional Element_Type is
        // Remove last element of set

        // Get Last interval in tree
        var Last_IV := Remove_Last(S.Items)
        if Last_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if Last_IV.Last > Last_IV.First then
            // Need to put back the remainder
            S.Items |= (First => Last_IV.First, Last => Last_IV.Last-1)
        end if

        // Return Last item
        return Last_IV.Last
    end func Remove_Last

    func Remove_Any(var S : Countable_Set) -> optional Element_Type is
        // Remove any element of set

        // Get any interval in tree
        var Any_IV := Remove_Any(S.Items)
        if Any_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if Any_IV.Last > Any_IV.First then
            // Need to remove one to return and put back the remainder
            if (Any_IV.Last - Any_IV.First) mod 2 == 0 then
                // Return high bound when high-low is even
                // NOTE: We do this to avoid having algorithms become
                //       dependent on always getting values in ascending 
                //       or descending order.
                S.Items |= (First => Any_IV.First, Last => Any_IV.Last-1)
                return Any_IV.Last
            else
                // Return low bound when high-low is odd
                S.Items |= (First => Any_IV.First+1, Last => Any_IV.Last)
                return Any_IV.First
            end if
        else
            // Return only item in interval
            return Any_IV.First
        end if

    end func Remove_Any

    func Ranges(S : Countable_Set) ->
      Result : Ordered_Set<Countable_Range<Element_Type>> is
        // Return set of disjoint ranges that represent the set of values in S
        Result := []
        var Cur_Range : Countable_Range<Element_Type> for Result := []
        var Copy_Of_Items for Result := S.Items
        var Next_Range for Result := Remove_First(Copy_Of_Items)

        while Next_Range not null loop
            if Cur_Range.Last < Cur_Range.First then
                //  Was empty range, remember first range
                Cur_Range <== Next_Range
            elsif Cur_Range.Last+1 == Next_Range.First then
                //  Combine contiguous ranges
                Cur_Range :=
                  (First => Cur_Range.First, Last => Next_Range.Last)
            else
                //  Discontiguous ranges, add Cur_Range to result and update
                Result <|= Cur_Range
                Cur_Range <== Next_Range
            end if
            Next_Range := Remove_First(Copy_Of_Items)
        end loop

        if Cur_Range.Last >= Cur_Range.First then
            //  Include last range
            Result <|= Cur_Range
        end if
    end func Ranges

end class PSL::Containers::Countable_Set

func PSL::Test::Test_Countable_Set(A, X, Y, Z : Integer) is
    var S : Countable_Set<Integer> := X | Y..Z
    Println(A | " in " | X | "|" | Y | ".." | Z | "=" | ( A in S ))

    const Agg : Countable_Set<Integer> := [X, Y, Z]
    const Or : Countable_Set<Integer> := Y | Z | X

    Println(" [X, Y, Z] =? (Y | Z | X) --> " | ( Agg =? Or ))

    for J in S loop 
        Println("Remove_Any(S) = " | J)
    end loop

    S := []

    for I in 1..10 forward loop
        S += I
        Println("Adding " | I | " to S, Count = " | Count(S))
    end loop

    for K in S loop 
        Println("Remove_Any(S) = " | K)
    end loop

    Println("Count(S) = " | Count(S))
    S -= 7
    Println("After S -= 7, Count(S) = " | Count(S))

    var Xor := S xor [2, 5, 12, 15]
    Print("S xor [2, 5, 12, 15] = ")
    for J in Xor forward loop
        Print(J | " ")
    end loop
    Print('\n')

    for I in -1 .. 11 forward loop
       Println("S[" | I | "] = " | S[I])
    end loop

    for I in -1 .. 11 forward loop
        for J in I-2 .. I + 5 forward loop
            Print("S[" | I | " .. " | J | "] = ")
            const Slice := S[I .. J]
            for K in Slice forward loop
                Print(K | " ")
            end loop
            Print('\n')
        end loop
    end loop

    for Num in 1 .. 11 forward loop
       Print("S / " | Num | " =")
       for each Piece of S / Num forward loop
          Print (" {")
          for J in Piece forward loop
              Print(J | " ")
          end loop
          Print ("}")
       end loop
       Print('\n')
    end loop
end func PSL::Test::Test_Countable_Set
interface PSL::Containers::Range_Set<Element_Type is Comparable<>> is
  // A set abstraction that supports efficiently storing potentially
  // large ranges of values
    op "[]"() -> Range_Set

    func Singleton(Elem : Element_Type) -> Range_Set
        // Return a set consisting of a single element

    op ".."(Left, Right : Element_Type) -> Range_Set
        // Closed interval of values
    op "<.."(Left, Right : Element_Type) -> Range_Set
        // Open-Closed interval of values
    op "..<"(Left, Right : Element_Type) -> Range_Set
        // Closed-Open interval of values
    op "<..<"(Left, Right : Element_Type) -> Range_Set
        // Open interval of values

    op "|"(Left, Right : Element_Type) -> Range_Set
    op "|"(Left : Range_Set; Right : Element_Type) -> Range_Set
    op "|"(Left : Element_Type; Right : Range_Set) -> Range_Set
    op "|"(Left : Range_Set; Right : Range_Set) -> Range_Set

    op "|="(var Left : Range_Set; Right : Element_Type)
    op "|="(var Left : Range_Set; Right : Range_Set)

    op "<|="(var Left : Range_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Range_Set; var Right : Range_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Range_Set) -> Range_Set
      // Set difference
    op "-="(var S : Range_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Range_Set; Right : Range_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Range_Set; Right : Range_Set) 
      -> Range_Set is "|"   // union
    op "or="(var Left : Range_Set; Right : Range_Set) is "|="

    op "+"(Left : Range_Set; Right : Range_Set) 
      -> Range_Set is "|"   // Union
    op "+="(var Left : Range_Set; Right : Range_Set) is "|="
    op "+="(var Left : Range_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Range_Set) -> Range_Set
        // Intersection
    op "and="(var Left : Range_Set; Right : Range_Set)

    op "xor"(Left, Right : Range_Set) -> Range_Set
        // Symmetric difference
    op "xor="(var Left : Range_Set; Right : Range_Set)

    op "in"(Left : Element_Type; Right : Range_Set) -> Boolean

    op "=?"(Left, Right : Range_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    func Is_Empty(S : Range_Set) -> Boolean

    func Lower_Bound(S : Range_Set) -> optional Element_Type
        // Lower bound of set
    func Lower_Bound_Is_Open(S : Range_Set) -> Boolean
        // Whether lower bound is "open" or "closed"

    func Upper_Bound(S : Range_Set) -> optional Element_Type
        // Upper bound of set
    func Upper_Bound_Is_Open(S : Range_Set) -> Boolean
        // Whether upper bound is "open" or "closed"

    func Remove_First(var S : Range_Set) -> optional Interval<Element_Type>
        // Remove first interval of set (lowest low bound)

    func Remove_Last(var S : Range_Set) -> optional Interval<Element_Type>
        // Remove last interval of set (highest high bound)

    func Remove_Any(var S : Range_Set) -> optional Interval<Element_Type>
        // Remove an arbitrary interval of set

end interface PSL::Containers::Range_Set

class PSL::Containers::Range_Set is

    type Element_Interval is Interval<Element_Type>

    var Items : optional AA_Tree<Element_Interval>

    func Remove_Interval(var S : Range_Set; Remove_IV : Element_Interval) is
      // Remove the given interval from the set, if present
        if Remove_IV.Low > Remove_IV.High then
            // Nothing to remove
            return
        end if

          // Find an interval within the AA_Tree that overlaps
        for Remaining_IV := Remove_IV while Remaining_IV not null loop
            // Get overlap, if any
            var IV := Overlapping(S.Items, Remaining_IV)

            if IV is null then
                // No overlap, nothing left to remove
                exit loop
            end if
        
            // Found an overlapping interval; delete it and add back what's left
            Delete(S.Items, IV)
            if Is_Strictly_Within(Remaining_IV, IV) then
                // Add back left and right remnants
                // Remaining_IV is fully subsumed.
                S.Items |= (Low => IV.Low, Low_Is_Open => IV.Low_Is_Open, 
                  High => Remaining_IV.Low, 
                  High_Is_Open => not Remaining_IV.Low_Is_Open)
                S.Items |= (Low => Remaining_IV.High, 
                  Low_Is_Open => not Remaining_IV.High_Is_Open,
                  High => IV.High, 
                  High_Is_Open => IV.High_Is_Open)
                // we are all done now
                exit loop
            end if

            // May be something left
            const Overlap := IV and Remaining_IV
            IV -= Overlap

            if not Is_Empty(IV) then
                // Worth putting the interval back
                S.Items |= IV
            end if

            continue loop with Remaining_IV => Remaining_IV - Overlap

        end loop

    end func Remove_Interval

    func Is_Subset(Left, Right : Range_Set) -> Boolean is
        // Return True if Left is a subset of Right
        for Left_IV in Left loop
            for Remaining_IV := Left_IV while not Is_Empty(Remaining_IV) loop
                const Right_IV := Overlapping(Right.Items, Remaining_IV)
                if Right_IV is null then
                    // Found some values that are not in Right
                    return #false
                end if

                // Loop around with what is left
                continue loop with Remaining_IV => Remaining_IV - Right_IV
            end loop
        end loop
        // Everything in Left was found in Right
        return #true
    end func Is_Subset

  exports
    op "[]"() -> Range_Set is
        return (Items => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Range_Set is
        // Return a set consisting of a single element
        Result := []
        Result.Items |= Singleton(Elem)
    end func Singleton

    op ".."(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false, 
              High => Right, High_Is_Open => #false)
        end if
    end op ".."
    
    op "<.."(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
              High => Right, High_Is_Open => #false)
        end if
    end op "<.."
    
    op "<..<"(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
              High => Right, High_Is_Open => #true)
        end if
    end op "<..<"
    
    op "..<"(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false,
              High => Right, High_Is_Open => #true)
        end if
    end op "..<"
    
    op "|"(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        Result |= Left
        if Left != Right then
            Result |= Right
        end if
    end op "|"

    op "|"(Left : Range_Set; Right : Element_Type) 
      -> Result : Range_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Range_Set) -> Range_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Range_Set; Right : Range_Set) 
      -> Result : Range_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Range_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := Singleton(Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end op "|="

    op "<|="(var Left : Range_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
        // TBD: No copy minimization done at the moment
        Left |= Right
        Right := null
    end op "<|="

    op "|="(var Left : Range_Set; Right : Range_Set) is
        if Count(Left.Items) == 0 then
            Left := Right
        else
            // Make a copy of the Right set
            var Right_Copy for Left := Right

            // Merge all of its intervals into Left
            Left <|= Right_Copy
        end if
    end op "|="

    op "<|="(var Left : Range_Set; var Right : Range_Set) is
        // Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
            loop
                // Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)
                if Right_IV is null then
                    return
                end if

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    // Incorporate left interval into Right_IV
                    Right_IV |= Left_IV

                    if Right_IV == Left_IV then
                        // Right_IV fully subsumed by existing interval
                        Right_IV := null
                        exit loop
                    end if

                    // Need to delete Left_IV 
                    Delete(Left.Items, Left_IV)

                    // Now see if there is anything still overlapping
                    Left_IV := Overlapping(Left.Items, Right_IV)
                end loop

                if not Is_Empty(Right_IV) then
                    // Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end op "<|="

    op "-"(Left, Right : Range_Set) -> Result : Range_Set is
      // Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-="(var S : Range_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
        Remove_Interval(S, Singleton(Elem))
    end op "-="

    op "-="(var Left : Range_Set; Right : Range_Set) is
      // Remove all intervals of Right from Left, if present
        for IV in Right loop
            Remove_Interval(Left, IV)
        end loop
    end op "-="

    op "and"(Left, Right : Range_Set) -> Result : Range_Set is
        // Intersection

        // Add elements that are in both Right and Left into result
        Result := []
        for Right_IV in Right loop
            for Remaining_IV := Right_IV while Remaining_IV not null loop
                var Left_IV := Overlapping(Left.Items, Remaining_IV)

                if Left_IV is null then
                    exit loop
                end if

                // Compute overlap, add into result, and then loop
                // around after removing it from Remaining_IV
                const Overlap := Remaining_IV and Left_IV

                Result.Items |= Overlap

                continue loop with Remaining_IV => Remaining_IV - Overlap
            end loop
        end loop
    end op "and"

    op "and="(var Left : Range_Set; Right : Range_Set) is
        // Intersection
        Left := Left and Right
    end op "and="

    op "xor"(Left, Right : Range_Set) -> Range_Set is
        // Symmetric difference

        return (Left - Right) or (Right - Left)
    end op "xor"

    op "xor="(var Left : Range_Set; Right : Range_Set) is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        const Only_In_Right := Right - Left
        Left -= Right
        Left += Only_In_Right
    end op "xor="

    op "in"(Left : Element_Type; Right : Range_Set) -> Boolean is
        return Overlapping(Right.Items, Singleton(Left)) not null
    end op "in"

    op "=?"(Left, Right : Range_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        if Is_Subset(Left, Right) then
            if Is_Subset(Right, Left) then
                return #equal
            else
                return #less
            end if
        elsif Is_Subset(Right, Left) then
            return #greater
        else
            return #unordered
        end if
    end op "=?"

    func Is_Empty(S : Range_Set) -> Boolean is
        // Return count of items in set
        return Count(S.Items) == 0
    end func Is_Empty

    func Lower_Bound(S : Range_Set) -> optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end func Lower_Bound

    func Lower_Bound_Is_Open(S : Range_Set) -> Boolean is
        const First_IV := First(S.Items)
        if First_IV is null then
            return #true   // TBD: or null?
        else
            return First_IV.Low_Is_Open
        end if
    end func Lower_Bound_Is_Open

    func Upper_Bound(S : Range_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end func Upper_Bound

    func Upper_Bound_Is_Open(S : Range_Set) -> Boolean is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return #true   // TBD: or null?
        else
            return Last_IV.High_Is_Open
        end if
    end func Upper_Bound_Is_Open

    func Remove_First(var S : Range_Set) 
      -> optional Interval<Element_Type> is
        // Remove first interval of set (lowest low bound)
        return Remove_First(S.Items)
    end func Remove_First

    func Remove_Last(var S : Range_Set) 
      -> optional Interval<Element_Type> is
        // Remove last interval of set (highest high bound)
        return Remove_Last(S.Items)
    end func Remove_Last

    func Remove_Any(var S : Range_Set) 
      -> optional Interval<Element_Type> is
        // Remove an arbitrary interval of set
        return Remove_Any(S.Items)
    end func Remove_Any

end class PSL::Containers::Range_Set

func PSL::Test::Test_Range_Set(A, X, Y, Z : Univ_Real) is
    var S : Range_Set<Univ_Real> := X | Y..Z
    Println(A | " in " | X | "|" | Y | ".." | Z | "=" | ( A in S ))

    const Agg : Range_Set<Univ_Real> := [X, Y, Z]
    const Or : Range_Set<Univ_Real> := Y | Z | X
    const Open_Ind : Map<Boolean, Univ_String> := [#false => "", #true => "<"]

    Println(" [X, Y, Z] =? (Y | Z | X) --> " | ( Agg =? Or ))

    S := []

    var R := 0.0
    for I in 1..10 forward loop
        R += 1.0
        S += R
        Println("Adding " | R | " to S, Is_Empty(S) = " | Is_Empty(S))
    end loop

    var Xor := S xor [2.0, 5.0, 12.0, 15.0]
    Print("S xor [2.0, 5.0, 12.0, 15.0] = ")
    for IV in Xor forward loop
        if IV.Low != IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] | ".." | 
              Open_Ind[IV.High_Is_Open] | IV.High | " ")
        else
            Print(IV.Low | " ")
        end if
    end loop
    Print('\n')
end func PSL::Test::Test_Range_Set
interface PSL::Core::Univ_Real<> is
    op "+"(Right : Univ_Real) -> Univ_Real
      is import(#identity)

    op "-"(Right : Univ_Real) -> Univ_Real
      is import(#real_negate)

    op "abs"(Right : Univ_Real) -> Univ_Real
      is import(#real_abs)

    op "magnitude"(Univ_Real) -> Univ_Real is "abs"

    op "+"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_add)

    op "-"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_subtract)

    op "*"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_multiply)

    op "*"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_int_multiply)

    op "*"(Left : Univ_Integer; Right : Univ_Real) -> Univ_Real

    op "/"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_divide)

    op "/"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_int_divide)

    op "**"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_exp)

    op "+="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_add)

    op "-="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_subtract)

    op "*="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_multiply)

    op "/="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_divide)

    op "**="(var Left : Univ_Real; Right : Univ_Integer) 
      is import(#real_assign_exp)


    op "=?"(Left, Right : Univ_Real) -> Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Univ_Real) -> optional Univ_Real
      is import(#real_min)
    func Max(Left, Right : optional Univ_Real) -> optional Univ_Real
      is import(#real_max)

    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Univ_Real

    func Hash(Val : Univ_Real) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Univ_Real) -> Univ_String
      is import(#to_string_real)

    func From_String(Str : Univ_String) -> optional Univ_Real
      is import(#from_string_real)

    func Print(X : Univ_Real) is import(#print_real)
    func Println(X : Univ_Real) is (Println(To_String(X)))

    func Round_To_Int(Real : Univ_Real) -> Univ_Integer
      is import(#round_to_int)

    func Int_To_Real(Int : Univ_Integer) -> Univ_Real
      is import(#int_to_real)

    op "in"(Left : Univ_Real; Right : Range_Set<Univ_Real>) -> Boolean
      is in Range_Set<Univ_Real>

end interface PSL::Core::Univ_Real

class PSL::Core::Univ_Real is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_Real) -> Univ_Real is
        // Hand off to built-in real * int op
        return Right * Left
    end op "*"

    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Result : Univ_Real is
        {Val >= 0.0}
        Result := Val / 2.0
        while Result > 0.0 and then Result * Result / Val 
          not in 0.9999999999999 .. 1.00000000000001 loop
            Result := (Val / Result + Result)/2.0
        end loop
    end func Sqrt

end class PSL::Core::Univ_Real
    
func PSL::Test::Test_Real() is
    var X := 3.5
    var Y := 5.22
    var Z := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny := 0.000023
    Println("Teeny = " | Teeny)
    var Small := 0.005
    Println("Small = " | Small)
    var Medium := 235.123
    Println("Medium = " | Medium)
    var Big := 11.0**5
    Println("Big = " | Big)
    var Huge := 13.0**15
    Println("Huge = " | Huge)

    Println("Y in 1.0 .. 6.0 = " | ( Y in 1.0 .. 6.0 ))
    
    Println("Y in 1.0 ..< 5.22 = " | ( Y in 1.0 ..< 5.22 ))

    Println("Sqrt(2.0) = " | Sqrt(2.0))

    Println("Sqrt(-2.0) = " | Sqrt(-2.0))
end func PSL::Test::Test_Real
abstract interface PSL::Core::Indexable
  <Elem_Type is Assignable<>; Index_Type is Countable<>> is
    // An indexable container
    op "indexing"(ref A : Indexable; Index : Index_Type) -> ref Elem_Type
    func Length(A : Indexable) -> Univ_Integer
    op "magnitude"(Indexable) -> Univ_Integer is Length
    op "index_set"(A : Indexable) -> Countable_Range<Index_Type>
    func Bounds(A : Indexable) -> Countable_Range<Index_Type> is "index_set"
end interface PSL::Core::Indexable
interface PSL::Containers::Basic_Array<Element_Type is Assignable<>> is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    func Create(Length : Univ_Integer<>; Val : optional Element_Type) 
      -> Basic_Array 
      is import(#basic_array_create)
    op "[]"() -> Basic_Array is (Create(0, null))
    op "indexing"(ref V : Basic_Array; Index : Univ_Integer<>) -> 
      ref Element_Type is import(#basic_array_indexing)
    op "var_indexing"(ref var V : Basic_Array; Index : Univ_Integer<>) -> 
      ref var Element_Type is import(#basic_array_indexing)
    func Length(V : Basic_Array) -> Univ_Integer<>
      is import(#basic_array_length)
    op "magnitude"(Basic_Array) -> Univ_Integer<> is Length
    op "|"(Left, Right : Basic_Array) -> Basic_Array
    op "index_set"(A : Basic_Array) -> Countable_Range<Univ_Integer>
    op "<|="(var Left : Basic_Array; var Right : optional Element_Type)
end interface PSL::Containers::Basic_Array

class PSL::Containers::Basic_Array is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
  exports
    op "|"(Left, Right : Basic_Array) -> Result : Basic_Array is
        const Left_Len := Length(Left)

        if Left_Len == 0 then
            return Right
        end if

        Result := Create(Left_Len + Length(Right), null)

        // Copy the Left elements
        for I in 1..Left_Len concurrent loop
            Result[I] := Left[I]
        end loop

        // Copy the Right elements
        
        for J in 1..Length(Right) concurrent loop
            Result[Left_Len + J] := Right[J]
        end loop
    end op "|"
            
    op "index_set"(A : Basic_Array) -> Countable_Range<Univ_Integer> is
        return 1..Length(A)
    end op "index_set"

    op "<|="(var Left : Basic_Array; var Right : optional Element_Type) is
        const Left_Len := |Left|
        var Result : Basic_Array for Left := Create(Left_Len+1, null)

        for I in 1 .. Left_Len concurrent loop
            Result[I] <== Left[I]
        end loop

        Result[Left_Len+1] <== Right

        Left <== Result
    end op "<|="
end class PSL::Containers::Basic_Array

func PSL::Test::Test_Basic_Array() is
    var A : Basic_Array<Univ_Integer<>> := Create(3, 7)
    A[1] := 42
    A[2] += 6
    A[3] += A[2]
    Print("The answer is: " | A[1] + A[2] + A[3] | "\n")
    Print("Length(A) = " | Length(A) | "\n")

    var B := A | A
    Print("Length(B) = " | Length(B) | ", B[5] = " | B[5] | "\n")
    for I in 1..Length(B) forward loop
        Print("B[" | I | "] = " | B[I] | ", ")
    end loop
    Print("\n")

    const C : Basic_Array<Univ_Integer> := [1, 3, 5, 7];
    Print("C = [")
    for each [I => E] of C forward loop
        Print((I > 1? ", " : "") | E)
    end loop
    Println("]")
    Println("|C| = " | |C|)
end func PSL::Test::Test_Basic_Array
interface PSL::Core::Vector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable Vector, indexed by Univ_Integer, 1..Length
    op "[]"() -> Vector
    func Create(Length : Univ_Integer; Value : Element_Type) -> Vector
    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type
    op "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      -> Vector  // a "read-only" slice
    op "index_set"(V : Vector) -> Countable_Range<Univ_Integer>
    func Bounds(V : Vector) -> Countable_Range<Univ_Integer> is "index_set"
    op "|="(var V : Vector; Elem : Element_Type)
    op "|="(var V : Vector; Right : Vector)
    op "<|="(var V : Vector; var Elem : optional Element_Type)
    op "|"(Left, Right : Vector) -> Vector
    op "|"(Left : Vector; Right : Element_Type) -> Vector
    func Length(V : Vector) -> Univ_Integer
    op "magnitude"(Vector) -> Univ_Integer is Length
end interface PSL::Core::Vector
    
class PSL::Core::Vector is
  // Extendable Vector, indexed by Univ_Integer, 1..Length
    const Debug := #false;
    const Initial_Size := 4
    const Leaf_Vec_Capacity := 256
    const Vec_Of_Vec_Length := 256
    const Subvec_Capacity : Basic_Array<Univ_Integer> :=
      // Capacity of each subvec at given level
      [Leaf_Vec_Capacity,
       Vec_Of_Vec_Length * Leaf_Vec_Capacity,
       Vec_Of_Vec_Length ** 2 * Leaf_Vec_Capacity]
    const Ordinal : Basic_Array<Univ_String> :=
      ["th","st","nd","rd","th","th","th","th","th","th"]

    const Level : Univ_Integer        //  Level = 0 means only Data array
    var Count   : Univ_Integer := 0   //  Overall count
    var Width   : Univ_Integer := 0   //  Num Subvecs in use; is 0 if level = 0
    var Data    : optional Basic_Array<optional Element_Type> := null
    var Subvecs : optional Basic_Array<optional Vector> := null

//    func Rep_Ok(V : Vector; ID : Univ_Integer) is
//        //if Debug then
//        //    Println("ID: " | ID);
//        //end if;
//        {V.Count >= 0};
//        if V.Level == 0 then
//            {V.Width == 0};
//            {V.Subvecs is null};
//            if V.Data not null then
//                {V.Data.Length() >= V.Count};
//            end if;
//        else
//            {V.Width >= 0};
//            {V.Subvecs not null};
//            {V.Data is null};
//        end if;
//    end func Rep_Ok;

    func Expand_Count(var V : Vector; Amount : Univ_Integer := 1) is
        // Expand count by "Amount"
        {> Amount > 0 <}
        //Rep_Ok(V, 1)
        const New_Count := V.Count + Amount;

        loop
            var Next_Count := New_Count

            if V.Level == 0 then
                //  A single Basic_Array of elements
                Next_Count := Min (New_Count, Leaf_Vec_Capacity)
                if V.Data is null then
                    //  Very first element
                    if Debug then
                        Println("Very first element");
                    end if;
                    V.Data := Create(Max(Initial_Size, Next_Count), null)
                    //Rep_Ok(V, 5555);
                elsif V.Count == Length(V.Data) or New_Count > Length(V.Data)
                then
                    //  Double the size if below capacity, else add a level
                    if V.Count < Leaf_Vec_Capacity then
                        // Double the size (up to the max)
                        if Debug then
                            Println("Doubling Data, V.Count was " | V.Count)
                        end if
                        var Old_Data <== V.Data
                        V.Data := Create(Min (Max (2*V.Count, Next_Count),
                                              Leaf_Vec_Capacity), null)
                        for I in 1..V.Count loop
                            V.Data[I] <== Old_Data[I]
                        end loop
                        Old_Data := null
                        //Rep_Ok(V, 6666);
                    else
                        // Reached maximum, add one level
                        {> Next_Count == V.Count <}
                        //Rep_Ok(V, 3333);
                        if Debug then
                            Println("Adding second level, V.Count was " |
                              V.Count)
                        end if;
                        var Old_V <== V
                        V := (Level => 1,
                              Count => Next_Count,
                              Width => 2,
                              Subvecs => Create (Vec_Of_Vec_Length, null))
                        V.Subvecs[1] <== Old_V
                        V.Subvecs[2] :=
                          (Level => 0, Data => Create(Leaf_Vec_Capacity, null))
                        //  Will loop around to extend this two-level structure
                        //Rep_Ok(V, 4444);
                    end if;
                else
                    if Debug then
                        Println(Next_Count | ", " | New_Count);
                    end if;
                end if
            else
                //  Multi-level structure, expand last subvec or add another
                if V.Width > 0 and then
                    V.Subvecs[V.Width].Count < Subvec_Capacity[V.Level]
                then
                    //  Can expand this subvec up to its capacity
                    if Debug then
                        Println("Expand Subvec " | V.Width |
                          ", V.Count was " | V.Count)
                    end if;
                    ref Last_Subvec => V.Subvecs[V.Width]
                    const Subvec_Increase := Min (New_Count - V.Count,
                      Subvec_Capacity[V.Level] - Last_Subvec.Count)
                    Expand_Count (Last_Subvec, Subvec_Increase);
                    //  Compute next value for V.Count
                    Next_Count := V.Count + Subvec_Increase;
                    //Rep_Ok(V, 7777);
                elsif V.Width < Vec_Of_Vec_Length then
                    //  Add another subvec
                    V.Width += 1
                    if V.Level == 1 then
                        //  Add another leaf vec
                        //  Compute amount in this new leaf vec
                        const Amount_In_New_Leaf := Min (Leaf_Vec_Capacity,
                          New_Count - V.Count)

                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " leaf vec, V.Count was " | V.Count |
                                ", adding " | Amount_In_New_Leaf |
                                " in new leaf")
                        end if;

                        V.Subvecs[V.Width] :=
                          (Level => 0, Count => Amount_In_New_Leaf,
                           Data => Create(Leaf_Vec_Capacity, null))

                        //  Compute total count of vector
                        Next_Count := V.Count + Amount_In_New_Leaf
                        //Rep_Ok(V, 8888);
                    else
                        //  Add another multi-level subvec
                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " level " | V.Level-1 |
                                " sub vec, V.Count was " | V.Count)
                        end if;
                        V.Subvecs[V.Width] :=
                          (Level => V.Level-1,
                           Width => 0,
                           Subvecs => Create(Vec_Of_Vec_Length, null))
                        //Rep_Ok(V, 9999);

                        //  Count not increased yet
                        Next_Count := V.Count
                    end if
                else
                    //  Must add another level
                    if Debug then
                        Println("Adding another level, V.Level was " |
                          V.Level | ", V.Count was " | V.Count |
                          ", Next_Count = " | Next_Count)
                    end if;
                    var Old_V <== V
                    V := (Level => Old_V.Level+1,
                          Count => Old_V.Count,
                          Width => 1,
                          Subvecs => Create (Vec_Of_Vec_Length, null))
                    V.Subvecs[1] <== Old_V

                    //  Count not increased yet
                    Next_Count := V.Count
                    //  Will loop around to extend this multi-level structure
                end if
            end if
            //Rep_Ok(V, 1212);
            V.Count := Next_Count
            //Rep_Ok(V, 2323);
            if Next_Count == New_Count then
                exit loop
            end if
            if Debug then
                Println("Trying again, Next_Count = " | Next_Count |
                  ", New_Count = " | New_Count)
                Println("V.Level = " | V.Level | ", V.Width = " | V.Width);
            end if;
            //Rep_Ok(V, 2);
        end loop
        //Rep_Ok(V, 2222);
    end func Expand_Count

  exports
    op "[]"() -> Vector is
        return (Level => 0, Count => 0, Data => null)
    end op "[]"

    func Create(Length : Univ_Integer; Value : Element_Type) {N >= 0} 
        -> Vector is

        if Length <= Leaf_Vec_Capacity then
            return (Level => 0,
                    Count => Length, Data => Create (Length, Value))
        else
            const More_Needed := Length - Leaf_Vec_Capacity;

            var Result : Vector :=
                (Level => 0, Count => Leaf_Vec_Capacity,
                 Data => Create (Leaf_Vec_Capacity, Value))
            Result.Expand_Count(More_Needed);
            if Value not null then
                for I in 1 .. More_Needed loop
                    Result[Leaf_Vec_Capacity + I] := Value
                end loop
            end if;
            //Rep_Ok(Result, 3);
            return Result;
        end if;

    end func Create

    func Length(V : Vector) -> Univ_Integer is
        //Rep_Ok(V, 4);
        return V.Count
    end func Length

    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type is
        //Rep_Ok(V, 5);
        if Index <= 0 or else Index > V.Count then
           //var IO := IO::Get_IO();
           //IO.Stderr.Println("Vector index " | Index |
           //    " out of bounds 1 .. " |
           Println("Vector index " | Index | " out of bounds 1 .. " |
             V.Count)
           {*vector_index_out_of_bounds* Index in 1..V.Count}
        end if
        if V.Level == 0 then
            //  Simple case
            return V.Data[Index]
        else
           const Subvec_Size := Subvec_Capacity[V.Level]
           const Which_Subvec := (Index-1) / Subvec_Size + 1
           const Subvec_Index := (Index-1) mod Subvec_Size + 1
           //  Recurse with appropriate subvec
           return V.Subvecs[Which_Subvec][Subvec_Index]
        end if;
    end op "indexing"

    op "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      -> Vector is
      // a "read-only" slice
        //Rep_Ok(V, 6);
        return [for I in Index_Set => V[I]]
    end op "slicing"

    op "index_set"(V : Vector) -> Countable_Range<Univ_Integer> is
        //Rep_Ok(V, 7);
        return 1..Length(V)
    end op "index_set"

    op "<|="(var V : Vector; var Elem : optional Element_Type) is
        //Rep_Ok(V, 8);
        Expand_Count(V, Amount => 1)
        //Rep_Ok(V, 9);
        V[V.Count] <== Elem
        //Rep_Ok(V, 10);
    end op "<|="

    op "|="(var V : Vector; Elem : Element_Type) is
        //Rep_Ok(V, 11);
        Expand_Count(V, Amount => 1)
        //Rep_Ok(V, 12);
        V[V.Count] := Elem
        //Rep_Ok(V, 13);
    end op "|="
    
    op "|="(var V : Vector; Right : Vector) is
        //Rep_Ok(V, 14);
        const Orig_Count := V.Count
        if Orig_Count == 0 then
            // Just copy right
            V := Right;
        elsif Right.Count > 0 then
            // Grow V, and then copy in Right
            Expand_Count(V, Right.Count)
            for I in 1..Right.Count loop
                //Rep_Ok(V, 15);
                if Debug then
                    Println(V.Level | ", " | V.Count | ", " | V.Width);
                end if;
                V[I+Orig_Count] := Right[I]
                //Rep_Ok(V, 16);
            end loop
        end if
        //Rep_Ok(V, 17);
    end op "|="

    op "|"(Left, Right : Vector) -> Result : Vector is
        //Rep_Ok(Left, 18);
        //Rep_Ok(Right, 19);
        // Copy left into result, and then add in the Right elements
        if Left.Count == 0 then
            // Left is null Vector; result is determined by Right
            Result := Right
        else
            // Start with Left
            Result := Left
            //Rep_Ok(Result, 20);
            Result |= Right
        end if
        //Rep_Ok(Result, 21);
    end op "|"

    op "|"(Left : Vector; Right : Element_Type) -> Result : Vector is
        //Rep_Ok(Left, 22);
        Result := Left
        //Rep_Ok(Result, 23);
        Result |= Right
        //Rep_Ok(Result, 24);
    end op "|"

end class PSL::Core::Vector

func PSL::Test::Test_Vector() is
    var V : Vector<Univ_Integer> := []
    var U : Vector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " | V[1] | ", " | V[2])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 1..Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    Println("\"indexing\"(V, 12) := 33;")
    "indexing"(V, 12) := 33
    for I in 1..Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 1..Length(Slice) forward loop
        Println("Slice[" | I | "] = " | Slice[I])
    end loop

    func Equal(Left, Right : Vector<Univ_Integer>) -> Boolean is
        if |Left| == |Right| then
            for each [I => L] of Left concurrent loop
                if L != Right[I] then
                    return #false;
                end if;
            end loop;
        else
            return #false;
        end if;
        return #true;
    end func Equal;

    var W : Vector<Univ_Integer> := Create(253, 1)
    const Correct : Vector<Univ_Integer> := [1, 1, 2, 2, 2, 2];
    W |= 2; W |= 2; W |= 2; W |= 2
    {Length(W) == 257}
    {Equal(W[252 .. 257], Correct)}

    var Y : Vector<Univ_Integer> := Create(256, 1)
    //Y |= 2; Y |= 2; Y |= 2; Y |= 2
    Y |= [2, 2, 2, 2];
    {Length(Y) == 260}
    {Equal(Y[255 .. 260], Correct)}
    W |= Y;

    var Z : Vector<Univ_Integer> := Create(300, 1)
    Z |= 2; Z |= 2; Z |= 2; Z |= 2
    {Length(Z) == 304}
    {Equal(Z[299 .. 304], Correct)}
    Z |= Correct;
    Z |= W;
    Z[257] := 4;
    const J := Z[1];
    var H := Z[12];

    var X : Vector<Univ_Integer> := [1];
    const XX : Vector<Univ_Integer> := Create(257, 1);
    X |= XX;

    var Strings : Vector<Univ_String> := [];
    Strings |= "hi";
    Strings |= "ho";
    Strings := Strings | "hi";
    Strings |= "";
    Strings[|Strings|] := "ho";
    Strings |= ["it's", "off", "to"];
    const To_Add : Vector<Univ_String> := [] | "work" | "we" | "go";
    Strings |= To_Add;
    for (each S of Strings; Sep := "" then " ") forward loop
        Print(Sep | S);
    end loop;
    Print('\n');

    var LL : Vector<Vector<Univ_String>> := [];
    LL |= ["one", "two", "three"];
    LL |= ["ten", "twenty", "thirty"];
    for each Vec of LL forward loop
        for each S of Vec forward loop
            Print(S);
        end loop
    end loop
    Print('\n');
end func PSL::Test::Test_Vector

func PSL::Test::Test_Big_Vector () is
    var Big_V : Vector<Univ_Integer> := []
    var Ran := Random::Start()
    const N := 1_000_000
    Println("Building a vector of length " | N);
    for I in 1..N forward loop
        Big_V |= Ran.Next() mod N
        if |Big_V| mod (N/40) == 0 then
            Println("Big_V[" | |Big_V| | "] = " | Big_V[|Big_V|])
        end if
    end loop
    Println("|Big_V| = " | |Big_V|)
end func PSL::Test::Test_Big_Vector

interface PSL::Core::ZVector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable vector, indexed by Univ_Integer, 0..Length-1
    op "[]"() -> ZVector
    func Create(Length : Univ_Integer; Value : Element_Type) -> ZVector
    op "indexing"(ref V : ZVector; Index : Univ_Integer) -> 
      ref Element_Type
    op "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      -> ZVector
      // a "read-only" slice
    op "index_set"(V : ZVector) -> Countable_Range<Univ_Integer>
    op "|="(var V : ZVector; Elem : Element_Type)
    op "|="(var V : ZVector; Right : ZVector)
    op "<|="(var V : ZVector; var Elem : optional Element_Type)
    op "|"(Left, Right : ZVector) -> ZVector
    op "|"(Left : ZVector; Elem : Element_Type) -> Result : ZVector
    func Length(V : ZVector) -> Univ_Integer
    op "magnitude"(ZVector) -> Univ_Integer is Length
end interface PSL::Core::ZVector
    
class PSL::Core::ZVector is
  // Extendable ZVector, indexed by Univ_Integer, 0..Length-1
    var Vec : Vector<Element_Type>

  exports
    op "[]"() -> ZVector is
        return (Vec => [])
    end op "[]"

    func Create(Length : Univ_Integer; Value : Element_Type) -> ZVector is
        return (Vec => Create(Length, Value))
    end func Create

    func Length(V : ZVector) -> Univ_Integer is
        return Length(V.Vec)
    end func Length

    op "indexing"(ref V : ZVector; Index : Univ_Integer) -> 
      ref Element_Type is
        {Index in 0..<Length(V.Vec)}  // Index out of bounds
        return V.Vec[Index+1]
    end op "indexing"

    op "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      -> ZVector is
      // a "read-only" slice
        return [for I in Index_Set => V[I]]
    end op "slicing"

    op "index_set"(V : ZVector) -> Countable_Range<Univ_Integer> is
        return 0..<Length(V.Vec)
    end op "index_set"

    op "<|="(var V : ZVector; var Elem : optional Element_Type) is
        V.Vec <|= Elem
    end op "<|="

    op "|="(var V : ZVector; Elem : Element_Type) is
        V.Vec |= Elem
    end op "|="

    op "|="(var V : ZVector; Right : ZVector) is
        V.Vec |= Right.Vec
    end op "|="
    
    op "|"(Left, Right : ZVector) -> Result : ZVector is
        return (Vec => Left.Vec | Right.Vec)
    end op "|"

    op "|"(Left : ZVector; Elem : Element_Type) -> Result : ZVector is
        return (Vec => Left.Vec | Elem)
    end op "|"

end class PSL::Core::ZVector

func PSL::Test::Test_ZVector() is
    var V : ZVector<Univ_Integer> := []
    var U : ZVector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " | V[0] | ", " | V[1])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 0..<Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    Println("\"indexing\"(V, 11) := 33;")
    "indexing"(V, 11) := 33
    for I in 0..<Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 0..<Length(Slice) forward loop
        Println("Slice[" | I | "] = " | Slice[I])
    end loop
end func PSL::Test::Test_ZVector
interface PSL::Core::ZString<> is
  // A universal string with characters indexed starting at 0
    op "from_univ"(Univ : Univ_String) -> ZString
      is import(#identity)
    op "to_univ"(ZStr : ZString) -> Univ_String
      is import(#identity)

    func Print(ZString) is import(#print_string)
    func Println(ZString) is import(#println_string)
    func Readln() -> optional ZString is import(#read_string)

    op "*"(Left : Univ_Integer; Right : ZString) -> ZString
        // Produce specified number of "Right" strings in a row
    op "*"(Left : ZString; Right : Univ_Integer) -> ZString
        // Produce specified number of "Left" strings in a row

    op "|"(Left, Right : ZString) -> ZString 
      is import(#concat_string)

    op "=?"(Left, Right : ZString) -> Ordering
      is import(#string_compare)

    op "|="(var Left : ZString; Right : ZString)
      is import(#assign_concat_string)

    op "indexing"(Str : ZString; Index : Univ_Integer<>) -> Univ_Character
        // a "read-only" element, indexed 0..<Length(Str)

    op "index_set"(Str : ZString) -> Countable_Range<Univ_Integer>
        // Return set of indices for string

    op "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> ZString
        // a "read-only" slice

    func Length(Str : ZString) -> Univ_Integer
      is import(#string_length)

    op "magnitude"(ZString) -> Univ_Integer is Length

    func Hash(Val : ZString) -> Univ_Integer
      is import(#hash_string)

    op "|"(Left : ZString; Right : Right_Type is Imageable<>) 
      -> ZString

    op "|"(Left : Left_Type is Imageable<>; Right : ZString)
      -> ZString

    op "|="(var Left : ZString; Right : Right_Type is Imageable<>)

    // Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) -> ZVector<Univ_Character>
    func From_ZVector(Vec : ZVector<Univ_Character>) -> ZString

    func Replace(Orig : ZString;
      Char : Univ_Character; With : Univ_Character) -> ZString
    //  Replace each appearance of Char with "With"

end interface PSL::Core::ZString
    
class PSL::Core::ZString is
  // A universal string with characters indexed starting at 0
    var U_Str : Univ_String

  exports
    op "indexing"(Str : ZString; Index : Univ_Integer<>) -> Univ_Character is
        // a "read-only" element, indexed 0..<Length(Str)
        return Str.U_Str[Index+1]
    end op "indexing"

    op "index_set"(Str : ZString) -> Countable_Range<Univ_Integer> is
        // Return set of indices for string
        return 0 ..< |Str.U_Str|
    end op "index_set"

    op "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> ZString is
        // a "read-only" slice
        return (U_Str => Str.U_Str[Index_Set.First <.. Index_Set.Last+1])
    end op "slicing"

    op "*"(Left : Univ_Integer; Right : ZString) -> ZString is
        // Produce specified number of "Right" strings in a row
        return (U_Str => Left * Right.U_Str)
    end op "*"

    op "*"(Left : ZString; Right : Univ_Integer) -> ZString is
        // Produce specified number of "Left" strings in a row
        return Right * Left   // Just pass the buck to other "*"
    end op "*"

    op "|"(Left : ZString; Right : Right_Type is Imageable<>) 
      -> ZString is
        if Right is null then
            return (U_Str => Left.U_Str | "null")
        else
            return (U_Str => Left.U_Str | Right_Type::To_String(Right))
        end if
    end op "|"

    op "|"(Left : Left_Type is Imageable<>; Right : ZString)
      -> ZString is
        if Left is null then
            return (U_Str => "null" | Right.U_Str)
        else
            return (U_Str => Left_Type::To_String(Left) | Right.U_Str)
        end if
    end op "|"

    op "|="(var Left : ZString; Right : Right_Type is Imageable<>) is
        if Right is null then
            Left.U_Str |= "null"
        else
            Left.U_Str |= Right_Type::To_String(Right)
        end if
    end op "|="

    // Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) -> ZVector<Univ_Character> is
        return [for I in 0 ..< Length(Str) => Str[I]]
    end func To_ZVector

    func From_ZVector(Vec : ZVector<Univ_Character>) -> ZString is
        var Result : ZString := "";
        for each C of Vec forward loop
            Result |= C;
        end loop;
        return Result;
    end func From_ZVector;

    func Replace(Orig : ZString;
      Char : Univ_Character; With : Univ_Character) -> Result : ZString is
    //  Replace each appearance of Char with "With"

       Result := ""

       var Prev_Match := -1
       for each [I => C] of Orig forward loop
          //  Look for a match
          if C == Char then
             // Concatenate on unchanged part and replacement character
             Result |= Orig[Prev_Match <..< I] | With
             Prev_Match := I;
          end if
       end loop

       if Prev_Match < 0 then
          Result := Orig
       elsif Prev_Match < |Orig|-1 then
          Result |= Orig[Prev_Match <..< |Orig|]
       end if
    end func Replace

end class PSL::Core::ZString

func PSL::Test::Test_ZString() is
    const U : ZString := "tab\t"
    const T := U[3]
    Println("U = " | U | ", Length(U) = " | Length(U) | ", U[4] = '" | T | "'")
    const X : ZString := "this is a string"
    const Y := X[2]
    {Y == 'i'} // string indexing problem
    const Z := X[5..6]
    {Z == "is"} // string slicing problem, expected 'is', found Z 
    Println("X = " | X | ", X[2] = " | Y | ", X[5..6] = " | Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " | "hello")

    const Seven_Xs :ZString := "x" * 7
    {Seven_Xs == "xxxxxxx"} // Char multiplication check

    Println("Here are seven x's: " | Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
    Println("X.Replace('s', With => 'x') = " | X.Replace('s', With => 'x'))
end func PSL::Test::Test_ZString
interface PSL::Containers::Slice<Array_Type is Indexable<>> is
  // A sliceable array.
    const First : Array_Type::Index_Type
    const Last : Array_Type::Index_Type

    func Length(S : Slice) -> Univ_Integer
        // Return length of slice (i.e. Last - First + 1)

    op "magnitude"(Slice) -> Univ_Integer is Length
        // Allows use of |...| operator

    op "slicing"(ref A : Array_Type) -> ref Slice
        // Convert an array into a slice covering 1..Length(A)

    op "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice
        // Slice of an array

    op "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice
        // Slice of a slice

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type
        // Index into a slice

    op "index_set"(S : Slice) -> Countable_Range<Array_Type::Index_Type>
end interface PSL::Containers::Slice

class PSL::Containers::Slice is
    ref Arr : Array_Type
  exports
    func Length(S : Slice) -> Univ_Integer is
        // Return length of slice (i.e. Last - First + 1)
        return S.Last - S.First + 1
    end func Length

    op "slicing"(ref A : Array_Type) -> ref Slice is
        // Convert an array into a slice covering whole array
        const A_Bounds := "index_set"(A)
        return (First => A_Bounds.First, Last => A_Bounds.Last, Arr => A)
    end op "slicing"

    op "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of an array
        const A_Bounds := "index_set"(A)
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= A_Bounds.First and then 
            Bounds.Last <= A_Bounds.Last)} //slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => A)
    end op "slicing"

    op "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of a slice
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= S.First and then Bounds.Last <= S.Last)}
          // slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => S.Arr)
    end op "slicing"

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type is
        // Index into a slice
        {Index >= S.First and then Index <= S.Last}
          // array index out of bounds
        return S.Arr[Index]
    end op "indexing"
    
    op "index_set"(S : Slice) -> Countable_Range<Array_Type::Index_Type> is
        return S.First .. S.Last
    end op "index_set"
end class PSL::Containers::Slice
interface PSL::Core::Enum<Literals : Vector<Univ_Enumeration>> is
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit == Univ)}
      -> Enum
    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)}

    op "=?"(Left, Right : Enum) -> Ordering
      is import("=?")

    // Functions for Imageable
    func To_String(Val : Enum) -> Univ_String
    func From_String(Str : Univ_String) -> optional Enum

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Enum) -> Enum 
      is import("+")
    op "+"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("+")
    op "-"(Left, Right : Enum) -> Univ_Integer 
      is import("-")
    op "-"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("-")

    // TBD: These should be properties some day (e.g. Color#first).
    func First()->Enum
    func Last()->Enum
    func Range()->Countable_Range<Enum> is "[..]" in Countable_Range<Enum>

    op "[..]"() -> Countable_Range<Enum> is in Countable_Range<Enum>

    func Hash(Val : Enum) -> Univ_Integer
      is import(#identity)

    op ".."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "<.."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "<..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "|"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>

    func Min(Left, Right : optional Enum) -> optional Enum
      is import(#min)
    func Max(Left, Right : optional Enum) -> optional Enum
      is import(#max)
end interface PSL::Core::Enum

class PSL::Core::Enum is
    const Value : Univ_Integer
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit == Univ)}
      -> Enum is
        for I in 1 .. |Literals| loop
            if Literals[I] == Univ then
                return (Value => I-1)
            end if
        end loop
        {*bad_enum_literal* #false}
        return null
    end op "from_univ"

    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)} is
        if Val is null then
            return null
        else
            return Literals[Val.Value+1]
        end if
    end op "to_univ"

    // Functions for Imageable
    func To_String(Val : Enum) -> Univ_String is
        return Univ_Enumeration::To_String([[Val]])
    end func To_String

    func From_String(Str : Univ_String) -> optional Enum is
        return Univ_Enumeration::From_String(Str)
    end func From_String

    func First()->Enum is
        return (Value => 0)
    end func First

    func Last()->Enum is
        return (Value => |Literals| - 1)
    end func Last

end class PSL::Core::Enum

func PSL::Test::Test_Enum() is
    type Color is Enum< [#red, #green, #blue] >
    type Day_Of_Week is 
       Enum< [#Monday, #Tuesday, #Wednesday, #Thursday, 
        #Friday, #Saturday, #Sunday] >

    for C : Color in Color::First() .. Color::Last() forward loop
        Println("Next color = " | C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " | C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " | D3)
    end loop

    {#Monday in Day_Of_Week}

end func PSL::Test::Test_Enum
func Test_Enum() is
    PSL::Test::Test_Enum()
end func Test_Enum
interface PSL::Containers::Map
  <Key_Type is Hashable<>; Value_Type is Assignable<>> is
  // A hashed-map module
    type Pair is Key_Value<Key_Type, Value_Type>

    op "[]"() -> Map

    op "|="(var Left : Map; Right : Pair)
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.

    op "|"(Left : Map; Right : Pair) -> Map
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.

    op "<|="(var Left : Map; var Right : optional Pair)
        // Move Key/Value pair into map, leaving Right null

    op "<|="(var Left : Map; var Right : Map)
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.

    op "+="(var Left : Map; Right : Pair) is "|="
        // A synonym for adding a key=>value pair

    op "in"(Left : Key_Type; Right : Map) -> Boolean
        // Return True if given key has a mapping in the Map

    op "-="(var M : Map; Key : Key_Type)   // aka Exclude
        // Remove mapping for Right, if present

    op "index_set"(M : Map) -> Set<Key_Type>
        // Return set of keys with mappings

    func Keys(M : Map) -> Set<Key_Type> is "index_set"

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type
        // Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Map) -> optional Pair
        // Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Map) -> Univ_Integer
        // Number of mappings in the table

    op "magnitude"(Map) -> Univ_Integer is Count

    func Is_Empty(M : Map) -> Boolean
        // Return True if no mappings in the table

    func Dump_Statistics(M : Map)
      // A debugging routine to show bucket sizes of Map

end interface PSL::Containers::Map

class PSL::Containers::Map is
  // A hashed-map module

    var Data : Basic_Map<Key_Value<Key_Type, Value_Type>>

  exports
    op "[]"() -> Map is
        return (Data => [])
    end op "[]"

    op "|"(Left : Map; Right : Pair) -> Result : Map is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.
        Result := Left
        Result.Data |= Right
    end op "|"

    op "|="(var Left : Map; Right : Pair) is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.
        Left.Data |= Right
    end op "|="

    op "<|="(var Left : Map; var Right : optional Pair) is
        // Move Key/Value pair into map, leaving Right null
        Left.Data <|= Right
    end op "<|="

    op "<|="(var Left : Map; var Right : Map) is
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.
        loop
            var Right_Elem for Left := Remove_Any(Right)
            if Right_Elem is null then
                return   // All done
            end if

            Left.Data <|= Right_Elem
        end loop
    end op "<|="

    op "in"(Left : Key_Type; Right : Map) -> Boolean is
        return Left in Right.Data
    end op "in"

    op "-="(var M : Map; Key : Key_Type) is
      // Remove the given key from the Map, if present
        M.Data -= Key
    end op "-="
   
    op "index_set"(M : Map) -> Result : Set<Key_Type> is
        // Return set of keys with mappings
        if M.Data is null then
            return []
        else
           return "index_set"(M.Data)
        end if
    end op "index_set"

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type is
        // Used for references to M[Key]; requires the Key to be in M.
        return M.Data[Key].Value
    end op "indexing"

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type is
        // Used for assignments to M[Key]; Key is added to M if not present
        return "var_indexing"(M.Data, Key).Value
    end op "var_indexing"

    func Count(M : Map) -> Univ_Integer is
        return Count(M.Data)
    end func Count

    func Is_Empty(M : Map) -> Boolean is
        // Return True if no mappings in the table
        return Is_Empty(M.Data)
    end func Is_Empty

    func Remove_Any(var M : Map) -> Result : optional Pair is
        return Remove_Any(M.Data)
    end func Remove_Any

    func Dump_Statistics(M : Map) is
      // A debugging routine to show bucket sizes of Map
        Dump_Statistics(M.Data)
    end func Dump_Statistics

end class PSL::Containers::Map

func PSL::Test::Test_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    type Enum_String_Map is Map<Univ_Enumeration, Univ_String>

    var M : Enum_String_Map := [X => Y, A => B]

    Println("Count = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
        Println(K | " in M = " | (K in M))
    end loop

    Println("#xy in M = " | (#xy in M))

    M -= X

    Println("Count after deletion = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    M -= A

    Println("Count after deletion = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    var Ran := Random::Start(Hash(A))
    var MUI : Map<Univ_Integer, Univ_Integer> := []

    Println("Adding 100 random pairings to Map.")
    for I in 1..100 loop
        const Key := Next(Ran) mod 100
        const Value := Next(Ran) mod 100
        MUI[Key] := Value
    end loop
    Println("Map is now of count = " | Count(MUI))

    for each [K => V] of MUI loop
        Println("Mapping " | K | " => " | V)
        Println("MUI[" | K | "] = " | MUI[K])
    end loop

    for (Pair in MUI; I in 1..60 forward) loop
        Print(" [" | Pair.Key | " => " | Pair.Value | "]")
        if I mod 5 == 0 then
            Print('\n')
        end if
    end loop

    if Count(MUI) > 60 then
        Println(" ...")
    elsif Count(MUI) mod 5 != 0 then
        Print('\n')
    end if

end func PSL::Test::Test_Map
interface PSL::Containers::Two_Way_Map
  <Key_Type is Imageable<>; Value_Type is Imageable<>>   // TBD: use Hashable
  extends Forward : Map<Key_Type, Value_Type> is
    type Pair2 is Key_Value<Key_Type, Value_Type>

    op "[]"() -> Two_Way_Map

    op "|="(var Left : Two_Way_Map; Right : Pair2)
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any.

    op "|"(Left : Two_Way_Map; Right : Pair2) -> Two_Way_Map
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any in result.

    op "<|="(var Left : Two_Way_Map; var Right : optional Pair2)
        // Move Key/Value pair into Two_Way_map, leaving Right null

    op "<|="(var Left : Two_Way_Map; var Right : Two_Way_Map)
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.

    op "-="(var M : Two_Way_Map; Key : Key_Type)   // aka Exclude
        // Remove mapping for Right, if present

    op "var_indexing"(ref var M : Two_Way_Map; Key : Key_Type) 
      -> ref var optional Value_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Key_Of (M : Two_Way_Map; Value : Value_Type) -> optional Key_Type
        // Use reverse mapping to determine key given value

    func Rev_Map (M : Two_Way_Map) -> Map<Value_Type, Key_Type>
        // Return a copy of the reverse map

end interface PSL::Containers::Two_Way_Map

class PSL::Containers::Two_Way_Map is
    var Reverse : Map<Value_Type, Key_Type>
    var Unreversed : Set<Key_Type>  //  Keys not yet in Reverse map

    func Add_Unreversed(var M : Two_Way_Map) is
      //  Add Unreversed Keys into M.Reverse
        while not Is_Empty (M.Unreversed) loop
            var Key := Remove_Any(M.Unreversed)
            M.Reverse |= [M.Forward[Key] => Key]
        end loop
    end func Add_Unreversed

  exports

    op "[]"() -> Two_Way_Map is
        return (Forward => [], Reverse => [], Unreversed => [])
    end op "[]"

    op "|="(var Left : Two_Way_Map; Right : Pair2) is
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any.
        Add_Unreversed (Left)
        Left.Forward |= Right
        Left.Reverse |= [Right.Value => Right.Key]
    end op "|="

    op "|"(Left : Two_Way_Map; Right : Pair2) -> Result : Two_Way_Map is
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any in result.
        Result := Left
        Add_Unreversed (Result)
        Result |= Right
    end op "|"

    op "<|="(var Left : Two_Way_Map; var Right : optional Pair2) is
        // Move Key/Value pair into Two_Way_map, leaving Right null
        Add_Unreversed (Left)
        Left.Reverse |= [Right.Value => Right.Key]
        Left.Forward <|= Right
    end op "<|="

    op "<|="(var Left : Two_Way_Map; var Right : Two_Way_Map) is
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.
        Add_Unreversed (Left)
        loop
            var KV := Remove_Any(Right)
            if KV is null then
                exit loop
            end if
            Left <|= KV
        end loop
    end op "<|="

    op "-="(var M : Two_Way_Map; Key : Key_Type) is   // aka Exclude
        // Remove mapping for Right, if present
        Add_Unreversed (M)
        if Key in M.Forward then
           M.Reverse -= M.Forward[Key]
           M.Forward -= Key
        end if
    end op "-="

    op "var_indexing"(ref var M : Two_Way_Map; Key : Key_Type) 
      -> ref var optional Value_Type is
        // Used for assignments to M[Key]; Key is added to M if not present
        Add_Unreversed (M)
        if Key not in M then
            //  Don't have value of Key so can't add to M.Reverse yet
            M.Unreversed |= Key
        end if
        return "var_indexing"(M.Forward, Key)
    end op "var_indexing"

    func Key_Of (M : Two_Way_Map; Value : Value_Type) -> optional Key_Type is
        // Use reverse mapping to determine key given value
        if Value in M.Reverse then
           // Found in reverse mapping
           return M.Reverse[Value]
        else
           // Search through Unreversed keys
           for K in M.Unreversed loop
               if M.Forward[K] == Value then
                   return K
               end if
           end loop
           // Not there
           return null
        end if
    end func Key_Of

    func Rev_Map (M : Two_Way_Map) -> Result : Map<Value_Type, Key_Type> is
        // Return a copy of the reverse map, after adding the unreversed keys
        var Copy for Result := M;
        Add_Unreversed (Copy)
        
        Result <== Copy.Reverse
        Copy := null
    end func Rev_Map

end class PSL::Containers::Two_Way_Map
interface PSL::Core::Float<Digits : Univ_Integer := 15> is
  // A floating point type that provides at least the
  // given number of digits of precision.

    op "from_univ"(Univ : Univ_Real) -> Float
      is import(#identity)

    op "to_univ"(Val : Float) -> Univ_Real
      is import(#identity)

    op "+"(Right : Float) -> Float
      is import(#identity)

    op "-"(Right : Float) -> Float
      is import(#real_negate)

    op "abs"(Right : Float) -> Float
      is import(#real_abs)

    op "magnitude"(Float) -> Float is "abs"

    op "+"(Left, Right : Float) -> Result : Float 
      is import(#real_add)

    op "-"(Left, Right : Float) -> Result : Float
      is import(#real_subtract)

    op "*"(Left, Right : Float) -> Result : Float 
      is import(#real_multiply)

    op "*"(Left : Float; Right : Univ_Integer) -> Result : Float 
      is import(#real_int_multiply)

    op "*"(Left : Univ_Integer; Right : Float) -> Result : Float

    op "/"(Left, Right : Float) -> Result : Float
      is import(#real_divide)

    op "/"(Left : Float; Right : Univ_Integer) -> Result : Float
      is import(#real_int_divide)

    op "**"(Left : Float; Right : Univ_Integer) -> Float
      is import(#real_exp)

    op "+="(var Left : Float; Right : Float) 
      is import(#real_assign_add)

    op "-="(var Left : Float; Right : Float) 
      is import(#real_assign_subtract)

    op "*="(var Left : Float; Right : Float) 
      is import(#real_assign_multiply)

    op "/="(var Left : Float; Right : Float) 
      is import(#real_assign_divide)

    op "**="(var Left : Float; Right : Univ_Integer) 
      is import(#real_assign_exp)


    op "=?"(Left, Right : Float) -> Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Float) -> optional Float
      is import(#real_min)
    func Max(Left, Right : optional Float) -> optional Float
      is import(#real_max)

    func Hash(Val : Float) -> Univ_Integer
      is import(#identity)

    func Round_To_Int(Val : Float) -> Univ_Integer
      is import(#round_to_int)

    func Int_To_Float(Int : Univ_Integer) -> Float
      is import(#int_to_real)

    func To_String(Val : Float) -> Univ_String
      is import(#to_string_real)

    func From_String(Str : Univ_String) -> optional Float
      is import(#from_string_real)

    func Print(X : Float) is import(#print_real)
    func Println(X : Float) is (Println(To_String(X)))

    op "in"(Left : Float; Right : Range_Set<Float>) -> Boolean
      is in Range_Set<Float>
        // "in" defined in Range_Set

    
end interface PSL::Core::Float

class PSL::Core::Float is
    const Value : Univ_Real
  exports
    op "*"(Left : Univ_Integer; Right : Float) -> Result : Float is
        // Hand off to built-in real*int op
        return Right * Left
    end op "*"
end class PSL::Core::Float
    
func PSL::Test::Test_Float() is
    type My_Float is Float<Digits => 8>

    var X : My_Float := 3.5
    var Y : My_Float := 5.22
    var Z : My_Float := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny := 0.000023
    Println("Teeny = " | Teeny)
    var Small := 0.005
    Println("Small = " | Small)
    var Medium := 235.123
    Println("Medium = " | Medium)
    var Big := 11.0**5
    Println("Big = " | Big)
    var Huge := 13.0**15
    Println("Huge = " | Huge)

    var X2 : My_Float := 3.5 * 2

    Println("X * 2 = " | X * 2 | ", 2 * X = " | 2 * X | ", X2 = " | X2)
    Println("X / 2 = " | X / 2 )

    if X in 1.5 ..< 3.6 then
        Println("X *is* in 1.5 ..< 3.6")
    else
        Println("X *not* in 1.5 ..< 3.6??")
    end if

    Println("X in 1.5 ..< 3.5 = " | (X in 1.5 ..< 3.5) )
end func PSL::Test::Test_Float
interface PSL::Core::Fixed<Delta : Univ_Real> is
  // Fixed point types, represented as an integer
  // multiple of the given Delta
    op "from_univ"(Univ : Univ_Real) -> Fixed
    op "to_univ"(Val : optional Fixed) -> optional Univ_Real

    op "+"(Right : Fixed) -> Fixed
      is import(#identity)

    op "-"(Right : Fixed) -> Fixed
      is import(#negate)

    op "abs"(Right : Fixed) -> Fixed
      is import("abs")

    op "magnitude"(Fixed) -> Fixed is "abs"

    op "+"(Left, Right : Fixed) -> Fixed
      is import("+")
    op "-"(Left, Right : Fixed) -> Fixed
      is import("-")
    op "*"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_mul)
    op "*"(Left : Univ_Real; Right : Fixed) -> Fixed
      is import(#real_fixed_mul)
    op "*"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("*")
    op "*"(Left : Univ_Integer; Right : Fixed) -> Fixed
      is import("*")
    op "/"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_div)
    op "/"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("/")

    op "+="(var Left : Fixed; Right : Fixed) 
      is import("+=")

    op "-="(var Left : Fixed; Right : Fixed) 
      is import("-=")

    op "*="(var Left : Fixed; Right : Fixed) 
      is import("*=")

    op "/="(var Left : Fixed; Right : Univ_Integer) 
      is import("/=")

    op "/="(var Left : Fixed; Right : Univ_Real)

    op "=?"(Left, Right : Fixed) -> Ordering
      is import("=?")

    func Min(Left, Right : optional Fixed) -> optional Fixed
      is import(#min)
    func Max(Left, Right : optional Fixed) -> optional Fixed
      is import(#max)

    func Hash(Val : Fixed) -> Univ_Integer
      is import(#identity)

    func Round_To_Int(Val : Fixed) -> Univ_Integer

    func To_String(Val : Fixed) -> Univ_String

    func From_String(Str : Univ_String) -> optional Fixed

    func Print(X : Fixed)
    func Println(X : Fixed) is (Println(To_String(X)))

    op "in"(Left : Fixed; Right : Range_Set<Fixed>) 
      -> Boolean is in Range_Set<Fixed>
    
end interface PSL::Core::Fixed

class PSL::Core::Fixed is
    const Value : Univ_Integer

  exports
    op "from_univ"(Univ : Univ_Real) -> Fixed is
        return (Value => Univ_Real::Round_To_Int(Univ/Delta))
    end op "from_univ"

    op "to_univ"(Val : optional Fixed) -> optional Univ_Real is
        if Val is null then
            return null
        else
            return Delta * Int_To_Real(Val.Value)
        end if
    end op "to_univ"

    op "/="(var Left : Fixed; Right : Univ_Real) is
        Left := Left / Right
    end op "/="

    func Print(X : Fixed) is
        var Val : Univ_Real := [[X]]
        Print(Val)
    end func Print

    func To_String(Val : Fixed) -> Univ_String is
        return Univ_Real::To_String([[Val]])
    end func To_String

    func From_String(Str : Univ_String) -> optional Fixed is
        return Univ_Real::From_String(Str)
    end func From_String

    func Round_To_Int(Val : Fixed) -> Univ_Integer is
        return Univ_Real::Round_To_Int([[Val]])
    end func Round_To_Int

end class PSL::Core::Fixed

func PSL::Test::Test_Fixed(X : Univ_Real) is
    type My_Fixed is Fixed<Delta => 1.0E-6>

    var XTI : My_Fixed := X
    const Minute : My_Fixed := 60.0
    Println("X = " | XTI)
    Println("X * 2 = " | (XTI*2))
    Println("X + X = " | (XTI + XTI))
    Println("X - X = " | (XTI - XTI))
    Println("X / 2 = " | (XTI / 2))
    Println("X / 2.0 = " | (XTI / 2.0))
    Println("X * 3.0 = " | (XTI * 3.0))
    Println("5.0 * X = " | (5.0 * XTI))
    Println("-5.0 * X = " | (-5.0 * XTI))
    Println("-5.0 = " | -5.0)
    Println("Minute = " | Minute)
    Println("-5.0*Minute = " | -5.0*Minute)

    Println("Round_To_Int(X) = " | Round_To_Int(XTI))

    const Rng : Range_Set<My_Fixed> := 1.0 ..< 5.0

    Print("Rng = ")
    const Open_Ind : Map<Boolean, Univ_String> := [#false => "", #true => "<"]
    for IV in Rng forward loop
        if IV.Low != IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] | ".." | 
              Open_Ind[IV.High_Is_Open] | IV.High | " ")
        else
            Print(IV.Low | " ")
        end if
    end loop
    Print('\n')

    Println("X = " | XTI)
    Println("X in Rng = " | (XTI in Rng))

    if XTI in 1.0 ..< 5.0 then
        Println("X in 1.0 ..< 5.0")
    else
        Println("X not in 1.0 ..< 5.0")
    end if

    Println("X in 1.0 ..< 5.0 = " | (XTI in 1.0 ..< 5.0))

end func PSL::Test::Test_Fixed
interface PSL::Containers::Array
  <Elem_Type is Assignable<>; Indexed_By is Countable<>> 
  implements Indexable<Elem_Type, Indexed_By> is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    const Bounds : Countable_Range<Indexed_By>

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Array

    func Length(Arr : Array) -> Univ_Integer
    op "magnitude"(Array) -> Univ_Integer is Length

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By>

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type
    op "index_set"(Arr : Array) -> Countable_Range<Indexed_By> is Bounds
    op "<|="(var Left : Array; var Right : optional Elem_Type)
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) -> Array
    op "[]"() -> Array
end interface PSL::Containers::Array

class PSL::Containers::Array is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is Basic_Array<Elem_Type>
    var Data : Elem_Array
  exports

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Array is
        return (Data => Create(Length(Bounds), Initial_Value),
          Bounds => Bounds)
    end func Create

    func Length(Arr : Array) -> Univ_Integer is
        return Length(Arr.Data)
    end func Length

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end func Bounds

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type is
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type is
        if Length(Arr) == 0 then
            // Create a one-element array
            Arr := (Data => Create(1, null),
              Bounds => Index .. Index)
        elsif Index < Arr.Bounds.First then
            // Extend below
            Arr := (Data => 
              Elem_Array::Create(Arr.Bounds.First - Index, null) | Arr.Data,
              Bounds => Index .. Arr.Bounds.Last)
        elsif Index > Arr.Bounds.Last then
            // Extend above
            Arr := (Data => 
              Arr.Data | Elem_Array::Create(Index - Arr.Bounds.Last, null),
              Bounds => Arr.Bounds.First .. Index)
        end if
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end op "var_indexing"

    op "<|="(var Left : Array; var Right : optional Elem_Type) is
        // Add Right onto Array
        if Length(Left) == 0 then
            Left := (Data => Create(1, null),
              Bounds => Indexed_By::First() .. Indexed_By::First())
            Left[Indexed_By::First()] <== Right
        else
            Left[Left.Bounds.Last + 1] <== Right
        end if
    end op "<|="
    
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Array is
        Result := Left
        Result[Right.Key] := Right.Value
    end op "|"

    op "[]"() -> Result : Array is
        const First := Indexed_By::First()
        return (Data => Create(0, null), Bounds => First + 1 .. First)
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Array

func PSL::Test::Test_Array() is
    type Color is Enum< [#red, #green, #blue] >
    type RCB is Array<Integer<Range => 0..0xFF>, Indexed_By => Color>

    const Red : RCB := [#red => 0x33, #green => 0, #blue => 0]
    const Blue : RCB := [#red => 0, #green => 0, #blue => 0x33]
    const Yellow : RCB := [0, 0x33, 0x33]
    const White : RCB := [0xFF, 0xFF, 0xFF]
    
    const RCBs : Vector<RCB> := [Red, Blue, Yellow, White]

    for each C of RCBs forward loop
        Println("#red => " | C[#red] | ", #green => " | C[#green] |
          ", #blue => " | C[#blue])
    end loop
end func PSL::Test::Test_Array
interface PSL::Containers::Index_Pair
  <Index1_Type is Countable<>; Index2_Type is Countable<>> is
  // Two countable indices which can be combined to form an 2D array index
    const Index1 : Index1_Type
    const Index2 : Index2_Type

    func Nth_Pair
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       N : Univ_Integer) -> optional Index_Pair
      // Return Nth Pair given bounds for each of 2 index types
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2)
      // presuming second index varies fastest.
      // Return null if N out of range.

    func Pair_Position
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       Pair : Index_Pair) -> optional Univ_Integer
      // Return position of Pair within bounds
      // presuming Pair.Index1 in Bounds1 and Pair.Index2 in Bounds2
      // and second index varies fastest.
      // Return null if Pair out of range.

end interface PSL::Containers::Index_Pair

class PSL::Containers::Index_Pair is
  exports
    func Nth_Pair
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       N : Univ_Integer) -> optional Index_Pair is
      // Return Nth Pair given bounds for each of 2 index types
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2).
      // Return null if N out of range.
        const Len2 := Length (Bounds2)
        if N <= 0 or else N > Length(Bounds1) * Len2 then
            return null
        else
            const I1 := (N-1) / Len2
            const I2 := (N-1) rem Len2
            return (Index1 => Bounds1.First + I1,
                    Index2 => Bounds2.First + I2)
        end if
    end func Nth_Pair

    func Pair_Position
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       Pair : Index_Pair) -> optional Univ_Integer is
      // Return position of Pair within bounds (starting at 1)
      // presuming Pair.Index1 in Bounds1 and Pair.Index2 in Bounds2
      // and second index varies fastest.
      // Return null if Pair out of range.
        if Pair.Index1 not in Bounds1 or else Pair.Index2 not in Bounds2 then
            return null
        else
            return (Pair.Index1-Bounds1.First) * Length(Bounds2) + 
              (Pair.Index2-Bounds2.First) + 1
        end if
    end func Pair_Position

end class PSL::Containers::Index_Pair

interface PSL::Containers::Index_Pair_Set<Pair is Index_Pair<>> is
  // Set of index pairs
    func Create(Bounds1 : Countable_Range<Pair::Index1_Type>;
                Bounds2 : Countable_Range<Pair::Index2_Type>)
      -> Index_Pair_Set

    op "[]"() -> Index_Pair_Set

    func Count(Index_Pair_Set) -> Univ_Integer

    func Is_Empty(Index_Pair_Set) -> Boolean

    func First(Index_Pair_Set)
      -> optional Pair
    func Last(Index_Pair_Set)
      -> optional Pair
    
    func Remove_First(var Index_Pair_Set)
      -> optional Pair
    func Remove_Last(var Index_Pair_Set)
      -> optional Pair
    func Remove_Any(var Index_Pair_Set)
      -> optional Pair
end interface PSL::Containers::Index_Pair_Set

class PSL::Containers::Index_Pair_Set is
  // Set of index pairs
    const Bounds1 : Countable_Range<Pair::Index1_Type>
    const Bounds2 : Countable_Range<Pair::Index2_Type>
    var First : Univ_Integer
    var Last : Univ_Integer

    func Nth_Pair(Index_Pair_Set; N : Univ_Integer) -> Pair is
      // Return Nth Pair of original Index_Pair_Set
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2).
      // Return null if N out of range.
        return Nth_Pair(Index_Pair_Set.Bounds1, Index_Pair_Set.Bounds2, N)
    end func Nth_Pair

  exports
    func Create(Bounds1 : Countable_Range<Pair::Index1_Type>;
                Bounds2 : Countable_Range<Pair::Index2_Type>)
      -> Index_Pair_Set is
        return (Bounds1 => Bounds1, Bounds2 => Bounds2,
                First => 1, Last => Length(Bounds1) * Length(Bounds2))
    end func Create

    op "[]"() -> Index_Pair_Set is
        return
          (Bounds1 =>
             Pair::Index1_Type::First()+1 .. Pair::Index1_Type::First(),
           Bounds2 =>
             Pair::Index2_Type::First()+1 .. Pair::Index2_Type::First(),
           First => 1,
           Last => 0)
    end op "[]"

    func Count(Index_Pair_Set) -> Univ_Integer is
        return Index_Pair_Set.Last - Index_Pair_Set.First + 1
    end func Count

    func Is_Empty(Index_Pair_Set) -> Boolean is
        return Index_Pair_Set.First > Index_Pair_Set.Last
    end func Is_Empty

    func First(Index_Pair_Set)
      -> optional Pair is
        return Nth_Pair(Index_Pair_Set, Index_Pair_Set.First)
    end func First

    func Last(Index_Pair_Set)
      -> optional Pair is
        return Nth_Pair(Index_Pair_Set, Index_Pair_Set.Last)
    end func Last

    func Remove_First(var Index_Pair_Set)
      -> Result : optional Pair is
        if Is_Empty(Index_Pair_Set) then
            Result := null
        else
            Result := Nth_Pair(Index_Pair_Set, Index_Pair_Set.First)
            Index_Pair_Set.First += 1
        end if
    end func Remove_First

    func Remove_Last(var Index_Pair_Set)
      -> Result : optional Pair is
        if Is_Empty(Index_Pair_Set) then
            Result := null
        else
            Result := Nth_Pair(Index_Pair_Set, Index_Pair_Set.Last)
            Index_Pair_Set.Last -= 1
        end if
    end func Remove_Last

    func Remove_Any(var Index_Pair_Set)
      -> optional Pair is
        if Count(Index_Pair_Set) mod 2 == 1 then
            return Remove_First(Index_Pair_Set)
        else
            return Remove_Last(Index_Pair_Set)
        end if
    end func Remove_Any

end class PSL::Containers::Index_Pair_Set
interface PSL::Containers::Array2D
  <Elem_Type is Assignable<>; Index1 is Countable<>; Index2 is Countable<>> is
  // A 2-D array abstraction where the index types are not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    const Bounds1 : Countable_Range<Index1>
    const Bounds2 : Countable_Range<Index2>

    func Create(Bounds1 : Countable_Range<Index1>;
      Bounds2 : Countable_Range<Index2>;
      Initial_Value : optional Elem_Type)
      -> Array2D

    type Indices is Index_Pair<Index1, Index2>
    type Set_Of_Indices is Index_Pair_Set<Indices>

    func Length1(Arr : Array2D) -> Univ_Integer
    func Length2(Arr : Array2D) -> Univ_Integer

    func Bounds1(Arr : Array2D) -> Countable_Range<Index1>
    func Bounds2(Arr : Array2D) -> Countable_Range<Index2>

    // Indexing operations using an index pair
    op "indexing"(ref Arr : Array2D; Indices) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array2D; Indices)
      -> ref var Elem_Type

    // Indexing operations using two individual indices
    op "indexing"(ref Arr : Array2D; Index1; Index2) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array2D; Index1; Index2)
      -> ref var Elem_Type

    // Set of index pairs that cover the 2D array.
    op "index_set"(Arr : Array2D) -> Set_Of_Indices

    op "[]"() -> Array2D
end interface PSL::Containers::Array2D

class PSL::Containers::Array2D is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is Basic_Array<optional Elem_Type>
    var Data : Elem_Array
  exports

    func Create(Bounds1 : Countable_Range<Index1>;
      Bounds2 : Countable_Range<Index2>;
      Initial_Value : optional Elem_Type)
      -> Array2D is
        return
          (Data => Create(Length(Bounds1) * Length(Bounds2), Initial_Value),
           Bounds1 => Bounds1, Bounds2 => Bounds2)
    end func Create

    func Length1(Arr : Array2D) -> Univ_Integer is
        return Length(Arr.Bounds1)
    end func Length1

    func Length2(Arr : Array2D) -> Univ_Integer is
        return Length(Arr.Bounds2)
    end func Length2

    func Bounds1(Arr : Array2D) -> Countable_Range<Index1> is (Arr.Bounds1)
    func Bounds2(Arr : Array2D) -> Countable_Range<Index2> is (Arr.Bounds2)

    // Indexing operations using an index pair
    op "indexing"(ref Arr : Array2D; Indices) -> ref Elem_Type is
        {> Indices.Index1 in Arr.Bounds1; Indices.Index2 in Arr.Bounds2 <}
        return Arr.Data[Pair_Position(Arr.Bounds1, Arr.Bounds2, Indices)]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array2D; Indices)
      -> ref var Elem_Type is
        return "var_indexing"(Arr, Indices.Index1, Indices.Index2)
    end op "var_indexing"

    // Indexing operations using two individual indices
    op "indexing"(ref Arr : Array2D; Index1; Index2) -> ref Elem_Type is
        {> Index1 in Arr.Bounds1; Index2 in Arr.Bounds2 <}
        return Arr.Data
          [Indices::Pair_Position(Arr.Bounds1, Arr.Bounds2, (Index1, Index2))]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array2D; Index1; Index2)
      -> ref var Elem_Type is
        if Index1 not in Arr.Bounds1 or else Index2 not in Arr.Bounds2 then
            // Extend array to include Index1 and Index2
            var Old_Arr <== Arr
            Arr := Create
              (Bounds1 => Min(Old_Arr.Bounds1.First, Index1) ..
                 Max(Old_Arr.Bounds1.Last, Index1),
               Bounds2 => Min(Old_Arr.Bounds2.First, Index2) ..
                 Max(Old_Arr.Bounds2.Last, Index2),
               Initial_Value => null)

            // Move over old data
            for I in Old_Arr.Bounds1 loop
                for J in Old_Arr.Bounds2 loop
                    // Explicitly use "indexing" to avoid infinite recursion
                    "indexing"(Arr, I, J) <== Old_Arr[I, J]
                end loop
            end loop

            // Reclaim old data space
            Old_Arr := null
        end if

        //  Now return ref to appropriate element
        return "indexing"(Arr, Index1, Index2)
    end op "var_indexing"

    // Set of index pairs that cover the 2D array.
    op "index_set"(Arr : Array2D) -> Set_Of_Indices is
        return Create(Arr.Bounds1, Arr.Bounds2)
    end op "index_set"

    op "[]"() -> Array2D is
        return (Data => Create(0, null),
          Bounds1 => Index1::First()+1 .. Index1::First(),
          Bounds2 => Index2::First()+1 .. Index2::First())
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Array2D

func PSL::Test::Test_Array2D() is
    type Shade is Enum< [#white, #black] >
    type Chess_Board is Array2D<Shade,
      Index1 => Integer<1..8>, Index2 => Integer<1..8>>

    const Board_Indices : Chess_Board::Set_Of_Indices := Create(1..8, 1..8)
    var CB : Chess_Board := [for Ix in Board_Indices =>
      (if (Ix.Index1 - Ix.Index2) mod 2 == 0 then #white else #black)]

    for each [Ix => C] of CB forward loop
        Println("CB[" | Ix.Index1 | ", " | Ix.Index2 | "] = " | C)

        {> CB[Ix.Index1, Ix.Index2] == C <}
    end loop
end func PSL::Test::Test_Array2D
interface PSL::Core::Time<> is
  // Time in nanoseconds since Jan 1, 1970

    type Time_Interval is new
      Fixed<Delta => 1.0E-9>

    const Second : Time_Interval := 1.0
    const Millisecond : Time_Interval := 1.0/1000
    const Microsecond : Time_Interval := 1.0/10**6
    const Nanosecond : Time_Interval := 1.0/10**9

    const Minute : Time_Interval := 60.0
    const Hour : Time_Interval := 60 * Minute
    const Day : Time_Interval := 24 * Hour

    type Month_Enum is Enum< 
       [#Jan, #Feb, #Mar, #Apr, #May, #Jun,
        #Jul, #Aug, #Sep, #Oct, #Nov, #Dec] >

    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time

    func Zero() -> Time

    op "+"(Left : Time; Right : Time_Interval) -> Time
      is import("+")
    op "+"(Left : Time_Interval; Right : Time) -> Time
      is import("+")
    op "-"(Left : Time; Right : Time_Interval) -> Time
      is import("-")
    op "-"(Left, Right : Time) -> Time_Interval
      is import("-")

    op "=?"(Left, Right : Time) -> Ordering
      is import("=?")

    func Min(Left, Right : optional Time) -> optional Time
      is import(#min)
    func Max(Left, Right : optional Time) -> optional Time
      is import(#max)

    func Seconds_Since_1970(Time) -> Time_Interval
      is import(#identity)

end interface PSL::Core::Time

class PSL::Core::Time is
    const Since_1970 : Time_Interval

    type Year_Kind is Enum< [#normal, #leap] >

    const Month_Base : Array<Array<Univ_Integer, Indexed_By => Year_Kind>,
      Indexed_By => Month_Enum> := 
        [#Jan => [0, 0], #Feb => [31, 31], #Mar => [59, 60], #Apr => [90, 91],
         #May => [120, 121], #Jun => [151, 152], #Jul => [181, 182],
         #Aug => [212, 213], #Sep => [243, 244], #Oct => [273, 274],
         #Nov => [304, 305], #Dec => [334, 335]]

    func Kind_Of_Year(Year : Univ_Integer) -> Year_Kind is
        if Year mod 4 == 0 and then
          (Year mod 100 != 0 or else Year mod 400 == 0) then
            // Every 100 years leap year is omitted, 
            // except for multiples of 400 which *are* leap years.
            return #leap
        else
            return #normal
        end if
    end func Kind_Of_Year

    func Leaps_Before(Year : Univ_Integer) -> Univ_Integer is
        // Number of leap years before this year, starting from 1970
        if Year < 2101 then
            return (Year-1969)/4
        else
            // Every 100 years leap year is omitted, 
            // except for multiples of 400 which *are* leap years.
            return (Year-1969)/4 - (Year-2001)/100
        end if
    end func Leaps_Before

  exports
    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time is
        // Determine number of nanos since Jan 1, 1970
        const Kind := Kind_Of_Year(1970)
        const Base := Month_Base[Month][Kind]

        return (Since_1970 => 
          (Year-1970) * (365*Day) + 
          (Leaps_Before(Year) + Base + Day_Of_Month)*Day +
          Time_Of_Day - Time_Zone)
    end func Create

    func Zero() -> Time is
        return (Since_1970 => 0.0)
    end func Zero

end class PSL::Core::Time

func PSL::Test::Test_Time(X : Univ_Real) is
    var XTI : Time::Time_Interval := X
    const Local_Minute : Time::Time_Interval := 60.0
    Println("X = " | XTI)
    Println("X * 2 = " | XTI*2)
    Println("X + X = " | (XTI + XTI))
    Println("X - X = " | (XTI - XTI))
    Println("X / 2 = " | (XTI / 2))
    Println("X / 2.0 = " | (XTI / 2.0))
    Println("X * 3.0 = " | (XTI * 3.0))
    Println("5.0 * X = " | (5.0 * XTI))
    Println("-5.0 * X = " | (-5.0 * XTI))
    Println("-5.0 = " | -5.0)
    Println("Local_Minute = " | Local_Minute)
    Println("-5.0*Local_Minute = " | (-5.0*Local_Minute))
    Println("Time::Minute = " | Time::Minute)
    Println("-5.0*Time::Minute = " | (-5.0*Time::Minute))
    Println("Time::Hour = " | Time::Hour )
    Println("-5.0*Time::Hour = " | (-5.0*Time::Hour))

    var T : Time := Create(Year => 2011, Month => #Oct, Day_Of_Month => 18,
      Time_Of_Day => 10*Time::Hour + 5*Time::Minute,
      Time_Zone => -5.0*Time::Hour)

    Println("18-Oct-2011 = " | ( T - Zero() ))
    Println("X = " | XTI )
    Println("18-Oct-2011 - X = " | ( (T - XTI) - Zero() ) )

end func PSL::Test::Test_Time
concurrent interface PSL::Core::Clock<> is
    // A module that provides access to a wall clock and
    // to other timers, and an ability to delay the caller
    // for a given amount of time, or until a specified time
    // in the future.
    
    func Create() -> Clock
        // Create a clock, which corresponds to the current wall clock time

    func Create(Now : Time) -> Clock
        // Create a clock, where Now() returns the given time when created

    func Now(locked C : Clock) -> Time
        // Return current reading of clock

    func Now() -> Time
        // Return current reading of wall clock

    queued func Delay(C : Clock; Until : Time)
        // Wait until the given clock reads >= Until

    queued func Delay(Until : Time)
        // Wait until the wall clock reads >= Until

    queued func Delay(C : Clock; For : Time::Time_Interval)
        // Wait until the given clock reads "Now(C) + For"

    queued func Delay(For : Time::Time_Interval)
        // Wait until the wall clock reads "Now() + For"

    func Set(locked var C : Clock; To : Time)
        // Update clock so it reads the given time
end interface PSL::Core::Clock

concurrent class PSL::Core::Clock is

    var Timer_Delta : Time::Time_Interval
        // Amount to be subtracted from Current Time
        // to produce value of timer

    func Current_Time(locked C : Clock) -> Time 
      is import(#clock_current_time)
        // NOTE: Clock parameter is ignored; returns wall clock

    func Wait_For_Delay(queued C : Clock; Until : Time) is 
      import(#clock_delay)
        // Wait until the wall clock reads >= Until
        // NOTE: Clock parameter is ignored

  exports
    func Create() -> Clock is
        // Create a clock, which corresponds to the current wall clock time
        // Println("Create Clock with Delta 0.0")
        return (Timer_Delta => 0.0)
    end func Create

    func Create(Now : Time) -> Result : Clock is
        // Create a clock, where Now() returns the given time when created
        const Delta := Current_Time(Create()) - Now
        // Println("Create Clock with Delta = " | Delta)
        return (Timer_Delta => Current_Time(Create()) - Now)
    end func Create

    func Now(locked C : Clock) -> Result : Time is
        // Return current reading of clock
        Result := Current_Time(C) - C.Timer_Delta
        // Println("Now returning " | Result-Zero())
    end func Now

    func Now() -> Result : Time is
        // Return current reading of wall clock
        var C : Clock := Create()
        Result := Current_Time(C)
        // Println("Now returning " | Result-Zero())
    end func Now

    queued func Delay(C : Clock; Until : Time) is
        // Wait until the given clock reads >= Until
        Wait_For_Delay(C, Until + C.Timer_Delta)
    end func Delay

    queued func Delay(Until : Time) is
        // Wait until the wall clock reads >= Until
        var C : Clock := Create()
        Wait_For_Delay(C, Until)
    end func Delay

    queued func Delay(C : Clock; For : Time::Time_Interval) is
        // Wait until the given clock reads "Now(C) + For"
        // NOTE: Timer_Delta is irrelevant for this one
        // Println("Wait for delay of " | For)
        const Time_Now := Current_Time(C)
        const Until := Time_Now + For
        // Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now)
        Wait_For_Delay(C, Until)
    end func Delay

    queued func Delay(For : Time::Time_Interval) is
        // Wait until the wall clock reads "Now() + For"
        // NOTE: Timer_Delta is irrelevant for this one
        // Println("Wait for delay of " | For)
        var C : Clock := Create()
        const Time_Now := Current_Time(C)
        const Until := Time_Now + For
        // Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now)
        Wait_For_Delay(C, Until)
    end func Delay

    func Set(locked var C : Clock; To : Time) is
        // Update clock so it reads the given time
        C.Timer_Delta := Current_Time(C) - To
    end func Set

end class PSL::Core::Clock

func PSL::Test::Test_Clock() is
    var C := Clock::Create()
    const Start := C.Now()
    var Ran := Random::Start (Round_To_Int (Seconds_Since_1970 (Clock::Now())))
    Println("First random number = " | Next(Ran));
    Println("Second random number = " | Next(Ran));
    Println("Third random number = " | Next(Ran));

  then
    Println("About to delay 4.0 seconds")
    C.Delay(4.0)
    Println("Done with delay of 4.0")
  ||
    Println("About to delay 2.0 seconds")
    C.Delay(2.0)
    Println("Done with delay of 2.0")
||    // check that indent of 0 works
    for I in 1..7 loop
        Println("In loop delaying for 1.0")
        C.Delay(1.0)
        Println("Done with delay " | I | " of 1.0")
    end loop
then  // check that indent of 0 works
    Println("Elapsed time: " | (C.Now() - Start))
end func PSL::Test::Test_Clock
concurrent interface PSL::Core::Atomic<Content_Type is Comparable<>> is
    func Create(Initial_Val : Content_Type) -> Atomic
      // Create an atomic object with given initial value

    func Set_Value(locked var A : Atomic; Val : Content_Type)
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually

    func Value(locked A : Atomic) -> Content_Type
      // Return the current value
      // TBD: Use atomic hardware instructions eventually

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Content_Type
      // Set Value(A) to New_Val; Return the prior value.

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) -> Content_Type
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
end interface PSL::Core::Atomic

concurrent class PSL::Core::Atomic is
    var Value : Content_Type
  exports
    func Create(Initial_Val : Content_Type) -> Atomic is
      // Create an atomic object with given initial value
        return (Value => Initial_Val)
    end func Create

    func Set_Value(locked var A : Atomic; Val : Content_Type) is
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually
        A.Value := Val
    end func Set_Value

    func Value(locked A : Atomic) -> Content_Type is
      // Return the current value
      // TBD: Use atomic hardware instructions eventually
        return A.Value
    end func Value

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Result : Content_Type is
      // Set Value(A) to New_Val; Return the prior value.
        Result := A.Value
        A.Value := New_Val
    end func Test_And_Set

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) -> Result : Content_Type is
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
        Result := A.Value
        if Result == Expected_Val then
            A.Value := New_Val
        end if
    end func Compare_And_Swap
end class PSL::Core::Atomic

func PSL::Test::Test_Atomic(X, Y : Univ_Integer) is
    type Atomic_Univ is Atomic<Univ_Integer>
    var AX := Atomic_Univ::Create(X)

    Println("Value(X) = " | Value(AX))

    Set_Value(AX, X+1)
    Println("After Set_Value(" | X+1 | "), Value(X) = " | Value(AX))

    const Z := Test_And_Set(AX, Y)
    Println("Test_And_Set(X, " | Y | ") = " | Z)

    const CAS := Compare_And_Swap(AX, Expected_Val => X-1, New_Val => Y-1)
    Println("Compare_And_Swap(X, " | X-1 | ", " | Y-1 | 
      ") = " | CAS | ", Value(X) = " | Value(AX))

    const CAS2 := Compare_And_Swap(AX, Y, Y-2)
    Println("Compare_And_Swap(X, " | Y | ", " | Y-2 | 
      ") = " | CAS2 | ", Value(X) = " | Value(AX))

end func PSL::Test::Test_Atomic
interface PSL::Core::Modular<Modulus : Univ_Integer> is
  // This is an unsigned type whose arithmetic is "modulo" the modulus
    op "from_univ"(Lit : Univ_Integer) -> Modular 
      is import(#integer_from_univ)

    op "to_univ"(Val : Modular) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Modular) -> Modular
      is import(#identity)

    op "-"(Right : Modular) -> Modular

    op "abs"(Right : Modular) -> Modular
      is import(#identity)

    op "magnitude"(Modular) -> Modular is "abs"

    op "+"(Left, Right : Modular) -> Result : Modular

    op "-"(Left, Right : Modular) -> Result : Modular

    op "*"(Left, Right : Modular) -> Result : Modular

    op "/"(Left, Right : Modular) -> Result : Modular
      is import("/")

    op "mod"(Left, Right : Modular) -> Modular
      is import("mod")

    op "rem"(Left, Right : Modular) -> Modular
      is import("rem")

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "+="(var Left : Modular; Right : Modular)

    op "-="(var Left : Modular; Right : Modular)

    op "*="(var Left : Modular; Right : Modular)

    op "/="(var Left : Modular; Right : Modular) 
      is import("/=")

    op "**="(var Left : Modular; Right : Univ_Integer)

    op "=?"(Left, Right : Modular) -> Ordering
      is import("=?")

    op ">>"(Modular; Modular) -> Modular is import(">>")

    op "<<"(Modular; Modular) -> Modular is import("<<")

    op "and"(Left, Right : Modular) -> Modular is import(#bit_and)
    op "or"(Left, Right : Modular) -> Modular
    op "xor"(Left, Right : Modular) -> Modular
    op "not"(M : Modular) -> Modular

    func Min(Left, Right : optional Modular) -> optional Modular
      is import(#min)
    func Max(Left, Right : optional Modular) -> optional Modular
      is import(#max)

    func Hash(Val : Modular) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Modular) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Modular

    func Print(X : Modular) is import(#print_int)
    func Println(X : Modular) is (Println(To_String(X)))

    func First() -> Modular

    func Last() -> Modular

    op "[..]"()->Countable_Range<Modular> is in Countable_Range<Modular>

    op ".."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "<.."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "<..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "|"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
  implements for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding a Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "-"(Left, Right : Modular) -> Result : Univ_Integer

end interface PSL::Core::Modular

class PSL::Core::Modular is
    const Content : Univ_Integer;  // So this ends up as a wrapper

    func Bit_Or(Left, Right : Univ_Integer) -> Univ_Integer 
      is import(#bit_or)

    func Bit_Xor(Left, Right : Univ_Integer) -> Univ_Integer 
      is import(#bit_xor)
  exports
    op "-"(Right : Modular) -> Modular is
        return (Content => Modulus - Right.Content)
    end op "-"

    op "+"(Left, Right : Modular) -> Result : Modular is
        return (Content => (Left.Content + Right.Content) mod Modulus)
    end op "+"

    op "-"(Left, Right : Modular) -> Result : Modular is
        return (Content => (Left.Content - Right.Content) mod Modulus)
    end op "-"

    op "*"(Left, Right : Modular) -> Result : Modular is
        return (Content => (Left.Content * Right.Content) mod Modulus)
    end op "*"

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
        return (Content => (Left.Content ** Right) mod Modulus)
    end op "**"

    op "+="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content + Right.Content) mod Modulus)
    end op "+="

    op "-="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content - Right.Content) mod Modulus)
    end op "-="

    op "*="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content * Right.Content) mod Modulus)
    end op "*="

    op "**="(var Left : Modular; Right : Univ_Integer) is
        Left := (Content => (Left.Content ** Right) mod Modulus)
    end op "**="

    func From_String(Str : Univ_String) -> optional Modular is
        const Val : Univ_Integer := From_String(Str)
        if Val is null or else Val in 0..<Modulus then
            return (Content => Val)
        else
            return null
        end if
    end func From_String

    op "or"(Left, Right : Modular) -> Modular is
        return (Content => Bit_Or(Left.Content, Right.Content) mod Modulus)
    end op "or"

    op "xor"(Left, Right : Modular) -> Modular is
        return (Content => Bit_Xor(Left.Content, Right.Content) mod Modulus)
    end op "xor"

    op "not"(M : Modular) -> Modular is
        return (Content => Modulus - 1 - M.Content)
    end op "not"

    func First() -> Modular is
        return (Content => 0)
    end func First

    func Last() -> Modular is
        return (Content => Modulus-1)
    end func Last

  // implements
  // for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
        return (Content => (Left.Content + Right) mod Modulus)
    end op "+"

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular is
        return (Content => (Left + Right.Content) mod Modulus)
    end op "+"

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
        return (Content => (Left.Content - Right) mod Modulus)
    end op "-"

    op "-"(Left, Right : Modular) -> Result : Univ_Integer is
        return (Left.Content - Right.Content) mod Modulus
    end op "-"
end class PSL::Core::Modular
    
func PSL::Test::Test_Modular() is
    type Mod16 is Modular<16>

    Println("Testing mod 16")
    Println("0xA + 0xA = " | Mod16::0xA + Mod16::0xA)
    Println("0xA or 0x1 = " | (Mod16::0xA or Mod16::0x1))
    Println("0xA xor 0x2 = " | (Mod16::0xA xor Mod16::0x2))
    Println("not 0xA = " | (not Mod16::0xA))
end func PSL::Test::Test_Modular
interface PSL::Containers::Ordered_Set<Element_Type is Comparable<>> is
  // A set over individual but ordered elements
    op "[]"() -> Ordered_Set

    func Singleton(Elem : Element_Type) -> Ordered_Set

    op "|"(Left, Right : Element_Type) -> Ordered_Set
    op "|"(Left : Ordered_Set; Right : Element_Type) 
      -> Ordered_Set
    op "|"(Left : Element_Type; Right : Ordered_Set) 
      -> Ordered_Set
    op "|"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set

    op "|="(var Left : Ordered_Set; Right : Element_Type)
    op "|="(var Left : Ordered_Set; Right : Ordered_Set)

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Ordered_Set) -> Ordered_Set
      // Set difference
    op "-"(Left : Ordered_Set; Right : Element_Type) 
      -> Ordered_Set
      // Remove one element
    op "-="(var S : Ordered_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Ordered_Set; Right : Ordered_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|"   // union
    op "or="(var Left : Ordered_Set; Right : Ordered_Set)
      is "|="

    op "+"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|"   // Union
    op "+="(var Left : Ordered_Set; Right : Ordered_Set)
      is "|="
    op "+="(var Left : Ordered_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Ordered_Set) -> Ordered_Set
        // Intersection
    op "and="(var Left : Ordered_Set; Right : Ordered_Set)

    op "xor"(Left, Right : Ordered_Set) -> Ordered_Set
        // Symmetric difference
    op "xor="(var Left : Ordered_Set; Right : Ordered_Set)

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean

    op "=?"(Left, Right : Ordered_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    func Count(S : Ordered_Set) -> Univ_Integer

    op "magnitude"(Ordered_Set) -> Univ_Integer is Count

    func Is_Empty(S : Ordered_Set) -> Boolean

    func First(S : Ordered_Set) -> optional Element_Type
    func Last(S : Ordered_Set) -> optional Element_Type
    func Any_Element(S : Ordered_Set) -> optional Element_Type

    func Remove_First(var S : Ordered_Set) -> optional Element_Type
        // Remove first element of set (lowest value)

    func Remove_Last(var S : Ordered_Set) -> optional Element_Type
        // Remove last element of set (highest value)

    func Remove_Any(var S : Ordered_Set) -> optional Element_Type
        // Remove an arbitrary element of set

end interface PSL::Containers::Ordered_Set

class PSL::Containers::Ordered_Set is

    var Items : optional AA_Tree<Element_Type>
    var Count := 0

  exports
    op "[]"() -> Ordered_Set is
        return (Items => [], Count => 0)
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Ordered_Set is
        Result := []
        Result.Items |= Elem
        Result.Count := 1
    end func Singleton

    op "|"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
        Result.Items |= Left;
        Result.Items |= Right;
        Result.Count := Count(Result.Items)
    end op "|"

    op "|"(Left : Ordered_Set; Right : Element_Type) 
      -> Result : Ordered_Set is
        Result := Left
        Result.Items |= Right
        Result.Count := Count(Result.Items)
    end op "|"

    op "|"(Left : Element_Type; Right : Ordered_Set) 
      -> Ordered_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Result : Ordered_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Ordered_Set; Right : Element_Type) is
        Left.Items |= Right;
        Left.Count := Count(Left.Items)
    end op "|="

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type)
      is
        // Move element into set, leaving Right null afterward.
        Left.Items <|= Right
        Left.Count := Count(Left.Items)
    end op "<|="

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set)
      is
        // Move all elements of Right into Left, leaving Right empty.
        if Left.Count == 0 then
            Left.Items <== Right.Items
            Left.Count := Right.Count
            Right.Count := 0
        else
            // Iterate through the tree
            loop
                // Extract element from right
                var Elem for Left := Remove_Any(Right)

                if Elem is null then
                    Left.Count := Count(Left.Items)
                    return   // All done
                end if

                Left.Items <|= Elem

            end loop
        end if
    end op "<|="

    op "|="(var Left : Ordered_Set; Right : Ordered_Set) is
        // Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end op "|="

    op "-"(Left, Right : Ordered_Set) 
      -> Result : Ordered_Set is
      // Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-"(Left : Ordered_Set; Right : Element_Type)
      -> Result : Ordered_Set is
      // Remove one element
        Result := Left
        Result -= Right
    end op "-"
        
    op "-="(var S : Ordered_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
        Delete(S.Items, Elem);
        S.Count := Count(S.Items)
    end op "-="

    op "-="(var Left : Ordered_Set; Right : Ordered_Set) is
      // Remove all elements of Right from Left, if present
        for Elem in Right loop
            Left -= Elem
        end loop
    end op "-="

    op "and"(Left, Right : Ordered_Set)
      -> Result : Ordered_Set is
        // Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end op "and"

    op "and="(var Left : Ordered_Set; Right : Ordered_Set) is
        // Intersection
        for Elem in Left loop
            if Elem not in Right then
                Left -= Elem
            end if
        end loop
    end op "and="

    op "xor"(Left, Right : Ordered_Set) 
      -> Result : Ordered_Set is
        // Symmetric difference
        Result := Left
        Result xor= Right
    end op "xor"

    op "xor="(var Left : Ordered_Set; Right : Ordered_Set) is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end op "xor="

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean is
        return Overlapping(Right.Items, Left) not null
    end op "in"

    op "=?"(Left, Right : Ordered_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    func Count(S : Ordered_Set) -> Result : Univ_Integer is
        // Return count of items in set
        return S.Count;
    end func Count

    func Is_Empty(S : Ordered_Set) -> Boolean is
        return S.Count == 0;
    end func Is_Empty

    func First(S : Ordered_Set) -> optional Element_Type is
        return First(S.Items);
    end func First

    func Last(S : Ordered_Set) -> optional Element_Type is
        return Last(S.Items);
    end func Last

    func Any_Element(S : Ordered_Set) -> optional Element_Type is
        return Any_Element(S.Items);
    end func Any_Element

    func Remove_First(var S : Ordered_Set) 
      -> Result : optional Element_Type is
        // Return first element of set
        Result := Remove_First(S.Items)
        if Result not null then
           S.Count -= 1
        end if
    end func Remove_First

    func Remove_Last(var S : Ordered_Set) 
      -> Result : optional Element_Type is
        // Remove last element of set
        Result := Remove_Last(S.Items);
        if Result not null then
           S.Count -= 1
        end if
    end func Remove_Last

    func Remove_Any(var S : Ordered_Set) -> Result : optional Element_Type is
        // Remove any element of set
        Result := Remove_Any(S.Items);
        if Result not null then
           S.Count -= 1
        end if
    end func Remove_Any

end class PSL::Containers::Ordered_Set
interface PSL::Core::Enum_With_Rep
  <Rep_Type is Imageable<>;
   Rep_Map : Two_Way_Map<Univ_Enumeration, Rep_Type>> is
  // An enumeration type specified using a map from literal to value
  // of an underlying representation type.
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some [Lit => Val] of Rep_Map => Lit == Univ)}
      -> Enum_With_Rep
    op "to_univ"(Val : optional Enum_With_Rep)
      -> Result : optional Univ_Enumeration
      {Result is null or else
        (for some [Lit => Val] of Literals => Lit == Result)}

    // Functions to convert from/to rep
    func From_Rep (Rep : optional Rep_Type) -> optional Enum_With_Rep
    func To_Rep (Val : optional Enum_With_Rep) -> optional Rep_Type

    op "[..]"() -> Ordered_Set<Enum_With_Rep>

    op "=?"(Left, Right : Enum_With_Rep) -> Ordering

    // Functions for Imageable
    func To_String(Val : Enum_With_Rep) -> Univ_String
    func From_String(Str : Univ_String) -> optional Enum_With_Rep

    func Hash(Val : Enum_With_Rep) -> Univ_Integer

    func Min(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    func Max(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep

    func Dump_Rev_Map()
end interface PSL::Core::Enum_With_Rep

class PSL::Core::Enum_With_Rep is
    const Rep : Rep_Type
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      -> Enum_With_Rep is
        return (Rep => Rep_Map[Univ]);
    end op "from_univ"

    op "to_univ"(Val : optional Enum_With_Rep) 
      -> Result : optional Univ_Enumeration is
        if Val is null then
            return null
        else
            return Key_Of (Rep_Map, Val.Rep)
        end if
    end op "to_univ"

    func From_Rep (Rep : optional Rep_Type) -> optional Enum_With_Rep is
        if Rep is null then
            return null
        else
            return (Rep => Rep)
        end if
    end func From_Rep

    func To_Rep (Val : optional Enum_With_Rep) -> optional Rep_Type is
        if Val is null then
            return null
        else
            return Val.Rep
        end if
    end func To_Rep

    // Functions for Imageable
    func To_String(Val : Enum_With_Rep) -> Univ_String is
        const Enum : optional Univ_Enumeration := [[Val]];
        if Enum not null then
            // use enum image
            return Univ_Enumeration::To_String(Enum);
        else
            // use rep-type To_String
            return Rep_Type::To_String(Val.Rep)
        end if
    end func To_String

    func From_String(Str : Univ_String) -> optional Enum_With_Rep is
        if Str[1] == '#' then
            // Presume is an enum
            return Univ_Enumeration::From_String(Str)
        else
            // Use rep-type From_String
            return (Rep => Rep_Type::From_String(Str))
        end if
    end func From_String

    op "[..]"() -> Ordered_Set<Enum_With_Rep> is
        return [for each Rep of Rep_Map => From_Rep(Rep)]
    end op "[..]";

    op "=?"(Left, Right : Enum_With_Rep) -> Ordering is
        return Left.Rep =? Right.Rep
    end op "=?"

    func Hash(Val : Enum_With_Rep) -> Univ_Integer is
        return Hash (Val.Rep)
    end func Hash

    func Min(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep > Left.Rep then
            return Left
        else
            return Right
        end if
    end func Min

    func Max(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep < Left.Rep then
            return Left
        else
            return Right
        end if
    end func Max

    func Dump_Rev_Map() is
        const Rev := Rev_Map (Rep_Map)

        for KV in Rev loop
            Println ("[" | KV.Key | " => " | KV.Value | "]")
        end loop
    end func Dump_Rev_Map

end class PSL::Core::Enum_With_Rep

func PSL::Test::Test_Enum_With_Rep() is
    type Color is Enum_With_Rep<Univ_Integer,
               [#red => 1, #green => 3, #blue => 5]>;

    type Day_Of_Week is 
       Enum_With_Rep<Modular<2**7>,
          [#Monday => 1<<0, #Tuesday => 1<<1, #Wednesday => 1<<2,
           #Thursday => 1<<3, #Friday => 1<<4,
            #Saturday => 1<<5, #Sunday => 1<<6]>

    Println ("Dump_Rev_Map():")
    Day_Of_Week::Dump_Rev_Map()

    for C in Color forward loop
        Println("Next color = " | C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " | C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " | D3)
    end loop

    {#Monday in Day_Of_Week}

    for D4 in Day_Of_Week reverse loop
        Println("Prev day of week = " | D4)
    end loop

    for D5 in Day_Of_Week forward loop
        Println("To_Rep(" | D5 | ") = " | To_Rep(D5))
    end loop

    for I in 1..10 forward loop
        Println("Day_Of_Week::From_Rep(" | I | ") = " |
          Day_Of_Week::From_Rep(I))
    end loop

end func PSL::Test::Test_Enum_With_Rep
interface PSL::Core::Enum_Mask
  <Base_Type is Modular<>;
   Rep_Map : Two_Way_Map<Univ_Enumeration, Base_Type>>
  extends PSL::Core::Enum_With_Rep<Base_Type, Rep_Map> is
  // An enumeration type built on a modular type
  // that supports "|" as a way to combine bits into a single value.
    op "|"(Left, Right : Enum_Mask) -> Enum_Mask
       is (From_Rep(To_Rep(Left) or To_Rep(Right)))
end interface PSL::Core::Enum_Mask
concurrent interface PSL::Core::IO<>:
  // Locked versions of the Print, Println and Readln operations
    var Stdout : Standard_Output_Stream
    var Stderr : Standard_Output_Stream

    func Get_IO() -> IO  // Get handle on IO subsystem

    func Print(locked var IO; Univ_String)
    func Println(locked var IO; Univ_String)

    func Print(locked var IO; Val : Val_Type is Imageable<>)
    func Println(locked var IO; Val : Val_Type is Imageable<>)

    func Readln(locked var IO) -> optional Univ_String

    type Exit_Status_Value is new Integer<-9999 .. +9999>
    const Exit_Success : Exit_Status_Value := 0
    const Exit_Failure : Exit_Status_Value := 1 
    func Set_Exit_Status(locked var IO; Exit_Status_Value)
      is import(#set_exit_status)

end interface PSL::Core::IO

concurrent class PSL::Core::IO:
  exports
    func Get_IO() -> IO:
        return (Stdout => (Channel => #stdout),
                Stderr => (Channel => #stderr));

    func Print(locked var IO; Univ_String):
        Print (Univ_String)

    func Println(locked var IO; Univ_String):
        Println (Univ_String)

    func Print(locked var IO; Val : Val_Type is Imageable<>):
        Print (Val_Type::To_String(Val))

    func Println(locked var IO; Val : Val_Type is Imageable<>):
        Println (Val_Type::To_String(Val))

    func Readln(locked var IO) -> optional Univ_String:
        return Readln()

end class PSL::Core::IO
interface PSL::Containers::Imageable_Vector<Element_Type is Imageable<>>
  extends Vector<Element_Type>
  implements Imageable<> is
  //  A vector which can be easily printed.
  //  Requires element type to itself be Imageable.
    func To_String(Val : Imageable_Vector) -> Univ_String<>

    func From_String(Str : Univ_String<>) -> optional Imageable_Vector
      is (null)  // TBD

    op "=?"(Left, Right : Imageable_Vector) -> Ordering
    func Hash(Val : Imageable_Vector) -> Univ_Integer

    func Print(Val : Imageable_Vector) is (Print(To_String(Val)))
    func Println(Val : Imageable_Vector) is (Println(To_String(Val)))
end interface PSL::Containers::Imageable_Vector

class PSL::Containers::Imageable_Vector is
  exports
    func To_String(Val : Imageable_Vector) -> Result : Univ_String<> is
        Result := "";
        for (each V of Val; Sep := "[" then ", ") forward loop
            Result |= Sep | V;
        end loop
        return Result | "]"
    end func To_String

    op "=?"(Left, Right : Imageable_Vector) -> Ordering is
        for I in 1 .. Min(|Left|, |Right|) forward loop
            const Result := Left[I] =? Right[I]
            if Result != #equal then
                //  First mismatch determines result
                return Result
            end if
        end loop
        //  Prefixes match, result determined by length comparison
        return |Left| =? |Right|
    end op "=?"

    func Hash(Val : Imageable_Vector) -> Univ_Integer is
        if |Val| == 0 then
            return 0
        else
            //  Hash first and last
            return Hash(Val[1])*7 + Hash(Val[|Val|])
        end if
    end func Hash
end class PSL::Containers::Imageable_Vector
//  Tuple types

interface PSL::Containers::Pair<T1 is Assignable<>; T2 is Assignable<>> is
   const First  : T1;
   const Second : T2;
end interface PSL::Containers::Pair;

interface PSL::Containers::Triple<T1 is Assignable<>; T2 is Assignable<>;
                                  T3 is Assignable<>> is
   const First  : T1;
   const Second : T2;
   const Third  : T3;
end interface PSL::Containers::Triple;

interface PSL::Containers::Quad<T1 is Assignable<>; T2 is Assignable<>;
                                T3 is Assignable<>; T4 is Assignable<>> is
   const First  : T1;
   const Second : T2;
   const Third  : T3;
   const Fourth : T4;
end interface PSL::Containers::Quad;
func PSL::Test::Test_IO (X, Y : Univ_String; Z : Univ_Integer):
    var IO := IO::Get_IO()
    const Pi := 3.141592653589793
    const True := Boolean::#true

    IO.Print ("Pi = ")
    IO.Print (Pi)
    IO.Print (", True prints as ")
    IO.Print (True)
    IO.Print ('\n')
    IO.Print ("X = \"" | X | '"')
    IO.Print (", Y = \"" | Y | '"')
    IO.Println (", Z = " | Z )
    IO.Print ("Give me somethin: ")
    var Input := IO.Readln()
    IO.Println ("You gave me: \"" | Input | '"')

    IO.Stderr.Println ("This is going to standard error output");
    IO.Stdout.Println ("This is going to standard output");
    IO.Stdout.Println ("About to flush stderr and stdout");
    IO.Stderr.Flush ()
    IO.Stdout.Flush ()

    const Vec : Imageable_Vector<Univ_Integer> := [1, 3, 5, 7, 9]
    IO.Println ("About to print out imageable vector")
    IO.Print (Vec); IO.Print('\n')
end func PSL::Test::Test_IO
    
import PSL::Test::Test_IO

func Test_IO (X, Y : Univ_String; Z : Univ_Integer):
    PSL::Test::Test_IO (X, Y, Z)
end func Test_IO

interface PSL::Core::Output_Stream<> is
  // Output stream interface; all operations
  // expressed in terms of Univ_String print and close
    abstract func Print(var Output_Stream; Univ_String)
    abstract func Flush(var Output_Stream)
    abstract func Close(var optional Output_Stream)

    func Println(var Output_Stream+; Univ_String)

    func Print(var Output_Stream+; Val : Val_Type is Imageable<>)

    func Println(var Output_Stream+; Val : Val_Type is Imageable<>)

end interface PSL::Core::Output_Stream

class PSL::Core::Output_Stream is
  // Output stream interface; all operations
  // expressed in terms of Univ_String print
  exports
    func Println(var Output_Stream+; Univ_String):
        Output_Stream.Print(Univ_String)
        Output_Stream.Print("\n")

    func Print(var Output_Stream+; Val : Val_Type is Imageable<>):
        Output_Stream.Print (Val_Type::To_String(Val))

    func Println(var Output_Stream+; Val : Val_Type is Imageable<>):
        Output_Stream.Print (Val_Type::To_String(Val))
        Output_Stream.Print("\n")

end class PSL::Core::Output_Stream

abstract interface PSL::Core::Input_Stream<> is
    func Readln(var Input_Stream) -> optional Univ_String
    func Close(var optional Input_Stream)
end interface PSL::Core::Input_Stream

interface PSL::Core::File_Output_Stream<> extends Output_Stream<> is
    func Create(var IO; Name : Univ_String) -> optional File_Output_Stream
      is import(#create_output_file)
    func Append(var IO; Name : Univ_String) -> optional File_Output_Stream
      is import(#append_output_file)
    func Flush(var File_Output_Stream)
      is import(#flush_output_file)
    func Close(var optional File_Output_Stream)
      is import(#close_output_file)

    func Print(var File_Output_Stream; Univ_String)
      is import(#print_to_file)
end interface PSL::Core::File_Output_Stream

class PSL::Core::File_Output_Stream is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::File_Output_Stream

interface PSL::Core::File_Input_Stream<> extends Input_Stream is
    func Open(var IO; Name : Univ_String) -> optional File_Input_Stream
      is import(#open_input_file)
    func Close(var optional File_Input_Stream)
      is import(#close_input_file)
    func Readln(var File_Input_Stream) -> optional Univ_String
      is import(#read_from_file)
end interface PSL::Core::File_Input_Stream

class PSL::Core::File_Input_Stream is
    const Name : Univ_String;
    const Index : Univ_Integer
  exports
end class PSL::Core::File_Input_Stream

interface PSL::Core::Standard_Output_Stream<> extends Output_Stream is
  //  Output stream for one of the "standard" output channels
    type Output_Channel_Enum is Enum<[#stdout, #stderr]>
    const Channel : Output_Channel_Enum

    func Print(var Standard_Output_Stream; Univ_String)
      is import(#print_to_standard_file)

    func Flush(var Standard_Output_Stream)
      is import(#flush_standard_file)

    func Close(var optional Standard_Output_Stream)
      is Flush
end interface PSL::Core::Standard_Output_Stream

func PSL::Test::Test_File (Name, X, Y : Univ_String; Z : Univ_Integer):
    var IO := IO::Get_IO()
    var File := File_Output_Stream::Create(IO, Name);
    const Pi := 3.14159265389793
    const True := Boolean::#true

    IO.Println ("Writing to file: " | Name)

    File.Print ("Pi = ")
    Output_Stream::Print (File, Pi)
    File.Print (", True prints as ")
    Print (File, True)
    Print (File, '\n')
    File.Print ("X = \"" | X | '"')
    Println (File, ", Y = \"" | Y | '"')
    IO.Print ("Give me somethin: ")
    var Inp := IO.Readln()
    IO.Println ("You gave me: \"" | Inp | '"')
    File.Println ("User input = \"" | Inp | '"')
    File.Close();

    var Inp_File := File_Input_Stream::Open(IO, Name)
    IO.Println ("Contents of file " | Name)
    loop
        const Line := Inp_File.Readln()
        if Line is null then
            exit loop
        end if
        IO.Println(Line)
    end loop

    IO.Println("All done")

end func PSL::Test::Test_File
interface PSL::Short_Names<> is
   type Int is Univ_Integer<>
   type Char is Univ_Character<>
   type String is Univ_String<>
   type Real is Univ_Real<>
   type Bool is Boolean<>
   //interface Arr<Element_Type is Assignable<>> extends Basic_Array<Element_Type> is
   //end interface Arr
end interface PSL::Short_Names
interface PSL::Core::Operation_Descriptor<> is
   //  For internal use only
   const Routine_Addr : Univ_Integer;
   const Routine_Index : Univ_Integer;
   const Static_Link : Univ_Integer;
end interface PSL::Core::Operation_Descriptor;

func PSL::Test::Test_Operation_Descriptor() is
   //  For this Type to appear in the type table,
   //  it must be used. Don't delete this function
   const OD : PSL::Core::Operation_Descriptor := (0, 0, 0);
   Println(OD.Static_Link);
end func PSL::Test::Test_Operation_Descriptor;

interface PSL::Containers::Indexed_Set<Element_Type is Hashable<>;
                                       Id_Type is Integer<>> is
  //  A set where each element is assigned a unique ID when it is first
  //  added to the set, and the Id can be used to retrieve the element later.

   op "[]"() -> Indexed_Set
     // Create an empty indexed set

   func Get_Unique_Id(var Indexed_Set; Element_Type) -> Id_Type
     // Add element to set if not there; in any case return the unique Id
     // for the element.

   op "indexing"(ref const Indexed_Set; Id : Id_Type)
    -> ref const Element_Type
     //  Return ref to element in Indexed_Set with given Id

   op "index_set"(Indexed_Set) -> Countable_Range<Id_Type>
     //  Return set of Ids of all elements in the Indexed_Set

   op "in"(Id : Id_Type; Indexed_Set) -> Boolean
     //  Return #true if Id is in the range of the Indexed_Set

   func All_Ids(Indexed_Set) -> Countable_Range<Id_Type> is "index_set"
     //  Set of all ids in index set

   func Count(Indexed_Set) -> Univ_Integer
     //  Count of elements in the indexed set

   op "magnitude"(Indexed_Set) -> Univ_Integer is Count

end interface PSL::Containers::Indexed_Set

class PSL::Containers::Indexed_Set is
   interface Bucket<> is
      //  Linked list of indices of all elements with the same hash value
      var Id : Id_Type
      var Next : optional Bucket
   end interface Bucket

   const Empty_Bucket : optional Bucket := null

   interface With_Hash<> is
      //  Save a copy of the Hash value to avoid repeatedly re-invoking Hash
      var Elem : Element_Type
      var Saved_Hash : Univ_Integer
   end interface With_Hash

   const Initial_Size := 4  //  Length of initial hash-table backbone

   var IS_Vector   : Vector<With_Hash> := []
   var IS_Hash_Tab : Vector<optional Bucket> :=
     Create(Initial_Size, Empty_Bucket)
  exports
   op "[]"() -> Indexed_Set is
     // Create an empty indexed set
      return ()  //  Everything defaults properly
   end op "[]"

   op "indexing"(ref const Indexed_Set; Id : Id_Type)
     -> ref const Element_Type is
     //  Return ref to element in Indexed_Set with given Id
      return Indexed_Set.IS_Vector[Id].Elem
   end op "indexing"

   op "index_set"(Indexed_Set) -> Countable_Range<Id_Type> is
      return 1 .. |Indexed_Set.IS_Vector|
   end op "index_set"

   op "in"(Id : Id_Type; Indexed_Set) -> Boolean is
     //  Return #true if Id is in the range of the Indexed_Set
      return Id in Indexed_Set.All_Ids()
   end op "in"

   func Get_Unique_Id(var Indexed_Set; Elem : Element_Type) -> Id_Type is
     // Add element to set if not there; in any case return the unique Id
     // for the element.

      const Hash_Val := Hash(Elem)

      //  Search to see if it is already in table
      var Index := Hash_Val mod |Indexed_Set.IS_Hash_Tab| + 1
      ref Bucket_List => Indexed_Set.IS_Hash_Tab[Index]
      for B => Bucket_List then B.Next while B not null loop
         ref Elem_In_Table => Indexed_Set.IS_Vector[B.Id]
         if Elem_In_Table.Saved_Hash == Hash_Val
           and then Elem_In_Table.Elem == Elem
         then
            //  Already in table
            return B.Id
         end if
      end loop

      //  Not in table; add to end of vector
      var Elem_With_Hash : With_Hash for Indexed_Set :=
        (Elem => Elem, Saved_Hash => Hash_Val)
      Indexed_Set.IS_Vector <|= Elem_With_Hash

      //  Assign it a unique id based on position in Indexed_Set
      const New_Id : Id_Type := |Indexed_Set.IS_Vector|

      //  Add to appropriate bucket
      Bucket_List := (Id => New_Id, Next <== Bucket_List)

      //  Now check to see if hash table should be expanded
      if |Indexed_Set.IS_Vector| > 2 * |Indexed_Set.IS_Hash_Tab| then
         //  Table was already at double density.  Expand IS_Hash_Tab
         var Old_HTab <== Indexed_Set.IS_Hash_Tab
         const New_Len := |Old_HTab| * 2
         //  Create hash table with double the number of buckets
         Indexed_Set.IS_Hash_Tab := Create(New_Len, Empty_Bucket)
         for each Old_Bucket of Old_HTab loop
            for B => Old_Bucket then B.Next while B not null loop
               ref Old_Elem => Indexed_Set.IS_Vector[B.Id]
               ref New_Bucket =>
                 Indexed_Set.IS_Hash_Tab[Old_Elem.Saved_Hash mod New_Len + 1]
               //  Insert at front
               New_Bucket := (Id => B.Id, Next <== New_Bucket)
            end loop
         end loop
      end if // Expanding table

      return New_Id
   end func Get_Unique_Id

   func Count(Indexed_Set) -> Univ_Integer is (|Indexed_Set.IS_Vector|)
     //  Count of elements in the indexed set

end class PSL::Containers::Indexed_Set

func PSL::Test::Test_Indexed_Set() is
   type String_Id is new Integer<0 .. 1_000>
   type String_Set is Indexed_Set<Univ_String, String_Id>

   var SST : String_Set := []

   const Hello_Id := SST.Get_Unique_Id("Hello")
   const There_Id := SST.Get_Unique_Id("There")
   const My_Id := SST.Get_Unique_Id("My")
   const Friend_Id := SST.Get_Unique_Id("Friend")

   const Ids : Vector<String_Id> := [Hello_Id, There_Id, My_Id, Friend_Id]

   Print("Secret message:")
   for each Id of Ids forward loop
      Print(" " | SST[Id])
   end loop
   Print('\n')
end func PSL::Test::Test_Indexed_Set

interface PSL::Containers::Ordered_Map
  <Key_Type is Comparable<>; Value_Type is Assignable<>> is
  // An ordered map module, allowing iterating over the keys in
  // forward or reverse order.

    interface Pair<> extends Key_Value<Key_Type, Value_Type> is
       op "=?"(Left, Right : Pair) -> Ordering is (Left.Key =? Right.Key)
    end interface Pair

    op "[]"() -> Ordered_Map

    op "|="(var Left : Ordered_Map; Right : Pair)
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.

    op "|"(Left : Ordered_Map; Right : Pair) -> Ordered_Map
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.

    op "<|="(var Left : Ordered_Map; var Right : optional Pair)
        // Move Key/Value pair into map, leaving Right null

    op "<|="(var Left : Ordered_Map; var Right : Ordered_Map)
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.

    op "+="(var Left : Ordered_Map; Right : Pair) is "|="
        // A synonym for adding a key=>value pair

    op "in"(Left : Key_Type; Right : Ordered_Map) -> Boolean
        // Return True if given key has a mapping in the Map

    op "-="(var M : Ordered_Map; Key : Key_Type)   // aka Exclude
        // Remove mapping for Right, if present

    op "index_set"(M : Ordered_Map) -> Ordered_Set<Key_Type>
        // Return set of keys with mappings

    func Keys(M : Ordered_Map) -> Ordered_Set<Key_Type> is "index_set"

    op "indexing"(ref M : Ordered_Map; Key : Key_Type) {Key in M}
      -> ref Value_Type
        // Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Ordered_Map; Key : Key_Type) 
      -> ref var optional Value_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Remove_First(var M : Ordered_Map) -> optional Pair
        // Remove mapping from the Map with lowest key value.
        // Return null if Map is empty

    func Remove_Last(var M : Ordered_Map) -> optional Pair
        // Remove mapping from the Map with highest key value.
        // Return null if Map is empty

    func Remove_Any(var M : Ordered_Map) -> optional Pair
        // Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Ordered_Map) -> Univ_Integer
        // Number of mappings in the table

    op "magnitude"(Ordered_Map) -> Univ_Integer is Count

    func Is_Empty(M : Ordered_Map) -> Boolean
        // Return True if no mappings in the table

    func Dump_Statistics(M : Ordered_Map)
      // A debugging routine to show bucket sizes of Map

end interface PSL::Containers::Ordered_Map

class PSL::Containers::Ordered_Map is
    var Items : optional AA_Tree<Pair> := []
    var Count := 0
  exports
    op "[]"() -> Ordered_Map is (Items => [])

    op "|="(var Left : Ordered_Map; Right : Pair) is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.
        "var_indexing"(Left, Right.Key) := Right.Value
    end op "|="

    op "|"(Left : Ordered_Map; Right : Pair) -> Result : Ordered_Map is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.
        Result := Left
        Result |= Right
    end op "|"

    op "<|="(var Left : Ordered_Map; var Right : optional Pair) is
        // Move Key/Value pair into map, leaving Right null
        "var_indexing"(Left, Right.Key) <== Right.Value
        Right := null
    end op "<|="

    op "<|="(var Left : Ordered_Map; var Right : Ordered_Map) is
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.
        if Left.Count == 0 then
            Left.Items <== Right.Items
            Left.Count := Right.Count
        else
            // Iterate through the tree
            loop
                // Extract element from right
                var Elem for Left := Remove_Any(Right.Items)

                if Elem is null then
                    Left.Count := Count(Left.Items)
                    return   // All done
                end if

                Left.Items <|= Elem

            end loop
        end if
    end op "<|="

    op "in"(Left : Key_Type; Right : Ordered_Map) -> Boolean is
        // Return True if given key has a mapping in the Map
        const P : Pair := (Key => Left, Value => null)
        return P in Right.Items
    end op "in"

    op "-="(var M : Ordered_Map; Key : Key_Type) is  // aka Exclude
        // Remove mapping for Right, if present
        Delete(M.Items, (Key => Key, Value => null))
        M.Count := Count(M.Items)
    end op "-="

    op "index_set"(M : Ordered_Map) -> Ordered_Set<Key_Type>
      is ([for Item in M.Items => Item.Key])
        // Return set of keys with mappings

    op "indexing"(ref M : Ordered_Map; Key : Key_Type) {Key in M}
      -> ref Value_Type is
        // Used for references to M[Key]; requires the Key to be in M.
        return Unsafe_Indexing(M.Items, (Key => Key, Value => null)).Value
    end op "indexing"

    op "var_indexing"(ref var M : Ordered_Map; Key : Key_Type) 
      -> ref var optional Value_Type is
        // Used for assignments to M[Key]; Key is added to M if not present

        if Key not in M then
            //  Insert new item with Value null
            Insert(M.Items, (Key => Key, Value => null))
            M.Count += 1
        end if

        //  Return reference to item
        return "indexing"(M, Key)
    end op "var_indexing"

    func Remove_First(var M : Ordered_Map) -> Result : optional Pair is
        // Remove mapping from the Map with lowest key value.
        // Return null if Map is empty
        Result := Remove_First(M.Items)
        if Result not null then
           M.Count -= 1
        end if
    end func Remove_First

    func Remove_Last(var M : Ordered_Map) -> Result : optional Pair is
        // Remove mapping from the Map with highest key value.
        // Return null if Map is empty
        Result := Remove_Last(M.Items)
        if Result not null then
           M.Count -= 1
        end if
    end func Remove_Last

    func Remove_Any(var M : Ordered_Map) -> Result : optional Pair is
        // Remove one mapping from the Map.  Return null if Map is empty
        Result := Remove_Any(M.Items)
        if Result not null then
           M.Count -= 1
        end if
    end func Remove_Any

    func Count(M : Ordered_Map) -> Univ_Integer is (M.Count)
        // Number of mappings in the table

    func Is_Empty(M : Ordered_Map) -> Boolean is (M.Count == 0)
        // Return True if no mappings in the table

    func Dump_Statistics(M : Ordered_Map) is (null)
      // A debugging routine to show bucket sizes of Map

end class PSL::Containers::Ordered_Map

func PSL::Test::Test_Ordered_Map() is
    var M : Ordered_Map<Univ_Integer, Univ_String> := []
    
    M |= [3 => "three"]
    M |= [1 => "one"]
    M |= [5 => "five"]

    Println("M = [" |
     (for (each [K => V] of M forward; Sep := "" then ", ") =>
        <""> | Sep | K | " => " | V) | "]")

    M |= [2 => "deux"]
    M |= [1 => "un"]
    M |= [3 => "trois"]
    M |= [5 => "cinq"]

    Println("French M = [" |
     (for (each [K => V] of M forward; Sep := "" then ", ") =>
        <""> | Sep | K | " => " | V) | "]")

end func PSL::Test::Test_Ordered_Map
interface PSL::Containers::Bit_Set<Element_Type is Countable<>>
  implements
   Ordered_Set<Element_Type> is

    op "[]"() -> Bit_Set

    func Singleton(Elem : Element_Type) -> Bit_Set

    op ".."(Left, Right : Element_Type) -> Bit_Set
    op "<.."(Left, Right : Element_Type) -> Bit_Set
    op "..<"(Left, Right : Element_Type) -> Bit_Set
    op "<..<"(Left, Right : Element_Type) -> Bit_Set

    func Create(Range : Countable_Range<Element_Type>; Val : Boolean)
      -> Bit_Set

    op "|"(Left, Right : Element_Type) -> Bit_Set
    op "|"(Left : Bit_Set; Right : Element_Type) -> Bit_Set
    op "|"(Left : Element_Type; Right : Bit_Set) -> Bit_Set
    op "|"(Left : Bit_Set; Right : Bit_Set) -> Bit_Set

    op "|="(var Left : Bit_Set; Right : Bit_Set)

    op "|="(var Left : Bit_Set; Right : Element_Type)
        // Add element to Bit_Set.

    op "<|="(var Left : Bit_Set; var Right : optional Element_Type)
        // Move element into Bit_Set.

    op "<|="(var Left : Bit_Set; var Right : Bit_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "in"(Left : Element_Type; Right : Bit_Set) -> Boolean<>

    op "=?"(Left, Right : Bit_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    op "or"(Left, Right : Bit_Set) -> Bit_Set is "|"  // Union
    op "or="(var Left : Bit_Set; Right : Bit_Set) is "|="

    op "+"(Left, Right : Bit_Set) -> Bit_Set is "|"   // Union
    op "+="(var Left : Bit_Set; Right : Bit_Set) is "|="
    op "+="(var Left : Bit_Set; Right : Element_Type) is "|="   // aka Include

    op "and"(Left, Right : Bit_Set) -> Bit_Set
        // Intersection
    op "and="(var Left : Bit_Set; Right : Bit_Set)

    op "xor"(Left, Right : Bit_Set) -> Bit_Set
        // Symmetric difference
    op "xor="(var Left : Bit_Set; Right : Bit_Set)

    op "-"(Left, Right : Bit_Set) -> Bit_Set
        // Bit_Set difference

    op "-="(var Left : Bit_Set; Right : Bit_Set)
        // Compute Bit_Set difference

    op "-="(var S : Bit_Set; Elem : Element_Type)   // aka Exclude
        // Remove one element, if present

    op "indexing"(S : Bit_Set; Elem : Element_Type) -> Boolean is (Elem in S)

    func Count(S : Bit_Set) -> Univ_Integer

    op "magnitude"(Bit_Set) -> Univ_Integer is Count

    func Is_Empty(S : Bit_Set) -> Boolean<>

    func Remove_First(var S : Bit_Set) -> optional Element_Type
      // Remove and return the first element of the Bit_Set S
    func Remove_Last(var S : Bit_Set) -> optional Element_Type
      // Remove and return the last element of the Bit_Set S
    func Remove_Any(var S : Bit_Set) -> optional Element_Type
      // Remove and return an arbitrary element of the Bit_Set S

    func First(S : Bit_Set) -> optional Element_Type
      // Return the first element of the Bit_Set S;
      // return null if S is empty.
    func Last(S : Bit_Set) -> optional Element_Type
      // Return the last element of the Bit_Set S;
      // return null if S is empty.
    func Any_Element(S : Bit_Set) -> optional Element_Type
      // Return an arbitrary element of the Bit_Set S;
      // return null if S is empty.

end interface PSL::Containers::Bit_Set


class PSL::Containers::Bit_Set is
    var Bit_Arr : Packed_Array<Boolean, Indexed_By => Element_Type>
       //  TBD: should add "|", "and", "or" to Packed_Array
    //  When created: Bit_Arr[Bit_Arr.First()] == #true
    //            and  Bit_Arr[Bit_Arr.Last()] == #true
    //  This can change due to "and" and "-"
    var Count : Univ_Integer
  exports
    op "[]"() -> Bit_Set is ((Bit_Arr => [], Count => 0))

    func Singleton(Elem : Element_Type) -> Bit_Set
      is ((Bit_Arr => [Elem => #true], Count => 1))

    op ".."(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left .. Right, #true),
        Count => Max (Right - Left + 1, 0)))
    
    op "<.."(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left <.. Right, #true),
        Count => Max (Right - Left, 0)))
    
    op "<..<"(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left <..< Right, #true),
        Count => Max (Right - Left - 1, 0)))
    
    op "..<"(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left ..< Right, #true),
        Count => Max (Right - Left, 0)))
    
    func Create(Range : Countable_Range<Element_Type>; Val : Boolean)
      -> Bit_Set is ((Bit_Arr => Create(Range, Val),
            Count => Val? |Range| : 0))

    op "|"(Left, Right : Element_Type) -> Result : Bit_Set is
       const Low := Min(Left, Right)
       const High := Max(Left, Right)
       Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
       Result.Bit_Arr[Low] := #true
       Result.Bit_Arr[High] := #true
       Result.Count := Low==High? 1 : 2
    end op "|"
       
    op "|"(Left : Bit_Set; Right : Element_Type) -> Result : Bit_Set is
       if Left.Count == 0 then
          Result := Singleton(Right)
       elsif Right in Left.Bit_Arr.Bounds() then
          //  Left already encompasses Right
          Result := Left
          if not Result.Bit_Arr[Right] then
             Result.Bit_Arr[Right] := #true
             Result.Count += 1
          end if
       else
          //  Right is outside limits of Left
          const Low := Min(Left.Bit_Arr.First(),
                       Max(Right - Left.Count, Element_Type::First()))
          const High := Max(Left.Bit_Arr.Last(), 
                       Min(Right + Left.Count, Element_Type::Last()))
          // Println("Growing bounds of Left from " | Left.Bit_Arr.First() |
          //   " .. " | Left.Bit_Arr.Last() | " to " | Low | " .. " | High)
          Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
          //  Copy over all the #true values from Left
          for each [I => V] of Left.Bit_Arr {V} loop
             Result.Bit_Arr[I] := #true
          end loop
          //  And the Right value
          Result.Bit_Arr[Right] := #true
          Result.Count := Left.Count + 1
       end if;
    end op "|"

    op "|"(Left : Element_Type; Right : Bit_Set) -> Bit_Set
     is (Right | Left)
        
    op "|"(Left : Bit_Set; Right : Bit_Set) -> Result : Bit_Set is
       if Left.Count == 0 then
          return Right
       elsif Right.Count == 0 then
          return Left
       end if

       const Low := Min(Left.Bit_Arr.First(), Right.Bit_Arr.First())
       const High := Max(Left.Bit_Arr.Last(), Right.Bit_Arr.Last())
       if Low == Left.First() and then High == Left.Last() then
          //  Left subsumes Right, start from Left
          Result := Left;
       elsif Low == Right.First() and then High == Right.Last() then
          //  Rights subsumes Left
          return Right | Left
       else
          //  Neither is subsumed, create a new value
          Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
          for each [I => V] of Left.Bit_Arr {V} loop
             Result.Bit_Arr[I] := #true
          end loop
          Result.Count := Left.Count
       end if
       for each [I => V] of Right.Bit_Arr {V and not Result.Bit_Arr[I]} loop
          //  Set bit-arr true for the elements of Right that are not in Left
          Result.Bit_Arr[I] := #true
          Result.Count += 1
       end loop
    end op "|"

    op "|="(var Left : Bit_Set; Right : Bit_Set) is
       if Left.Bit_Arr.First() <= Right.Bit_Arr.First()
         and then Left.Bit_Arr.Last() >= Right.Bit_Arr.Last()
       then
          for each [I => V] of Right.Bit_Arr {V and not Left.Bit_Arr[I]} loop
             Left.Bit_Arr[I] := #true
             Left.Count += 1
          end loop
       else
          Left := Left | Right
       end if
    end op "|="

    op "|="(var Left : Bit_Set; Right : Element_Type) is
       // Add element to Bit_Set.
       if Right in Left.Bit_Arr.Bounds() then
          //  Right is within bounds of Left's bit array
          if not Left.Bit_Arr[Right] then
             Left.Bit_Arr[Right] := #true
             Left.Count += 1
          end if
       else
          //  Need to create a new object
          Left := Left | Right
       end if
    end op "|="

    op "<|="(var Left : Bit_Set; var Right : optional Element_Type) is
        // Move element into Bit_Set.
        // Not worth doing anything special for a bit set
        Left |= Right
        Right := null
    end op "<|="

    op "<|="(var Left : Bit_Set; var Right : Bit_Set) is
        // Move all elements of Right into Left, leaving Right empty.
        Left |= Right
        Right := []
    end op "<|="

    op "in"(Left : Element_Type; Right : Bit_Set) -> Boolean<> is
       return Left in Right.Bit_Arr.Bounds()
         and then
           Right.Bit_Arr[Left]
    end op "in"

    op "=?"(Left, Right : Bit_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Right_Count_In_Overlap := 0
        for each [I => Left_V] of Left.Bit_Arr loop
           const Right_V := (I in Right)
           if Left_V != Right_V then
              case Left.Count =? Right.Count of
                 [#equal] =>
                    //  Left can't be subset or superset
                    return #unordered
                 [#less] =>
                    if Left_V > Right_V then
                       //  Left can't be subset or superset
                       return #unordered
                    end if
                 [#greater] =>
                    if Left_V < Right_V then
                       //  Left can't be subset or superset
                       return #unordered
                    end if
              end case
           end if
           if Right_V then
              //  Keep track of number of elements in Right when only
              //  looking at elements in Left's Bit_Arr
              Right_Count_In_Overlap += 1
           end if
        end loop
        case Left.Count =? Right.Count of
           [#equal] =>
              //  Must be equal since same count and equal
              //  in all overlapping items
              return #equal
           [#less] =>
              //  Left is a proper subset of right
              return #less
           [#greater] =>
              if Right.Count > Right_Count_In_Overlap then
                 //  Right has some elements that are not in Left's Bit_Arr
                 return #unordered
              else
                 //  All #true elements of Right have been accounted for,
                 //  so Left is a proper superset of Right
                 return #greater
              end if
        end case
    end op "=?"

    op "and"(Left, Right : Bit_Set) -> Result : Bit_Set is
        // Intersection
        Result := Left
        Result and= Right
    end op "and"

    op "and="(var Left : Bit_Set; Right : Bit_Set) is
        for each [I => V] of Right.Bit_Arr {not V and I in Left} loop
           Left.Bit_Arr[I] := #false
           Left.Count -= 1
        end loop
    end op "and="

    op "xor"(Left, Right : Bit_Set) -> Result : Bit_Set is
       // Symmetric difference
       if Left.Count == 0 then
          return Right
       elsif Right.Count == 0 then
          return Left
       end if

       const Low := Min(Left.Bit_Arr.First(), Right.Bit_Arr.First())
       const High := Max(Left.Bit_Arr.Last(), Right.Bit_Arr.Last())
       if Low == Left.First() and then High == Left.Last() then
          //  Left subsumes Right, start from Left
          Result := Left;
       elsif Low == Right.First() and then High == Right.Last() then
          //  Rights subsumes Left
          return Right xor Left
       else
          //  Neither is subsumed, create a new value
          Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
          for each [I => V] of Left.Bit_Arr {V} loop
             Result.Bit_Arr[I] := #true
          end loop
          Result.Count := Left.Count
       end if
       for each [I => V] of Right.Bit_Arr {V} loop
          //  Invert element of Result when Right is #true
          if Result.Bit_Arr[I] then
             Result.Bit_Arr[I] := #false
             Result.Count -= 1
          else
             Result.Bit_Arr[I] := #true
             Result.Count += 1
          end if
       end loop
    end op "xor"

    op "xor="(var Left : Bit_Set; Right : Bit_Set) is
       if Left.Bit_Arr.First() <= Right.Bit_Arr.First()
         and then Left.Bit_Arr.Last() >= Right.Bit_Arr.Last()
       then
          //  Right is subsumed by Left
          for each [I => V] of Right.Bit_Arr {V} loop
             //  Invert I'th element of Left
             if Left.Bit_Arr[I] then
                Left.Bit_Arr[I] := #false
                Left.Count -= 1
             else
                Left.Bit_Arr[I] := #true
                Left.Count += 1
             end if
          end loop
       else
          //  Need to create a new object
          Left := Left xor Right
       end if
    end op "xor="

    op "-"(Left, Right : Bit_Set) -> Result : Bit_Set is
        // Bit_Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-="(var Left : Bit_Set; Right : Bit_Set) is
        // Compute Bit_Set difference
        if Left.Count == 0 then
           //  Nothing to do
           return
        end if

        for I in Max(Left.Bit_Arr.First(), Right.Bit_Arr.First()) ..
          Min(Left.Bit_Arr.Last(), Right.Bit_Arr.Last()) loop
           //  Only need to visit overlapping part of ranges
           if Right.Bit_Arr[I] and then Left.Bit_Arr[I] then
              Left.Bit_Arr[I] := #false
              Left.Count -= 1
           end if
        end loop
    end op "-="

    op "-="(var S : Bit_Set; Elem : Element_Type) is   // aka Exclude
        // Remove one element, if present
        if S.Count == 0 then
           //  Nothing to do
           return
        end if

        if Elem in S.Bit_Arr.Bounds() and then S.Bit_Arr[Elem] then
            S.Bit_Arr[Elem] := #false
            S.Count -= 1
        end if
    end op "-="

    func Count(S : Bit_Set) -> Univ_Integer is (S.Count)

    func Is_Empty(S : Bit_Set) -> Boolean<> is (S.Count == 0)

    func Remove_First(var S : Bit_Set) -> optional Element_Type is
      // Remove and return the first element of the Bit_Set S
      for each [I => V] of S.Bit_Arr {V} forward loop
         S.Bit_Arr[I] := #false
         S.Count -= 1
         return I
      end loop
    end func Remove_First

    func Remove_Last(var S : Bit_Set) -> optional Element_Type is
      // Remove and return the last element of the Bit_Set S
      for each [I => V] of S.Bit_Arr {V} reverse loop
         S.Bit_Arr[I] := #false
         S.Count -= 1
         return I
      end loop
    end func Remove_Last

    func Remove_Any(var S : Bit_Set) -> optional Element_Type is
      // Remove and return an arbitrary element of the Bit_Set S
       if S.Count mod 2 == 0 then
          return Remove_Last(S)
       else
          return Remove_First(S)
       end if
    end func Remove_Any

    func First(S : Bit_Set) -> optional Element_Type is
      // Return the first element of the Bit_Set S;
      // return null if S is empty.
      for each [I => V] of S.Bit_Arr {V} forward loop
         return I
      end loop
    end func First

    func Last(S : Bit_Set) -> optional Element_Type is
      // Return the last element of the Bit_Set S;
      // return null if S is empty.
      for each [I => V] of S.Bit_Arr {V} reverse loop
         return I
      end loop
    end func Last

    func Any_Element(S : Bit_Set) -> optional Element_Type is
      // Return an arbitrary element of the Bit_Set S;
       if S.Count mod 2 == 0 then
          return Last(S)
       else
          return First(S)
       end if
    end func Any_Element

end class PSL::Containers::Bit_Set

func PSL::Test::Test_Bit_Set(Args : Basic_Array<Univ_String>) is
   type BSI is Bit_Set<Integer<0 .. 199>>

   func Print_Set(S : BSI) is
      for (V in S; Sep := "[" then ", ") forward loop
         Print(Sep | V)
      end loop
      Println("]")
   end func Print_Set

   Println("Bit_Set of 3..33 = ")
   Print_Set(3 .. 33)

   var Test_Set : BSI

   if |Args| == 0 then
      Test_Set := [1, 3, 5, 7, 9]
   else
      Test_Set := []
      for each Arg of Args forward loop
         const Val : optional Univ_Integer := From_String(Arg)
         if Val is null then
            Println(Arg | ": not an integer")
         else
            Test_Set |= Val
         end if
      end loop
   end if

   Println ("Initial set:")
   Print_Set(Test_Set)

   Println ("Initial set xor 3..33 = ")
   Print_Set(Test_Set xor (3..33))

   Println ("(Initial set xor 3.33) and Create(15..20, #false) =")
   Print_Set((Test_Set xor (3..33)) and Create(15..20, #false))

   var Ran : Random := Start()
   for I in 1 .. 1000 forward loop
      const R := Ran.Next() mod 200
      if I mod 2 == 1 then
         Println("Adding " | R)
         Test_Set += R
      else
         Println("Subtracting " | R)
         Test_Set -= R
      end if
   end loop

   Println ("After 500 random adds and 500 random subtracts there are " |
     Test_Set.Count() | " left in set:")
   Print_Set(Test_Set)

end func PSL::Test::Test_Bit_Set
